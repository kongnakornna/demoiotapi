import 'dotenv/config';
export declare class RedisHelper {
    private static instance;
    private client;
    private pubClient;
    private subClient;
    private isConnected;
    private isInitialized;
    private connectionPromise;
    private IoRedis;
    private readonly logger;
    private constructor();
    static getInstance(): RedisHelper;
    initialize(): Promise<void>;
    initializeRedis(): Promise<void>;
    setupEventHandlers(): void;
    connect(): Promise<boolean>;
    healthCheck(): Promise<boolean>;
    getClient(): any;
    getPubClient(): any;
    getSubClient(): any;
    isReady(): boolean;
    disconnect(): Promise<void>;
    clearAllCache(): Promise<boolean>;
    clearCurrentDBCache(): Promise<boolean>;
    clearCacheByPattern(pattern: string): Promise<number>;
    clearMultipleCache(keys: string[]): Promise<number>;
    clearCacheByPatternSafely(pattern: string, batchSize?: number): Promise<{
        totalDeleted: number;
        batches: number;
    }>;
    clearExpiredCache(): Promise<{
        checked: number;
        expired: number;
    }>;
    clearCacheByTags(tags: string[]): Promise<number>;
    tagCache(key: string, tags: string[]): Promise<boolean>;
    getCacheStats(): Promise<{
        totalKeys: number;
        memoryUsage: string;
        connected: boolean;
        databaseSize: number;
    }>;
    set(key: string, value: any, ttl?: number): Promise<boolean>;
    get(key: string): Promise<any>;
    del(key: string): Promise<boolean>;
    exists(key: string): Promise<boolean>;
    expire(key: string, ttl: number): Promise<boolean>;
    ttl(key: string): Promise<number>;
    lpush(key: string, ...values: string[]): Promise<number>;
    rpush(key: string, ...values: string[]): Promise<number>;
    lpop(key: string): Promise<string | null>;
    rpop(key: string): Promise<string | null>;
    lrange(key: string, start: number, stop: number): Promise<string[]>;
    lrem(key: string, count: number, value: string): Promise<number>;
    llen(key: string): Promise<number>;
    lindex(key: string, index: number): Promise<string | null>;
    lset(key: string, index: number, value: string): Promise<void>;
    ltrim(key: string, start: number, stop: number): Promise<void>;
    hset(key: string, field: string, value: any): Promise<number>;
    hget(key: string, field: string): Promise<any>;
    hgetall(key: string): Promise<{
        [field: string]: any;
    }>;
    hdel(key: string, ...fields: string[]): Promise<number>;
    hexists(key: string, field: string): Promise<boolean>;
    sadd(key: string, ...members: string[]): Promise<number>;
    smembers(key: string): Promise<string[]>;
    srem(key: string, ...members: string[]): Promise<number>;
    sismember(key: string, member: string): Promise<boolean>;
    scard(key: string): Promise<number>;
    zadd(key: string, ...args: (number | string)[]): Promise<number>;
    zrange(key: string, start: number, stop: number, withScores?: boolean): Promise<string[]>;
    zrem(key: string, ...members: string[]): Promise<number>;
    publish(channel: string, message: any): Promise<number>;
    subscribe(channel: string, callback: (message: any) => void): void;
    unsubscribe(channel: string): void;
    pipeline(operations: Array<{
        command: string;
        args: any[];
    }>): Promise<any[]>;
    multi(operations: Array<{
        command: string;
        args: any[];
    }>): Promise<any[]>;
    keys(pattern: string): Promise<string[]>;
    flushall(): Promise<void>;
    flushdb(): Promise<void>;
    incr(key: string): Promise<number>;
    decr(key: string): Promise<number>;
    incrby(key: string, increment: number): Promise<number>;
    decrby(key: string, decrement: number): Promise<number>;
    SetCacheData(setData: any): Promise<boolean>;
    SetCacheKey(setData: any): Promise<boolean>;
    UpdateCacheData(setData: any): Promise<any>;
    GetCacheData(keycache: any): Promise<any>;
    GetCacheData2(keycache: any): Promise<any>;
    DeleteCacheData(keycache: any): Promise<boolean>;
    OTP(keycache: any): Promise<{
        key: any;
        time: number;
        OTP: any;
        day_th: string;
        day_en: string;
        timestamp: any;
        time_start: Date;
    }>;
    GetAllCacheDatakeys(): Promise<{
        [key: string]: any;
    }>;
}
export declare const redisHelper: RedisHelper;
export declare class CacheDataOne {
    private helper;
    constructor();
    SetCacheData(setData: any): Promise<boolean>;
    SetCacheKey(setData: any): Promise<boolean>;
    UpdateCacheData(setData: any): Promise<any>;
    GetCacheData(keycache: any): Promise<any>;
    GetCacheData2(keycache: any): Promise<any>;
    DeleteCacheData(keycache: any): Promise<boolean>;
    OTP(keycache: any): Promise<{
        key: any;
        time: number;
        OTP: any;
        day_th: string;
        day_en: string;
        timestamp: any;
        time_start: Date;
    }>;
    lpush(key: string, ...values: string[]): Promise<number>;
    lrange(key: string, start: number, stop: number): Promise<string[]>;
    lrem(key: string, count: number, value: string): Promise<number>;
    rpush(key: string, ...values: string[]): Promise<number>;
    lpop(key: string): Promise<string | null>;
    rpop(key: string): Promise<string | null>;
    llen(key: string): Promise<number>;
    lindex(key: string, index: number): Promise<string | null>;
    lset(key: string, index: number, value: string): Promise<void>;
    ltrim(key: string, start: number, stop: number): Promise<void>;
    hset(key: string, field: string, value: any): Promise<number>;
    hget(key: string, field: string): Promise<any>;
    hgetall(key: string): Promise<{
        [field: string]: any;
    }>;
    hdel(key: string, ...fields: string[]): Promise<number>;
    hexists(key: string, field: string): Promise<boolean>;
    sadd(key: string, ...members: string[]): Promise<number>;
    smembers(key: string): Promise<string[]>;
    srem(key: string, ...members: string[]): Promise<number>;
    sismember(key: string, member: string): Promise<boolean>;
    scard(key: string): Promise<number>;
    zadd(key: string, ...args: (number | string)[]): Promise<number>;
    zrange(key: string, start: number, stop: number, withScores?: boolean): Promise<string[]>;
    zrem(key: string, ...members: string[]): Promise<number>;
    exists(key: string): Promise<boolean>;
    expire(key: string, ttl: number): Promise<boolean>;
    ttl(key: string): Promise<number>;
    keys(pattern: string): Promise<string[]>;
    flushall(): Promise<void>;
    flushdb(): Promise<void>;
    incr(key: string): Promise<number>;
    decr(key: string): Promise<number>;
    incrby(key: string, increment: number): Promise<number>;
    decrby(key: string, decrement: number): Promise<number>;
    publish(channel: string, message: any): Promise<number>;
    subscribe(channel: string, callback: (message: any) => void): void;
    unsubscribe(channel: string): void;
    healthCheck(): Promise<boolean>;
    connect(): Promise<boolean>;
    disconnect(): Promise<void>;
    isReady(): boolean;
    GetAllCacheDatakeys(): Promise<{
        [key: string]: any;
    }>;
    pipeline(operations: Array<{
        command: string;
        args: any[];
    }>): Promise<any[]>;
    multi(operations: Array<{
        command: string;
        args: any[];
    }>): Promise<any[]>;
}
export declare const cacheDataOne: CacheDataOne;
