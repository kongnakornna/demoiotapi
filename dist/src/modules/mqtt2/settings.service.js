"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var SettingsService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SettingsService = void 0;
const common_1 = require("@nestjs/common");
const typeorm_1 = require("@nestjs/typeorm");
const typeorm_2 = require("typeorm");
const user_entity_1 = require("../users/entities/user.entity");
const sduserrole_entity_1 = require("../users/entities/sduserrole.entity");
const rolesaccess_entity_1 = require("../users/entities/rolesaccess.entity");
const userrolepermission_entity_1 = require("../users/entities/userrolepermission.entity");
const devicetype_entity_1 = require("../settings/entities/devicetype.entity");
const setting_entity_1 = require("../settings/entities/setting.entity");
const location_entity_1 = require("../settings/entities/location.entity");
const type_entity_1 = require("../settings/entities/type.entity");
const sensor_entity_1 = require("../settings/entities/sensor.entity");
const group_entity_1 = require("../settings/entities/group.entity");
const mqtt_entity_1 = require("../settings/entities/mqtt.entity");
const api_entity_1 = require("../settings/entities/api.entity");
const device_entity_1 = require("../settings/entities/device.entity");
const email_entity_1 = require("../settings/entities/email.entity");
const host_entity_1 = require("../settings/entities/host.entity");
const influxdb_entity_1 = require("../settings/entities/influxdb.entity");
const line_entity_1 = require("../settings/entities/line.entity");
const nodered_entity_1 = require("../settings/entities/nodered.entity");
const schedule_entity_1 = require("../settings/entities/schedule.entity");
const sms_entity_1 = require("../settings/entities/sms.entity");
const token_entity_1 = require("../settings/entities/token.entity");
const scheduledevice_entity_1 = require("../settings/entities/scheduledevice.entity");
const deviceaction_entity_1 = require("../settings/entities/deviceaction.entity");
const deviceactionlog_entity_1 = require("../settings/entities/deviceactionlog.entity");
const deviceactionuser_entity_1 = require("../settings/entities/deviceactionuser.entity");
const devivicealarmaction_entity_1 = require("../settings/entities/devivicealarmaction.entity");
const telegram_entity_1 = require("../settings/entities/telegram.entity");
const alarmdevice_entity_1 = require("../settings/entities/alarmdevice.entity");
const alarmdeviceevent_entity_1 = require("../settings/entities/alarmdeviceevent.entity");
const scheduleprocesslog_entity_1 = require("../settings/entities/scheduleprocesslog.entity");
const alarmprocesslog_entity_1 = require("../settings/entities/alarmprocesslog.entity");
const alarmprocesslogtemp_entity_1 = require("../settings/entities/alarmprocesslogtemp.entity");
const alarmprocesslogmqtt_entity_1 = require("../settings/entities/alarmprocesslogmqtt.entity");
const alarmprocesslogemail_entity_1 = require("../settings/entities/alarmprocesslogemail.entity");
const alarmprocesslogline_entity_1 = require("../settings/entities/alarmprocesslogline.entity");
const alarmprocesslogsms_entity_1 = require("../settings/entities/alarmprocesslogsms.entity");
const alarmprocesslogtelegram_entity_1 = require("../settings/entities/alarmprocesslogtelegram.entity");
const mqtthost_entity_1 = require("../settings/entities/mqtthost.entity");
const dashboard_config_entity_1 = require("../settings/entities/dashboard-config.entity");
const mailer_1 = require("@nestjs-modules/mailer");
const format = __importStar(require("../../helpers/format.helper"));
const rxjs_1 = require("rxjs");
const redis_cache_1 = require("../../utils/cache/redis.cache");
const tz = require('moment-timezone');
var Cache = new redis_cache_1.CacheDataOne();
var md5V1 = require('md5');
const rxjs_2 = require("rxjs");
const operators_1 = require("rxjs/operators");
const microservices_1 = require("@nestjs/microservices");
const format_helper_1 = require("../../helpers/format.helper");
var moment = require('moment');
var md5 = require('md5');
require("dotenv/config");
var tzString = process.env.tzString;
var SEND_EMAIL = process.env.SEND_EMAIL;
const fs = require('fs');
const path_1 = require("path");
const filePath = (0, path_1.join)(__dirname, 'public', 'emailConfigs2.json');
require('dotenv').config();
let SettingsService = SettingsService_1 = class SettingsService {
    constructor(mailerService, entityManager, dataSource, client, dashboardConfigRepository, SettingRepository, LocationRepository, TypeRepository, SensorRepository, GroupRepository, MqttRepository, ApiRepository, DeviceTypeRepository, DeviceRepository, EmailRepository, HostRepository, InfluxdbRepository, LineRepository, NoderedRepository, ScheduleRepository, SmsRepository, TokenRepository, scheduleDeviceRepository, DeviceactionRepository, DeviceactionlogRepository, DeviceactionuserRepository, DevicealarmactionRepository, TelegramRepository, alarmDeviceRepository, alarmDeviceEventRepository, scheduleprocesslogRepository, alarmprocesslogRepository, alarmprocesslogtempRepository, alarmprocesslogmqttRepository, alarmprocesslogemailRepository, alarmprocessloglineRepository, alarmprocesslogsmsRepository, alarmprocesslogtelegramRepository, userRepository, SdUserRoleRepository, SdUserRolesAccessRepository, UserRolePermissionRepository, mqtthostRepository) {
        this.mailerService = mailerService;
        this.entityManager = entityManager;
        this.dataSource = dataSource;
        this.client = client;
        this.dashboardConfigRepository = dashboardConfigRepository;
        this.SettingRepository = SettingRepository;
        this.LocationRepository = LocationRepository;
        this.TypeRepository = TypeRepository;
        this.SensorRepository = SensorRepository;
        this.GroupRepository = GroupRepository;
        this.MqttRepository = MqttRepository;
        this.ApiRepository = ApiRepository;
        this.DeviceTypeRepository = DeviceTypeRepository;
        this.DeviceRepository = DeviceRepository;
        this.EmailRepository = EmailRepository;
        this.HostRepository = HostRepository;
        this.InfluxdbRepository = InfluxdbRepository;
        this.LineRepository = LineRepository;
        this.NoderedRepository = NoderedRepository;
        this.ScheduleRepository = ScheduleRepository;
        this.SmsRepository = SmsRepository;
        this.TokenRepository = TokenRepository;
        this.scheduleDeviceRepository = scheduleDeviceRepository;
        this.DeviceactionRepository = DeviceactionRepository;
        this.DeviceactionlogRepository = DeviceactionlogRepository;
        this.DeviceactionuserRepository = DeviceactionuserRepository;
        this.DevicealarmactionRepository = DevicealarmactionRepository;
        this.TelegramRepository = TelegramRepository;
        this.alarmDeviceRepository = alarmDeviceRepository;
        this.alarmDeviceEventRepository = alarmDeviceEventRepository;
        this.scheduleprocesslogRepository = scheduleprocesslogRepository;
        this.alarmprocesslogRepository = alarmprocesslogRepository;
        this.alarmprocesslogtempRepository = alarmprocesslogtempRepository;
        this.alarmprocesslogmqttRepository = alarmprocesslogmqttRepository;
        this.alarmprocesslogemailRepository = alarmprocesslogemailRepository;
        this.alarmprocessloglineRepository = alarmprocessloglineRepository;
        this.alarmprocesslogsmsRepository = alarmprocesslogsmsRepository;
        this.alarmprocesslogtelegramRepository = alarmprocesslogtelegramRepository;
        this.userRepository = userRepository;
        this.SdUserRoleRepository = SdUserRoleRepository;
        this.SdUserRolesAccessRepository = SdUserRolesAccessRepository;
        this.UserRolePermissionRepository = UserRolePermissionRepository;
        this.mqtthostRepository = mqtthostRepository;
        this.logger = new common_1.Logger(SettingsService_1.name);
        this.latestData = new Map();
        this.messageStream = new rxjs_2.Subject();
    }
    async sendEmail(to, subject, content) {
        console.log(`----SettingsService--------`);
        console.log(`----sendEmail---------`);
        console.log(`to--` + to);
        console.log(`subject--` + subject);
        console.log(`content--` + content);
        if (!to) {
            var to = 'cmoniots@gmail.com';
        }
        if (to == undefined || to == '') {
            var to = 'cmoniots@gmail.com';
        }
        if (!subject) {
            var subject = 'CmonIoT test send email';
        }
        if (subject == undefined || subject == '') {
            var subject = 'CmonIoT test send email';
        }
        if (!content) {
            var content = 'test send email';
        }
        if (content == undefined || content == '') {
            var content = 'test send email';
        }
        await this.mailerService.sendMail({
            to,
            subject,
            html: content,
        });
        var rs = {
            to: to,
            subject: subject,
            content: content,
        };
        console.log(`sendEmail=>`);
        console.info(rs);
        return rs;
    }
    async create_devicealarmaction(dto) {
        console.log('create_nodered=>');
        console.info(dto);
        const result = await this.DevicealarmactionRepository.save(this.DevicealarmactionRepository.create(dto));
        return result;
    }
    async get_devicealarmaction_chk(action_name) {
        try {
            const rs = await this.DevicealarmactionRepository.findOne({
                where: {
                    action_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_schedule_device(dto) {
        console.log('create_nodered=>');
        console.info(dto);
        const result = await this.scheduleDeviceRepository.save(this.scheduleDeviceRepository.create(dto));
        return result;
    }
    async delete_schedule_device(dto) {
        try {
            var device_id = dto.device_id || '';
            var schedule_id = dto.schedule_id || '';
            const query = await this.scheduleDeviceRepository.createQueryBuilder('s');
            var countRs = await query.select('COUNT(DISTINCT s.schedule_id)', 'cnt');
            query.where('1=1');
            query.andWhere('s.device_id=:device_id', { device_id: device_id });
            query.andWhere('s.schedule_id=:schedule_id', {
                schedule_id: schedule_id,
            });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = {
                    device_id: device_id,
                    schedule_id: schedule_id,
                };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.scheduleDeviceRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async delete_schedule_device_by_schedule_id(dto) {
        try {
            var device_id = dto.device_id || '';
            var schedule_id = dto.schedule_id || '';
            const query = await this.scheduleDeviceRepository.createQueryBuilder('s');
            var countRs = await query.select('COUNT(DISTINCT s.schedule_id)', 'cnt');
            query.where('1=1');
            query.andWhere('s.schedule_id=:schedule_id', {
                schedule_id: schedule_id,
            });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = { schedule_id: schedule_id };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.scheduleDeviceRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async get_data_schedule_device(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var isCount = dto.isCount;
            const query = await this.scheduleDeviceRepository.createQueryBuilder('sc');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT sc.device_id)', 'cnt');
            }
            else {
                query.select([
                    'sc.device_id AS device_id',
                    'sc.schedule_id AS schedule_id',
                ]);
            }
            query.where('1=1');
            if (schedule_id) {
                query.andWhere('sc.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            if (device_id) {
                query.andWhere('sc.device_id=:device_id', { device_id: device_id });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                query.orderBy(`sc.device_id`, 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async findscheduledevicechk(dto) {
        console.log(`schedule Device =`);
        console.info(dto);
        try {
            var device_id = dto.device_id || '';
            var schedule_id = dto.schedule_id || '';
            var sort = dto.sort;
            const query = await this.scheduleDeviceRepository.createQueryBuilder('s');
            query.select([
                's.device_id AS device_id',
                's.schedule_id AS schedule_id',
                'sc.schedule_name AS schedule_name',
            ]);
            query.leftJoin('sd_iot_schedule', 'sc', 's.schedule_id= sc.schedule_id');
            query.leftJoin('sd_iot_device', 'dv', 's.device_id= dv.device_id');
            query.where('1=1');
            if (device_id) {
                query.andWhere('s.device_id=:device_id', { device_id: device_id });
            }
            if (schedule_id) {
                query.andWhere('s.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`s.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy(`s.device_id`, 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async findscheduledevice(dto) {
        console.log(`schedule Device =`);
        console.info(dto);
        try {
            var device_id = dto.device_id || '';
            var schedule_id = dto.schedule_id || '';
            var sort = dto.sort;
            const query = await this.scheduleDeviceRepository.createQueryBuilder('s');
            query.select([
                's.device_id AS device_id',
                's.schedule_id AS schedule_id',
                'sc.schedule_name AS schedule_name',
                'sc.start AS schedule_start',
                'sc.event AS schedule_event',
                'sc.sunday AS sunday',
                'sc.monday AS monday',
                'sc.tuesday AS tuesday',
                'sc.wednesday AS wednesday',
                'sc.thursday AS thursday',
                'sc.friday AS friday',
                'sc.saturday AS saturday',
                'dv.device_name AS device_name',
                'dv.mqtt_data_value AS mqtt_data_value',
                'dv.mqtt_data_control AS mqtt_data_control',
                'dv.oid AS device_oid',
                'dv.sn AS device_sn',
            ]);
            query.leftJoin('sd_iot_schedule', 'sc', 's.schedule_id= sc.schedule_id and sc.status=1');
            query.leftJoin('sd_iot_device', 'dv', 's.device_id= dv.device_id and dv.status=1');
            query.where('1=1');
            if (device_id) {
                query.andWhere('s.device_id=:device_id', { device_id: device_id });
            }
            if (schedule_id) {
                query.andWhere('s.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            if (dto.monday) {
                query.andWhere('sc.monday=:monday', { monday: dto.monday });
            }
            if (dto.tuesday) {
                query.andWhere('sc.tuesday=:tuesday', { tuesday: dto.tuesday });
            }
            if (dto.wednesday) {
                query.andWhere('sc.wednesday=:wednesday', { wednesday: dto.wednesday });
            }
            if (dto.thursday) {
                query.andWhere('sc.thursday=:thursday', { thursday: dto.thursday });
            }
            if (dto.friday) {
                query.andWhere('sc.friday=:friday', { friday: dto.friday });
            }
            if (dto.saturday) {
                query.andWhere('sc.saturday=:saturday', { saturday: dto.saturday });
            }
            if (dto.sunday) {
                query.andWhere('sc.sunday=:sunday', { sunday: dto.sunday });
            }
            if (dto.start) {
                query.andWhere('sc.start=:start', { start: dto.start });
            }
            if (dto.event) {
                query.andWhere('sc.event=:event', { event: dto.event });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`s.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy(`s.device_id`, 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async findOnescheduledevice(schedule_id) {
        try {
            const rs = await this.scheduleDeviceRepository.findOne({
                where: {
                    schedule_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async createscheduledevice(dto) {
        const result = await this.scheduleDeviceRepository.save(this.scheduleDeviceRepository.create(dto));
        return result;
    }
    async get_ScscheduleId(schedule_id) {
        try {
            const rs = await this.scheduleDeviceRepository.findOne({
                where: {
                    schedule_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async removeScscheduleId(schedule_id) {
        try {
            this.logger.log(`Deleting sd_iot_schedule_device with setting_id: ${schedule_id}`);
            const constsetting = await this.get_ScscheduleId(schedule_id);
            if (!constsetting) {
                throw new common_1.NotFoundException(`sd_iot_schedule_device with setting_id ${schedule_id} not found`);
            }
            await this.scheduleDeviceRepository.delete(schedule_id);
        }
        catch (error) {
            this.logger.error(`Error while deleting sd_iot_schedule_device = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_ScdeviceId(device_id) {
        try {
            const rs = await this.scheduleDeviceRepository.findOne({
                where: {
                    device_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async removeScdeviceId(dto) {
        console.log(`schedule Device =`);
        console.info(dto);
        try {
            var device_id = dto.device_id || '';
            var schedule_id = dto.schedule_id || '';
            const query = await this.scheduleDeviceRepository.createQueryBuilder('s');
            var countRs = await query.select('COUNT(DISTINCT s.schedule_id)', 'cnt');
            query.where('1=1');
            query.andWhere('s.device_id=:device_id', { device_id: device_id });
            query.andWhere('s.schedule_id=:schedule_id', {
                schedule_id: schedule_id,
            });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = {
                    device_id: device_id,
                    schedule_id: schedule_id,
                };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.scheduleDeviceRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async update_schedule_status(schedule_id, status) {
        console.log(`Updating devices with schedule_id '${schedule_id}' to status ${status}`);
        try {
            const DataUpdate = {};
            DataUpdate.status = status;
            const updateResult = await this.scheduleDeviceRepository
                .createQueryBuilder()
                .update('sd_iot_schedule')
                .set(DataUpdate)
                .where('schedule_id=:schedule_id', { schedule_id: schedule_id })
                .execute();
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for schedule_id '${schedule_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with schedule_id '${schedule_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for schedule_id '${schedule_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for mqtt_id '${schedule_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async update_schedule_status_day(schedule_id, dto) {
        try {
            console.log(`Updating devices with schedule_id '${schedule_id}'`);
            console.log(`dto:`, dto);
            const DataUpdate = {};
            const days = [
                'event',
                'sunday',
                'monday',
                'tuesday',
                'wednesday',
                'thursday',
                'friday',
                'saturday',
                'status',
            ];
            for (const day of days) {
                if (dto[day] !== undefined && dto[day] !== '') {
                    DataUpdate[day] = dto[day];
                }
            }
            if (Object.keys(DataUpdate).length == 0) {
                this.logger.warn(`No valid fields to update for schedule_id '${schedule_id}'.`);
                throw new common_1.UnprocessableEntityException('No valid fields to update.');
            }
            const updateResult = await this.scheduleDeviceRepository
                .createQueryBuilder()
                .update('sd_iot_schedule')
                .set(DataUpdate)
                .where('schedule_id=:schedule_id', { schedule_id })
                .execute();
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for schedule_id '${schedule_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with schedule_id '${schedule_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for schedule_id '${schedule_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for schedule_id '${schedule_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async maxid_setting() {
        try {
            const RS = await this.SettingRepository.query('SELECT MAX(setting_id) AS setting_id FROM sd_iot_setting');
            console.log('get_maxId');
            console.info(RS);
            var setting_id = RS['0'].setting_id;
            console.log('maxId=');
            console.info(setting_id);
            var setting_ids = setting_id + 1;
            console.log('setting_ids=');
            console.info(setting_ids);
            return setting_ids;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async findAll(dto) {
        console.log(`setting_list_paginate dto=`);
        console.info(dto);
        try {
            var idx = dto.idx || '';
            var uid = dto.uid || '';
            var keyword = dto.keyword || '';
            var status = dto.status;
            var setting_id = dto.setting_id;
            var location_id = dto.location_id;
            var setting_type_id = dto.setting_type_id;
            var sn = dto.sn;
            var createddate = dto.createddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.SettingRepository.createQueryBuilder('s');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT s.setting_id)', 'cnt');
            }
            else {
                query.select([
                    's.setting_id AS setting_id',
                    's.location_id AS location_id',
                    's.setting_type_id AS setting_type_id',
                    's.setting_name AS setting_name',
                    's.sn AS sn',
                    's.createddate AS createddate',
                    's.updateddate AS updateddate',
                    's.status AS status',
                    'l.location_name AS location_name',
                    't.type_name AS type_name',
                ]);
            }
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= s.location_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = s.setting_type_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('s.setting_name like :setting_name', {
                    setting_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (setting_id) {
                query.andWhere('s.setting_id=:setting_id', { setting_id: setting_id });
            }
            if (location_id) {
                query.andWhere('s.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (status) {
                query.andWhere('l.status=:status', { status: status });
            }
            if (setting_type_id) {
                query.andWhere('s.setting_type_id=:setting_type_id', {
                    setting_type_id: setting_type_id,
                });
            }
            if (sn) {
                query.andWhere('s.sn=:sn', { sn: sn });
            }
            if (status) {
                query.andWhere('s.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`l.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`l.setting_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async findOne(setting_id) {
        try {
            const rs = await this.SettingRepository.findOne({
                where: {
                    setting_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create(dto) {
        const result = await this.SettingRepository.save(this.SettingRepository.create(dto));
        return result;
    }
    async update(id, dto) {
        let setting_id = dto.setting_id || id;
        const DataUpdate = {};
        const query = await this.SettingRepository.createQueryBuilder('s');
        query.select(['s.setting_id AS setting_id']);
        query.where('1=1');
        query.andWhere('s.setting_id=:setting_id', { setting_id: setting_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with setting_id ${setting_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found sd_iot_settingsetting_id ${setting_id}.`,
                message_th: `ไม่พบข้อมูล sd_iot_settingsetting_id ${setting_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.location_id) {
            DataUpdate.location_id = dto.location_id;
        }
        if (dto.setting_type_id) {
            DataUpdate.setting_type_id = dto.setting_type_id;
        }
        if (dto.setting_name) {
            DataUpdate.setting_name = dto.setting_name;
        }
        if (dto.sn) {
            DataUpdate.sn = dto.sn;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.SettingRepository.createQueryBuilder()
            .update('sd_iot_setting')
            .set(DataUpdate)
            .where('setting_id=:setting_id', { setting_id: setting_id })
            .execute();
        return 200;
    }
    async remove(setting_id) {
        try {
            this.logger.log(`Deleting sd_iot_setting with setting_id: ${setting_id}`);
            const constsetting = await this.get_setting(setting_id);
            if (!constsetting) {
                throw new common_1.NotFoundException(`sd_iot_setting with setting_id ${setting_id} not found`);
            }
            await this.SettingRepository.delete(setting_id);
        }
        catch (error) {
            this.logger.error(`Error while deleting sd_iot_setting = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async create_setting(dto) {
        const result = await this.SettingRepository.save(this.SettingRepository.create(dto));
        return result;
    }
    async delete_setting(setting_id) {
        if (!setting_id || isNaN(setting_id) || setting_id <= 0) {
            throw new common_1.UnprocessableEntityException('Invalid setting_id');
        }
        try {
            this.logger.log(`Deleting sd_iot_setting with setting_id: ${setting_id}`);
            const constsetting = await this.get_setting(setting_id);
            if (!constsetting) {
                throw new common_1.NotFoundException(`sd_iot_setting with setting_id ${setting_id} not found`);
            }
            await this.SettingRepository.delete(setting_id);
        }
        catch (error) {
            this.logger.error(`Error while deleting sd_iot_setting = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_setting(setting_id) {
        try {
            const rs = await this.SettingRepository.findOne({
                where: {
                    setting_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_setting_sn(sn) {
        try {
            const rs = await this.SettingRepository.findOne({
                where: {
                    sn,
                },
            });
            console.log('===get_setting_sn===');
            console.log('rs=>');
            console.info(rs);
            return rs;
        }
        catch (_a) {
            return null;
        }
    }
    async update_setting(dto) {
        let setting_id = dto.setting_id;
        const DataUpdate = {};
        const query = await this.SettingRepository.createQueryBuilder('s');
        query.select(['s.setting_id AS setting_id']);
        query.where('1=1');
        query.andWhere('s.setting_id=:setting_id', { setting_id: setting_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with setting_id ${setting_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found setting ${setting_id}.`,
                message_th: `ไม่พบข้อมูล setting ${setting_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.location_id) {
            DataUpdate.location_id = dto.location_id;
        }
        if (dto.setting_type_id) {
            DataUpdate.setting_type_id = dto.setting_type_id;
        }
        if (dto.setting_name) {
            DataUpdate.setting_name = dto.setting_name;
        }
        if (dto.sn) {
            DataUpdate.sn = dto.sn;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.SettingRepository.createQueryBuilder()
            .update('sd_iot_setting')
            .set(DataUpdate)
            .where('setting_id=:setting_id', { setting_id: setting_id })
            .execute();
        return 200;
    }
    async setting_all() {
        console.log(`setting_alldto=`);
        try {
            const query = await this.SettingRepository.createQueryBuilder('s');
            query.select(['s.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async setting_list_paginate(dto) {
        console.log(`setting_list_paginate dto=`);
        console.info(dto);
        try {
            var keyword = dto.keyword || '';
            var status = dto.status;
            var setting_id = dto.setting_id;
            var location_id = dto.location_id;
            var setting_type_id = dto.setting_type_id;
            var sn = dto.sn;
            var createddate = dto.createddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.SettingRepository.createQueryBuilder('s');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT s.setting_id)', 'cnt');
            }
            else {
                query.select([
                    's.setting_id AS setting_id',
                    's.location_id AS location_id',
                    's.setting_type_id AS setting_type_id',
                    's.setting_name AS setting_name',
                    's.sn AS sn',
                    's.createddate AS createddate',
                    's.updateddate AS updateddate',
                    's.status AS status',
                    'l.location_name AS location_name',
                    't.type_name AS type_name',
                ]);
            }
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= s.location_id');
            query.leftJoin('sd_iot_type', 't', 't.type_id = s.setting_type_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('s.setting_name like :setting_name', {
                    setting_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (setting_id) {
                query.andWhere('s.setting_id=:setting_id', { setting_id: setting_id });
            }
            if (location_id) {
                query.andWhere('s.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (status) {
                query.andWhere('l.status=:status', { status: status });
            }
            if (setting_type_id) {
                query.andWhere('s.setting_type_id=:setting_type_id', {
                    setting_type_id: setting_type_id,
                });
            }
            if (sn) {
                query.andWhere('s.sn=:sn', { sn: sn });
            }
            if (createddate) {
                query.andWhere('s.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (status) {
                query.andWhere('s.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`s.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`s.createddate`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Location() {
        try {
            const RS = await this.SettingRepository.query('SELECT MAX(location_id) AS location_id FROM sd_iot_location');
            console.log('location_id');
            console.info(RS);
            var location_id = RS['0'].location_id;
            console.log('maxlocation_id=');
            console.info(location_id);
            var location_ids = location_id + 1;
            console.log('maxlocation_id=');
            console.info(location_ids);
            return location_ids;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_location(dto) {
        const result = await this.LocationRepository.save(this.LocationRepository.create(dto));
        return result;
    }
    async delete_location(location_id) {
        try {
            this.logger.log(`Deleting sd_iot_location with location_id: ${location_id}`);
            const const_location = await this.get_location(location_id);
            if (!const_location) {
                throw new common_1.NotFoundException(`sd_iot_location with location_id ${location_id} not found`);
            }
            await this.LocationRepository.delete(location_id);
        }
        catch (error) {
            this.logger.error(`Error while deleting sd_iot_location = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_location(location_id) {
        try {
            const rs = await this.LocationRepository.findOne({
                where: {
                    location_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_location_ip(ipaddress) {
        try {
            const rs = await this.LocationRepository.findOne({
                where: {
                    ipaddress,
                },
            });
            console.log('===ipaddress===');
            console.log('rs=>');
            console.info(rs);
            return rs;
        }
        catch (_a) {
            return null;
        }
    }
    async update_location(dto) {
        let location_id = dto.location_id;
        const DataUpdate = {};
        const query = await this.LocationRepository.createQueryBuilder('l');
        query.select(['l.location_id AS location_id']);
        query.where('1=1');
        query.andWhere('l.location_id=:location_id', { location_id: location_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with location_id ${location_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found sd_iot_locationlocation_id ${location_id}.`,
                message_th: `ไม่พบข้อมูล sd_iot_locationlocation_id ${location_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.location_name) {
            DataUpdate.location_name = dto.location_name;
        }
        if (dto.ipaddress) {
            DataUpdate.ipaddress = dto.ipaddress;
        }
        if (dto.location_detail) {
            DataUpdate.location_detail = dto.location_detail;
        }
        if (dto.configdata) {
            DataUpdate.configdata = dto.configdata;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.LocationRepository.createQueryBuilder()
            .update('sd_iot_location')
            .set(DataUpdate)
            .where('location_id=:location_id', { location_id: location_id })
            .execute();
        return 200;
    }
    async location_all() {
        console.log(`location_all=`);
        try {
            const query = await this.LocationRepository.createQueryBuilder('l');
            query.select(['l.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async location_list_paginate(dto) {
        console.log(`location_list_paginate dto=`);
        console.info(dto);
        try {
            var location_id = dto.location_id;
            var ipaddress = dto.ipaddress;
            var location_detail = dto.location_detail;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.LocationRepository.createQueryBuilder('l');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT l.location_id)', 'cnt');
            }
            else {
                query.select([
                    'l.location_id AS location_id',
                    'l.location_name AS location_name',
                    'l.ipaddress AS ipaddress',
                    'l.configdata AS configdata',
                    'l.location_detail AS location_detail',
                    'l.createddate AS createddate',
                    'l.updateddate AS updateddate',
                    'l.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('l.location_name like :location_name', {
                    location_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (location_id) {
                query.andWhere('l.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (ipaddress) {
                query.andWhere('l.ipaddress=:ipaddress', { ipaddress: ipaddress });
            }
            if (createddate) {
                query.andWhere('l.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('l.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('l.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`l.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`l.location_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Type() {
        try {
            const RS = await this.TypeRepository.query('SELECT MAX(type_id) AS type_id FROM sd_iot_type');
            console.log('type_id');
            console.info(RS);
            var type_id = RS['0'].type_id;
            console.log('max_type_id=');
            console.info(type_id);
            var max_type_id = max_type_id + 1;
            console.log('max_type_id=');
            console.info(max_type_id);
            return max_type_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_type(dto) {
        const result = await this.TypeRepository.save(this.TypeRepository.create(dto));
        return result;
    }
    async delete_type(type_id) {
        try {
            this.logger.log(`Deleting sd_iot_type with type_id: ${type_id}`);
            const consttype = await this.get_type(type_id);
            if (!consttype) {
                throw new common_1.NotFoundException(`type_id with type_id ${type_id} not found`);
            }
            await this.TypeRepository.delete(type_id);
        }
        catch (error) {
            this.logger.error(`Error while deleting type_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_type(type_id) {
        try {
            const rs = await this.TypeRepository.findOne({
                where: {
                    type_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_type_name(type_name) {
        try {
            const rs = await this.TypeRepository.findOne({
                where: {
                    type_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_type(dto) {
        let type_id = dto.type_id;
        const DataUpdate = {};
        const query = await this.TypeRepository.createQueryBuilder('t');
        query.select(['t.type_id AS type_id']);
        query.where('1=1');
        query.andWhere('t.type_id=:type_id', { type_id: type_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with type_id ${type_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found type_idtype_id ${type_id}.`,
                message_th: `ไม่พบข้อมูล type_idtype_id ${type_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.type_name) {
            DataUpdate.type_name = dto.type_name;
        }
        if (dto.group_id) {
            DataUpdate.group_id = dto.group_id;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.TypeRepository.createQueryBuilder()
            .update('sd_iot_type')
            .set(DataUpdate)
            .where('type_id=:type_id', { type_id: type_id })
            .execute();
        return 200;
    }
    async type_all() {
        console.log(`=type_all=`);
        try {
            const query = await this.TypeRepository.createQueryBuilder('t');
            query.select(['t.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async type_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var type_id = dto.type_id;
            var group_id = dto.group_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.TypeRepository.createQueryBuilder('t');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT t.type_id )', 'cnt');
            }
            else {
                query.select([
                    't.type_id AS type_id',
                    't.group_id AS group_id',
                    't.type_name AS type_name',
                    't.createddate AS createddate',
                    't.updateddate AS updateddate',
                    't.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('t.type_name like :type_name', {
                    type_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (type_id) {
                query.andWhere('t.type_id=:type_id', { type_id: type_id });
            }
            if (group_id) {
                query.andWhere('t.group_id=:group_id', { group_id: group_id });
            }
            if (createddate) {
                query.andWhere('t.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('t.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('t.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`t.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`t.type_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async create_device_type(dto) {
        const result = await this.DeviceTypeRepository.save(this.DeviceTypeRepository.create(dto));
        return result;
    }
    async delete_device_type(type_id) {
        try {
            this.logger.log(`Deleting sd_iot_device_type with type_id: ${type_id}`);
            const constdevicetype = await this.get_device_type(type_id);
            if (!constdevicetype) {
                throw new common_1.NotFoundException(`type_id with type_id ${type_id} not found`);
            }
            await this.DeviceTypeRepository.delete(type_id);
        }
        catch (error) {
            this.logger.error(`Error while deleting type_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_device_type(type_id) {
        try {
            const rs = await this.DeviceTypeRepository.findOne({
                where: {
                    type_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_device_type_name(type_name) {
        try {
            const rs = await this.DeviceTypeRepository.findOne({
                where: {
                    type_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_device_type(dto) {
        let type_id = dto.type_id;
        const DataUpdate = {};
        const query = await this.DeviceTypeRepository.createQueryBuilder('dt');
        query.select(['dt.type_id AS type_id']);
        query.where('1=1');
        query.andWhere('dt.type_id=:type_id', { type_id: type_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with type_id ${type_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found type_idtype_id ${type_id}.`,
                message_th: `ไม่พบข้อมูล type_idtype_id ${type_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.type_name) {
            DataUpdate.type_name = dto.type_name;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.DeviceTypeRepository.createQueryBuilder()
            .update('sd_iot_device_type')
            .set(DataUpdate)
            .where('type_id=:type_id', { type_id: type_id })
            .execute();
        return 200;
    }
    async maxid_DeviceType() {
        try {
            const RS = await this.TypeRepository.query('SELECT MAX(type_id) AS type_id FROM sd_iot_device_type');
            console.log('type_id');
            console.info(RS);
            var type_id = RS['0'].type_id;
            console.log('max_type_id=');
            console.info(type_id);
            var max_type_id = max_type_id + 1;
            console.log('max_type_id=');
            console.info(max_type_id);
            return max_type_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async devicetype_all() {
        console.log(`=devicetype_all=`);
        try {
            const query = await this.DeviceTypeRepository.createQueryBuilder('dt');
            query.select(['dt.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async devicetype_all_oi() {
        console.log(`=devicetype_all=`);
        try {
            const query = await this.DeviceTypeRepository.createQueryBuilder('t');
            query.select(['t.*']);
            query.where('1=1');
            query.andWhere('t.type_id > 1 ');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async devicetype_list_paginate(dto) {
        console.log(`devicetype_list_paginate dto=`);
        console.info(dto);
        try {
            var type_id = dto.type_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.TypeRepository.createQueryBuilder('dt');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT t.type_id )', 'cnt');
            }
            else {
                query.select([
                    't.type_id AS type_id',
                    't.type_name AS type_name',
                    't.createddate AS createddate',
                    't.updateddate AS updateddate',
                    't.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('t.type_name like :type_name', {
                    type_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (type_id) {
                query.andWhere('t.type_id=:type_id', { type_id: type_id });
            }
            if (createddate) {
                query.andWhere('t.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('t.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('t.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`t.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`t.type_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Sensor() {
        try {
            const RS = await this.SensorRepository.query('SELECT MAX(sensor_id) AS sensor_id FROM sd_iot_sensor');
            console.log('sensor_id');
            console.info(RS);
            var sensor_id = RS['0'].sensor_id;
            console.log('max_sensor_id=');
            console.info(sensor_id);
            var max_sensor_id = max_sensor_id + 1;
            console.log('max_sensor_id=');
            console.info(max_sensor_id);
            return max_sensor_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_sensor(dto) {
        const result = await this.SensorRepository.save(this.SensorRepository.create(dto));
        return result;
    }
    async delete_sensor(sensor_id) {
        try {
            this.logger.log(`Deleting sensor with sensor_id: ${sensor_id}`);
            const constsensor = await this.get_sensor(sensor_id);
            if (!constsensor) {
                throw new common_1.NotFoundException(`sensor_id with sensor_id ${sensor_id} not found`);
            }
            await this.SensorRepository.delete(sensor_id);
        }
        catch (error) {
            this.logger.error(`Error while deleting sensor_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_sensor(sensor_id) {
        try {
            const rs = await this.SensorRepository.findOne({
                where: {
                    sensor_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_sensor_chk(sensor_name) {
        try {
            const rs = await this.SensorRepository.findOne({
                where: {
                    sensor_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_sensor(dto) {
        let sensor_id = dto.sensor_id;
        const DataUpdate = {};
        const query = await this.SensorRepository.createQueryBuilder('s');
        query.select(['s.sensor_id AS sensor_id']);
        query.where('1=1');
        query.andWhere('s.sensor_id=:sensor_id', { sensor_id: sensor_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with sensor_id ${sensor_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found sensor_idsensor_id ${sensor_id}.`,
                message_th: `ไม่พบข้อมูล sensor_idsensor_id ${sensor_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.setting_type_id) {
            DataUpdate.setting_type_id = dto.setting_type_id;
        }
        if (dto.sensor_name) {
            DataUpdate.sensor_name = dto.setting_type_id;
        }
        if (dto.sn) {
            DataUpdate.sn = dto.sn;
        }
        if (dto.max) {
            DataUpdate.max = dto.max;
        }
        if (dto.min) {
            DataUpdate.min = dto.min;
        }
        if (dto.hardware_id) {
            DataUpdate.hardware_id = dto.hardware_id;
        }
        if (dto.status_high) {
            DataUpdate.status_high = dto.status_high;
        }
        if (dto.status_warning) {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.status_alert) {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.model) {
            DataUpdate.model = dto.model;
        }
        if (dto.vendor) {
            DataUpdate.vendor = dto.vendor;
        }
        if (dto.comparevalue) {
            DataUpdate.comparevalue = dto.comparevalue;
        }
        if (dto.updateddate) {
            DataUpdate.updateddate = dto.updateddate;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        if (dto.unit) {
            DataUpdate.unit = dto.unit;
        }
        if (dto.mqtt_id) {
            DataUpdate.mqtt_id = dto.mqtt_id;
        }
        if (dto.action_id) {
            DataUpdate.action_id = dto.action_id;
        }
        if (dto.status_alert_id) {
            DataUpdate.status_alert_id = dto.status_alert_id;
        }
        if (dto.mqtt_data_value) {
            DataUpdate.mqtt_data_value = dto.mqtt_data_value;
        }
        if (dto.mqtt_data_control) {
            DataUpdate.mqtt_data_control = dto.mqtt_data_control;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.SensorRepository.createQueryBuilder()
            .update('sd_iot_sensor')
            .set(DataUpdate)
            .where('sensor_id=:sensor_id', { sensor_id: sensor_id })
            .execute();
        return 200;
    }
    async sensor_all() {
        console.log(`=sensor_all=`);
        try {
            const query = await this.SensorRepository.createQueryBuilder('s');
            query.select(['s.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async sensor_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var type_id = dto.type_id;
            var location_id = dto.location_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var sn = dto.sn;
            var max = dto.max;
            var min = dto.min;
            var hardware_id = dto.hardware_id;
            var status_high = dto.status_high;
            var status_warning = dto.status_warning;
            var status_alert = dto.status_alert;
            var model = dto.model;
            var vendor = dto.vendor;
            var comparevalue = dto.comparevalue;
            var mqtt_id = dto.mqtt_id;
            var oid = dto.oid;
            var action_id = dto.action_id;
            var mqtt_data_value = dto.mqtt_data_value;
            var mqtt_data_control = dto.mqtt_data_control;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.SensorRepository.createQueryBuilder('s');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT s.sensor_id)', 'cnt');
            }
            else {
                query.select([
                    's.sensor_id AS sensor_id',
                    's.setting_id AS setting_id',
                    's.setting_type_id AS setting_type_id',
                    's.sensor_name AS sensor_name',
                    's.sn AS sn',
                    's.max AS max',
                    's.min AS min',
                    's.hardware_id AS hardware_id',
                    's.status_high AS status_high',
                    's.status_warning AS status_warning',
                    's.status_alert AS status_alert',
                    's.model AS model',
                    's.vendor AS vendor',
                    's.comparevalue AS comparevalue',
                    's.createddate AS createddate',
                    's.updateddate AS updateddate',
                    's.status AS status',
                    's.unit AS unit',
                    's.mqtt_id AS mqtt_id',
                    's.oid AS oid',
                    's.action_id AS action_id',
                    's.status_alert_id AS status_alert_id',
                    's.mqtt_data_value AS mqtt_data_value',
                    's.mqtt_data_control AS mqtt_data_control',
                    't.type_name AS type_name',
                    'st.setting_name AS setting_name',
                    'l.location_name AS location_name',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= s.setting_id');
            query.leftJoin('sd_iot_type', 't', 't.type_id = s.setting_type_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= st.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('s.sensor_name like :sensor_name', {
                    sensor_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (type_id) {
                query.andWhere('s.type_id=:type_id', { type_id: type_id });
            }
            if (location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (sn) {
                query.andWhere('s.sn=:sn', { sn: sn });
            }
            if (max) {
                query.andWhere('s.max=:max', { max: max });
            }
            if (min) {
                query.andWhere('s.min=:min', { min: min });
            }
            if (hardware_id) {
                query.andWhere('s.hardware_id=:hardware_id', {
                    hardware_id: hardware_id,
                });
            }
            if (status_high) {
                query.andWhere('s.status_high=:status_high', {
                    status_high: status_high,
                });
            }
            if (status_warning) {
                query.andWhere('s.status_warning=:status_warning', {
                    status_warning: status_warning,
                });
            }
            if (status_alert) {
                query.andWhere('s.status_alert=:status_alert', {
                    status_alert: status_alert,
                });
            }
            if (model) {
                query.andWhere('s.model=:model', { model: model });
            }
            if (vendor) {
                query.andWhere('s.vendor=:vendor', { vendor: vendor });
            }
            if (comparevalue) {
                query.andWhere('s.comparevalue:comparevalue', {
                    comparevalue: comparevalue,
                });
            }
            if (mqtt_id) {
                query.andWhere('s.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (oid) {
                query.andWhere('s.oid=:oid', { oid: oid });
            }
            if (action_id) {
                query.andWhere('s.action_id=:action_id', { action_id: action_id });
            }
            if (mqtt_data_value) {
                query.andWhere('s.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: mqtt_data_value,
                });
            }
            if (mqtt_data_control) {
                query.andWhere('s.mqtt_data_control=::mqtt_data_control', {
                    mqtt_data_control: mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('s.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('s.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('s.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`s.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`s.sensor_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Group() {
        try {
            const RS = await this.GroupRepository.query('SELECT MAX(group_id) AS group_id FROM sd_iot_group');
            console.log('group_id');
            console.info(RS);
            var group_id = RS['0'].group_id;
            console.log('max_group_id=');
            console.info(group_id);
            var max_group_id = max_group_id + 1;
            console.log('max_group_id=');
            console.info(max_group_id);
            return max_group_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_group(dto) {
        const result = await this.GroupRepository.save(this.GroupRepository.create(dto));
        return result;
    }
    async delete_group(group_id) {
        try {
            this.logger.log(`Deleting group with group_id: ${group_id}`);
            const constGroup = await this.get_group(group_id);
            if (!constGroup) {
                throw new common_1.NotFoundException(`group_id with group_id ${group_id} not found`);
            }
            await this.GroupRepository.delete(group_id);
        }
        catch (error) {
            this.logger.error(`Error while deleting group_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_group(group_id) {
        try {
            const rs = await this.GroupRepository.findOne({
                where: {
                    group_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_group(group_name) {
        try {
            const rs = await this.GroupRepository.findOne({
                where: {
                    group_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_group(dto) {
        let group_id = dto.group_id;
        const DataUpdate = {};
        const query = await this.GroupRepository.createQueryBuilder('g');
        query.select(['g.group_id AS group_id']);
        query.where('1=1');
        query.andWhere('g.group_id=:group_id', { group_id: group_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with group_id ${group_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found group_idgroup_id ${group_id}.`,
                message_th: `ไม่พบข้อมูล group_idgroup_id ${group_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.group_id) {
            DataUpdate.group_id = dto.group_id;
        }
        if (dto.group_name) {
            DataUpdate.group_name = dto.group_name;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.GroupRepository.createQueryBuilder()
            .update('sd_iot_group')
            .set(DataUpdate)
            .where('group_id=:group_id', { group_id: group_id })
            .execute();
        return 200;
    }
    async group_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.GroupRepository.createQueryBuilder('g');
            query.select(['g.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async group_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var group_id = dto.group_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.GroupRepository.createQueryBuilder('g');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT g.group_id)', 'cnt');
            }
            else {
                query.select([
                    'g.group_id AS group_id',
                    'g.group_name AS group_name',
                    'g.createddate AS createddate',
                    'g.updateddate AS updateddate',
                    'g.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('g.group_name like :group_name', {
                    group_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (group_id) {
                query.andWhere('g.group_id=:group_id', { group_id: group_id });
            }
            if (createddate) {
                query.andWhere('g.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('g.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('g.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`g.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`g.group_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Mqtt() {
        try {
            const RS = await this.GroupRepository.query('SELECT MAX(mqtt_id) AS mqtt_id FROM sd_iot_mqtt');
            console.log('mqtt_id');
            console.info(RS);
            var mqtt_id = RS['0'].mqtt_id;
            console.log('max_mqtt_id=');
            console.info(mqtt_id);
            var max_mqtt_id = max_mqtt_id + 1;
            console.log('max_mqtt_id=');
            console.info(max_mqtt_id);
            return max_mqtt_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async _create_mqtt(dto) {
        console.log('create_mqtt=>');
        console.info(dto);
        if ('mqtt_id' in dto) {
            delete dto.mqtt_id;
        }
        const result = await this.MqttRepository.save(this.MqttRepository.create(dto));
        return result;
    }
    async create_mqtt(dto) {
        try {
            console.log('-----create_mqtt dto----');
            console.info(dto);
            if (dto.mqtt_id) {
                const existsById = await this.MqttRepository.findOne({
                    where: { mqtt_id: dto.mqtt_id },
                });
                if (existsById) {
                    throw new common_1.ConflictException(`mqtt with mqtt_id ${dto.mqtt_id} already exists`);
                }
            }
            if (dto.bucket) {
                const existsByBucket = await this.MqttRepository.findOne({
                    where: { bucket: dto.bucket },
                });
                if (existsByBucket) {
                    throw new common_1.ConflictException(`mqtt with bucket ${dto.bucket} already exists`);
                }
            }
            if (dto.mqtt_name) {
                const existsByName = await this.MqttRepository.findOne({
                    where: { mqtt_name: dto.mqtt_name },
                });
                if (existsByName) {
                    throw new common_1.ConflictException(`mqtt with name ${dto.mqtt_name} already exists`);
                }
            }
            const DataDtos = {
                mqtt_type_id: dto.mqtt_type_id,
                sort: dto.sort_last,
                mqtt_name: dto.mqtt_name,
                host: dto.host,
                port: dto.port,
                username: dto.username,
                password: dto.password,
                secret: dto.secret,
                expire_in: dto.expire_in,
                token_value: dto.token_value,
                org: dto.org,
                bucket: dto.bucket,
                envavorment: dto.envavorment,
                status: dto.status,
                location_id: dto.location_id,
                createddate: dto.createddate,
                latitude: dto.latitude,
                longitude: dto.longitude,
            };
            const entity = this.MqttRepository.create(DataDtos);
            if (dto.mqtt_id) {
                entity.mqtt_id = dto.mqtt_id;
            }
            const result = await this.MqttRepository.save(entity);
            return result;
        }
        catch (err) {
            console.log('dto=>');
            console.info(dto);
            console.log('err=>');
            console.info(err);
            if (err instanceof common_1.ConflictException) {
                throw err;
            }
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                    errorCode: err.code || 'UNKNOWN_ERROR',
                },
                message: 'Cannot process the request',
            });
        }
    }
    async delete_mqtt(mqtt_id) {
        try {
            this.logger.log(`Deleting mqtt with mqtt_id: ${mqtt_id}`);
            const constmqtt = await this.get_mqtt(mqtt_id);
            if (!constmqtt) {
                throw new common_1.NotFoundException(`mqtt_id with mqtt_id ${mqtt_id} not found`);
            }
            const updateResult = await this.MqttRepository.update({ mqtt_id: mqtt_id }, { status: 0 });
        }
        catch (error) {
            this.logger.error(`Error while deleting mqtt_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_mqtt(mqtt_id) {
        try {
            const rs = await this.MqttRepository.findOne({
                where: {
                    mqtt_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_maxId_mqtt() {
        try {
            const RS = await this.MqttRepository.query('SELECT MAX(mqtt_id) AS mqtt_id FROM sd_iot_mqtt');
            console.log('get_maxId_mqttRS=');
            console.info(RS);
            var maxId = RS['0'].mqtt_id;
            console.log('maxId=');
            console.info(maxId);
            var mqtt_ids = maxId + 1;
            console.log('mqtt_ids=');
            console.info(mqtt_ids);
            return mqtt_ids;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_mqtt(mqtt_name) {
        try {
            console.log('mqtt_name=>');
            console.info(mqtt_name);
            const rs = await this.MqttRepository.findOne({
                where: {
                    mqtt_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_mqtt_status_2(mqtt_id, status) {
        try {
            var rs = this.MqttRepository.update({ mqtt_id: mqtt_id }, { status });
            console.log('update_mqtt_status rs=>');
            console.info(rs);
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_mqtt_status(mqtt_id, status) {
        console.log(`Updating devices with bucket '${mqtt_id}' to status ${status}`);
        try {
            const updateResult = await this.MqttRepository.update({ mqtt_id: mqtt_id }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for mqtt_id '${mqtt_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${mqtt_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for mqtt_id '${mqtt_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for mqtt_id '${mqtt_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async update_mqtt(dto) {
        var mqtt_id = dto.mqtt_id;
        var status = dto.status;
        const DataUpdate = {};
        const query = await this.MqttRepository.createQueryBuilder('mq');
        query.select(['mq.mqtt_id AS mqtt_id']);
        query.where('1=1');
        query.andWhere('mq.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        console.log('dto=>');
        console.info(dto);
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with mqtt_id ${mqtt_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found mqtt_idmqtt_id ${mqtt_id}.`,
                message_th: `ไม่พบข้อมูล mqtt_idmqtt_id ${mqtt_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.mqtt_type_id) {
            DataUpdate.mqtt_type_id = dto.mqtt_type_id;
        }
        if (dto.location_id) {
            DataUpdate.location_id = dto.location_id;
        }
        if (dto.mqtt_name) {
            DataUpdate.mqtt_name = dto.mqtt_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.username) {
            DataUpdate.username = dto.username;
        }
        if (dto.password) {
            DataUpdate.password = dto.password;
        }
        if (dto.secret) {
            DataUpdate.secret = dto.secret;
        }
        if (dto.expire_in) {
            DataUpdate.expire_in = dto.expire_in;
        }
        if (dto.token_value) {
            DataUpdate.token_value = dto.token_value;
        }
        if (dto.org) {
            DataUpdate.org = dto.org;
        }
        if (dto.bucket) {
            DataUpdate.bucket = dto.bucket;
        }
        if (dto.envavorment) {
            DataUpdate.envavorment = dto.envavorment;
        }
        if (status) {
            DataUpdate.status = status;
        }
        if (dto.latitude) {
            DataUpdate.latitude = dto.latitude;
        }
        if (dto.longitude) {
            DataUpdate.longitude = dto.longitude;
        }
        if (dto.mqtt_main_id) {
            DataUpdate.mqtt_main_id = dto.mqtt_main_id;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate=>');
        console.info(DataUpdate);
        console.log('mqtt_id=>' + mqtt_id);
        var updateResult = await this.MqttRepository.createQueryBuilder()
            .update('sd_iot_mqtt')
            .set(DataUpdate)
            .where('mqtt_id=:mqtt_id', { mqtt_id: mqtt_id })
            .execute();
        if (updateResult.affected == 0) {
            throw new common_1.NotFoundException(`Data with mqtt_id ${mqtt_id} not found.`);
        }
        return 200;
    }
    async mqtt_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.MqttRepository.createQueryBuilder('mq');
            query.select(['mq.*']);
            query.orderBy('mq.sort', 'ASC');
            query.addOrderBy(`mq.mqtt_id`, 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async mqtt_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var mqtt_id = dto.mqtt_id;
            var idhost = dto.idhost;
            var mqtt_type_id = dto.mqtt_type_id;
            var location_id = dto.location_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.MqttRepository.createQueryBuilder('mq');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT mq.mqtt_id)', 'cnt');
            }
            else {
                query.select([
                    'mq.mqtt_id AS mqtt_id',
                    'l.location_id AS location_id',
                    'h.idhost AS idhost',
                    'mq.sort AS sort',
                    'mq.mqtt_type_id AS mqtt_type_id',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.host AS host',
                    'mq.port AS port',
                    'mq.username AS username',
                    'mq.password AS password',
                    'mq.secret AS secret',
                    'mq.expire_in AS expire_in',
                    'mq.token_value AS token_value',
                    'mq.org AS org',
                    'mq.bucket AS bucket',
                    'mq.envavorment AS envavorment',
                    'mq.updateddate AS updateddate',
                    'mq.status AS status',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.ipaddress AS ipaddress',
                    'l.location_detail AS location_detail',
                    'h.*',
                ]);
            }
            query.leftJoin('sd_iot_type', 't', 't.type_id = mq.mqtt_type_id');
            query.leftJoin('sd_iot_host', 'h', 'mq.mqtt_main_id = h.idhost');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('mq.mqtt_name like :mqtt_name', {
                    mqtt_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (mqtt_id) {
                query.andWhere('mq.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.idhost) {
                query.andWhere('mq.mqtt_main_id=:mqtt_main_id', {
                    mqtt_main_id: dto.idhost,
                });
            }
            if (location_id) {
                query.andWhere('mq.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (mqtt_type_id) {
                query.andWhere('mq.mqtt_type_id=:mqtt_type_id', {
                    mqtt_type_id: mqtt_type_id,
                });
            }
            if (createddate) {
                query.andWhere('mq.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (dto.secret) {
                query.andWhere('mq.secret=:secret', { secret: dto.secret });
            }
            if (dto.expire_in) {
                query.andWhere('mq.expire_in=:expire_in', { expire_in: dto.expire_in });
            }
            if (dto.token_value) {
                query.andWhere('mq.token_value=:token_value', {
                    token_value: dto.token_value,
                });
            }
            if (dto.org) {
                query.andWhere('mq.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('mq.bucket=:bucket', { bucket: dto.bucket });
            }
            if (dto.envavorment) {
                query.andWhere('mq.envavorment=:envavorment', {
                    envavorment: dto.envavorment,
                });
            }
            if (updateddate) {
                query.andWhere('mq.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('mq.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`mq.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy(`mq.mqtt_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async mqtt_filter(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var mqtt_id = dto.mqtt_id;
            var mqtt_type_id = dto.mqtt_type_id;
            var location_id = dto.location_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var query = await this.MqttRepository.createQueryBuilder('mq');
            query.select([
                'mq.mqtt_id AS mqtt_id',
                'l.location_id AS location_id',
                'mq.sort AS sort',
                'mq.mqtt_type_id AS mqtt_type_id',
                'mq.mqtt_name AS mqtt_name',
                'mq.host AS host',
                'mq.port AS port',
                'mq.username AS username',
                'mq.password AS password',
                'mq.secret AS secret',
                'mq.expire_in AS expire_in',
                'mq.token_value AS token_value',
                'mq.org AS org',
                'mq.bucket AS bucket',
                'mq.envavorment AS envavorment',
                'mq.updateddate AS updateddate',
                'mq.status AS status',
                'mq.latitude AS latitude',
                'mq.longitude AS longitude',
                'mq.mqtt_main_id AS mqtt_main_id',
                't.type_name AS type_name',
                'l.location_name AS location_name',
                'l.ipaddress AS ipaddress',
                'l.location_detail AS location_detail',
            ]);
            query.leftJoin('sd_iot_type', 't', 't.type_id = mq.mqtt_type_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            const statusValue = status !== undefined ? parseInt(status) : 1;
            query.andWhere('mq.status = :statusValue', { statusValue });
            if (keyword) {
                query.andWhere('mq.mqtt_name like :mqtt_name', {
                    mqtt_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (mqtt_id) {
                query.andWhere('mq.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (location_id) {
                query.andWhere('mq.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (mqtt_type_id) {
                query.andWhere('mq.mqtt_type_id=:mqtt_type_id', {
                    mqtt_type_id: mqtt_type_id,
                });
            }
            if (createddate) {
                query.andWhere('mq.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (dto.secret) {
                query.andWhere('mq.secret=:secret', { secret: dto.secret });
            }
            if (dto.expire_in) {
                query.andWhere('mq.expire_in=:expire_in', { expire_in: dto.expire_in });
            }
            if (dto.token_value) {
                query.andWhere('mq.token_value=:token_value', {
                    token_value: dto.token_value,
                });
            }
            if (dto.org) {
                query.andWhere('mq.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('mq.bucket=:bucket', { bucket: dto.bucket });
            }
            if (dto.envavorment) {
                query.andWhere('mq.envavorment=:envavorment', {
                    envavorment: dto.envavorment,
                });
            }
            if (updateddate) {
                query.andWhere('mq.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy('mq.sort', 'ASC');
            query.addOrderBy(`mq.mqtt_id`, 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async mqtt_list_paginate_active(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var mqtt_id = dto.mqtt_id;
            var mqtt_type_id = dto.mqtt_type_id;
            var location_id = dto.location_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.MqttRepository.createQueryBuilder('mq');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT mq.mqtt_id)', 'cnt');
            }
            else {
                query.select([
                    'mq.mqtt_id AS mqtt_id',
                    'mq.mqtt_type_id AS mqtt_type_id',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.host AS host',
                    'mq.port AS port',
                    'mq.username AS username',
                    'mq.password AS password',
                    'mq.secret AS secret',
                    'mq.expire_in AS expire_in',
                    'mq.token_value AS token_value',
                    'mq.org AS org',
                    'mq.bucket AS bucket',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'mq.envavorment AS envavorment',
                    'mq.updateddate AS updateddate',
                    'mq.status AS status',
                    't.type_name AS type_name',
                ]);
            }
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = mq.mqtt_type_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('mq.mqtt_name like :mqtt_name', {
                    mqtt_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (mqtt_id) {
                query.andWhere('mq.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (location_id) {
                query.andWhere('mq.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (mqtt_type_id) {
                query.andWhere('mq.mqtt_type_id=:mqtt_type_id', {
                    mqtt_type_id: mqtt_type_id,
                });
            }
            if (createddate) {
                query.andWhere('mq.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (dto.secret) {
                query.andWhere('mq.secret=:secret', { secret: dto.secret });
            }
            if (dto.expire_in) {
                query.andWhere('mq.expire_in=:expire_in', { expire_in: dto.expire_in });
            }
            if (dto.token_value) {
                query.andWhere('mq.token_value=:token_value', {
                    token_value: dto.token_value,
                });
            }
            if (dto.org) {
                query.andWhere('mq.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('mq.bucket=:bucket', { bucket: dto.bucket });
            }
            if (dto.envavorment) {
                query.andWhere('mq.envavorment=:envavorment', {
                    envavorment: dto.envavorment,
                });
            }
            if (updateddate) {
                query.andWhere('mq.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('mq.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`mq.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`mq.mqtt_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async update_mqttt_sort(dto) {
        var mqtt_id = dto.mqtt_id;
        var sort = dto.sort;
        const DataUpdate = {};
        const query = await this.MqttRepository.createQueryBuilder('mq');
        query.select(['mq.mqtt_id AS mqtt_id']);
        query.where('1=1');
        query.andWhere('mq.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        console.log('dto=>');
        console.info(dto);
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with mqtt_id ${mqtt_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found mqtt_idmqtt_id ${mqtt_id}.`,
                message_th: `ไม่พบข้อมูล mqtt_idmqtt_id ${mqtt_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        DataUpdate.sort = sort;
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate=>');
        console.info(DataUpdate);
        console.log('mqtt_id=>' + mqtt_id);
        var updateResult = await this.MqttRepository.createQueryBuilder()
            .update('sd_iot_mqtt')
            .set(DataUpdate)
            .where('mqtt_id=:mqtt_id', { mqtt_id: mqtt_id })
            .execute();
        if (updateResult.affected == 0) {
            throw new common_1.NotFoundException(`Data with mqtt_id ${mqtt_id} not found.`);
        }
        return 200;
    }
    async mqtt_last_sort() {
        try {
            const query = await this.MqttRepository.createQueryBuilder('mqtt');
            query.select(['mqtt.sort AS sort']);
            query.where('1=1');
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy(`mqtt.sort`, 'DESC');
            var data = await query.getRawMany();
            console.log(`data=>`);
            console.info(data);
            var sort = data['0'].sort;
            console.log(`sort=>` + sort);
            return sort;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Api() {
        try {
            const RS = await this.ApiRepository.query('SELECT MAX(api_id) AS api_id FROM sd_iot_api');
            console.log('api_id');
            console.info(RS);
            var api_id = RS['0'].api_id;
            console.log('max_api_id=');
            console.info(api_id);
            var max_api_id = max_api_id + 1;
            console.log('max_api_id=');
            console.info(max_api_id);
            return max_api_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_api(dto) {
        console.log('create_api=>');
        console.info(dto);
        const result = await this.ApiRepository.save(this.ApiRepository.create(dto));
        return result;
    }
    async delete_api(api_id) {
        try {
            this.logger.log(`Deleting mqtt with api_id: ${api_id}`);
            const constmqtt = await this.get_api(api_id);
            if (!constmqtt) {
                throw new common_1.NotFoundException(`api_id with api_id ${api_id} not found`);
            }
            await this.ApiRepository.delete(api_id);
        }
        catch (error) {
            this.logger.error(`Error while deleting api_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_api(api_id) {
        try {
            const rs = await this.ApiRepository.findOne({
                where: {
                    api_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_api(api_name) {
        try {
            console.log('api_name=>');
            console.info(api_name);
            const rs = await this.ApiRepository.findOne({
                where: {
                    api_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_api(dto) {
        let api_id = dto.api_id;
        const DataUpdate = {};
        const query = await this.ApiRepository.createQueryBuilder('api');
        query.select(['api.api_id AS api_id']);
        query.where('1=1');
        query.andWhere('api.api_id=:api_id', { api_id: api_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with api_id ${api_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found api_idapi_id ${api_id}.`,
                message_th: `ไม่พบข้อมูล api_idapi_id ${api_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.api_name) {
            DataUpdate.api_name = dto.api_name;
        }
        if (dto.mqtt_name) {
            DataUpdate.mqtt_name = dto.mqtt_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.token_value) {
            DataUpdate.token_value = dto.token_value;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.ApiRepository.createQueryBuilder()
            .update('sd_iot_api')
            .set(DataUpdate)
            .where('api_id=:api_id', { api_id: api_id })
            .execute();
        return 200;
    }
    async api_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.ApiRepository.createQueryBuilder('api');
            query.select(['api.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async api_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var api_id = dto.api_id;
            var api_name = dto.api_name;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.ApiRepository.createQueryBuilder('api');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT api.api_id)', 'cnt');
            }
            else {
                query.select([
                    'api.api_id AS api_id',
                    'api.api_name AS api_name',
                    'api.host AS host',
                    'api.port AS port',
                    'api.token_value AS token_value',
                    'api.password AS password',
                    'api.updateddate AS updateddate',
                    'api.status AS status',
                    't.type_name AS type_name',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('api.api_name like :api_name', {
                    api_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (api_id) {
                query.andWhere('api.api_id=:api_id', { api_id: api_id });
            }
            if (createddate) {
                query.andWhere('api.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('api.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('api.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`api.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`api.api_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Device() {
        try {
            const RS = await this.DeviceRepository.query('SELECT MAX(device_id) AS device_id FROM sd_iot_device');
            console.log('device_id');
            console.info(RS);
            var device_id = RS['0'].device_id;
            console.log('max_device_id=');
            console.info(device_id);
            var max_device_id = max_device_id + 1;
            console.log('max_device_id=');
            console.info(max_device_id);
            return max_device_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_device_do(dto) {
        var _a, _b;
        try {
            if (dto.sn) {
                const existsBysn = await this.DeviceRepository.findOne({
                    where: { sn: dto.sn },
                });
                if (existsBysn)
                    throw new common_1.ConflictException(`mqtt with name ${dto.mqtt_name} already exists`);
            }
            const result = await this.DeviceRepository.save(this.DeviceRepository.create(dto));
            return result;
        }
        catch (err) {
            console.log('dto=>');
            console.info(dto);
            console.info(err);
            if ((err instanceof typeorm_2.QueryFailedError &&
                ((_a = err.driverError) === null || _a === void 0 ? void 0 : _a.code) === '23505') ||
                err.constraint === 'PK_841e36ab4b8edbaa5363d65f18d') {
                const constraint = (_b = err.driverError) === null || _b === void 0 ? void 0 : _b.constraint;
                throw new common_1.ConflictException(`create_device Primary Key sn ${dto.sn}  already exists, please use unique value. code ${err.driverError.code}` +
                    (constraint ? ` (${constraint})` : ''));
            }
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                statusCode: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { errorMessage: err.message },
                message: { errorMessage: err.message },
            });
        }
    }
    async create_device(dto) {
        var _a, _b, _c, _d;
        try {
            const requiredFields = ['sn', 'org', 'bucket'];
            for (const field of requiredFields) {
                if (!dto[field]) {
                    throw new common_1.BadRequestException(`Field ${field} is required`);
                }
            }
            if (dto.sn) {
                const existing = await this.DeviceRepository.findOne({
                    where: { sn: dto.sn },
                });
                if (existing) {
                    throw new common_1.ConflictException(`Device with SN ${dto.sn} already exists`);
                }
            }
            const { device_id } = dto, deviceData = __rest(dto, ["device_id"]);
            const deviceToCreate = Object.assign(Object.assign({}, deviceData), { work_status: (_a = dto.work_status) !== null && _a !== void 0 ? _a : 1, time_life: (_b = dto.time_life) !== null && _b !== void 0 ? _b : 1, mqtt_control_on: (_c = dto.mqtt_control_on) !== null && _c !== void 0 ? _c : '1', mqtt_control_off: (_d = dto.mqtt_control_off) !== null && _d !== void 0 ? _d : '0' });
            const result = await this.DeviceRepository.save(this.DeviceRepository.create(deviceToCreate));
            return result;
        }
        catch (err) {
            console.error('Create device error:', err);
            if (err.code === '23505' || err instanceof common_1.ConflictException) {
                if (err.message.includes('sn')) {
                    throw new common_1.ConflictException(`Device with SN ${dto.sn} already exists`);
                }
                throw new common_1.ConflictException(`Duplicate device data: ${err.message}`);
            }
            if (err.code === '23502') {
                throw new common_1.UnprocessableEntityException(`Required field is missing: ${err.message}`);
            }
            if (err instanceof common_1.BadRequestException ||
                err instanceof common_1.ConflictException ||
                err instanceof common_1.UnprocessableEntityException) {
                throw err;
            }
            throw new common_1.UnprocessableEntityException(`Failed to create device: ${err.message}`);
        }
    }
    async __create_device(dto) {
        try {
            return await this.DeviceRepository.manager.transaction(async (transactionalEntityManager) => {
                if (dto.sn) {
                    const existingDevice = await transactionalEntityManager.findOne(device_entity_1.Device, {
                        where: { sn: dto.sn },
                    });
                    if (existingDevice) {
                        throw new common_1.ConflictException(`Device with SN ${dto.sn} already exists`);
                    }
                }
                const newDevice = transactionalEntityManager.create(device_entity_1.Device, Object.assign(Object.assign({}, dto), { work_status: dto.work_status || 1, time_life: dto.time_life || 1, mqtt_control_on: dto.mqtt_control_on || '1', mqtt_control_off: dto.mqtt_control_off || '0' }));
                const result = await transactionalEntityManager.save(device_entity_1.Device, newDevice);
                return result;
            });
        }
        catch (err) {
            console.error('Error in create_device:', {
                dto,
                error: err.message,
                code: err.code,
            });
            if (err instanceof common_1.ConflictException) {
                throw err;
            }
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                    errorCode: err.code,
                },
                message: 'Failed to create device',
            });
        }
    }
    async delete_device(device_id) {
        try {
            this.logger.log(`Deleting mqtt with device_id: ${device_id}`);
            const constmqtt = await this.get_device(device_id);
            if (!constmqtt) {
                throw new common_1.NotFoundException(`device_id with device_id ${device_id} not found`);
            }
            const updateResult = await this.DeviceRepository.update({ device_id: device_id }, { status: 0 });
        }
        catch (error) {
            this.logger.error(`Error while deleting device_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_device(device_id) {
        try {
            const rs = await this.DeviceRepository.findOne({
                where: {
                    device_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_device(device_name) {
        try {
            console.log('device_name=>');
            console.info(device_name);
            const rs = await this.DeviceRepository.findOne({
                where: {
                    device_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_sn(sn) {
        try {
            console.log('sn=>');
            console.info(sn);
            const rs = await this.DeviceRepository.findOne({
                where: {
                    sn,
                },
            });
            return rs;
        }
        catch (err) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                statusCode: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { errorMessage: err.message },
                message: { errorMessage: err.message },
            });
        }
    }
    async update_device(dto) {
        let device_id = dto.device_id;
        const DataUpdate = {};
        const query = await this.DeviceRepository.createQueryBuilder('d');
        query.select(['d.device_id AS device_id']);
        query.where('1=1');
        query.andWhere('d.device_id=:device_id', { device_id: device_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with device_id ${device_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found device_iddevice_id ${device_id}.`,
                message_th: `ไม่พบข้อมูล device_iddevice_id ${device_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.setting_id) {
            DataUpdate.setting_id = dto.setting_id;
        }
        if (dto.type_id) {
            DataUpdate.type_id = dto.type_id;
        }
        if (dto.location_id) {
            DataUpdate.location_id = dto.location_id;
        }
        if (dto.device_name) {
            DataUpdate.device_name = dto.device_name;
        }
        if (dto.sn) {
            DataUpdate.sn = dto.sn;
        }
        if (dto.max) {
            DataUpdate.max = dto.max;
        }
        if (dto.min) {
            DataUpdate.min = dto.min;
        }
        if (dto.hardware_id) {
            DataUpdate.hardware_id = dto.hardware_id;
        }
        if (dto.status_warning) {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.recovery_warning) {
            DataUpdate.recovery_warning = dto.recovery_warning;
        }
        if (dto.status_alert) {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.recovery_alert) {
            DataUpdate.recovery_alert = dto.recovery_alert;
        }
        if (dto.time_life) {
            DataUpdate.time_life = dto.time_life;
        }
        if (dto.period) {
            DataUpdate.period = dto.period;
        }
        if (dto.model) {
            DataUpdate.model = dto.model;
        }
        if (dto.vendor) {
            DataUpdate.vendor = dto.vendor;
        }
        if (dto.comparevalue) {
            DataUpdate.comparevalue = dto.comparevalue;
        }
        if (dto.updateddate) {
            DataUpdate.updateddate = dto.updateddate;
        }
        if (dto.unit) {
            DataUpdate.unit = dto.unit;
        }
        if (dto.mqtt_id) {
            DataUpdate.mqtt_id = dto.mqtt_id;
        }
        if (dto.action_id) {
            DataUpdate.action_id = dto.action_id;
        }
        if (dto.status_alert_id) {
            DataUpdate.status_alert_id = dto.status_alert_id;
        }
        if (dto.oid) {
            DataUpdate.oid = dto.oid;
        }
        if (dto.mqtt_data_value) {
            DataUpdate.mqtt_data_value = dto.mqtt_data_value;
        }
        if (dto.mqtt_data_control) {
            DataUpdate.mqtt_data_control = dto.mqtt_data_control;
        }
        if (dto.measurement) {
            DataUpdate.measurement = dto.measurement;
        }
        if (dto.mqtt_control_on) {
            DataUpdate.mqtt_control_on = dto.mqtt_control_on;
        }
        if (dto.mqtt_control_off) {
            DataUpdate.mqtt_control_off = dto.mqtt_control_off;
        }
        if (dto.org) {
            DataUpdate.org = dto.org;
        }
        if (dto.bucket) {
            DataUpdate.bucket = dto.bucket;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        if (dto.mqtt_device_name) {
            DataUpdate.mqtt_device_name = dto.mqtt_device_name;
        }
        if (dto.mqtt_status_over_name) {
            DataUpdate.mqtt_status_over_name = dto.mqtt_status_over_name;
        }
        if (dto.mqtt_status_data_name) {
            DataUpdate.mqtt_status_data_name = dto.mqtt_status_data_name;
        }
        if (dto.mqtt_act_relay_name) {
            DataUpdate.mqtt_act_relay_name = dto.mqtt_act_relay_name;
        }
        if (dto.mqtt_control_relay_name) {
            DataUpdate.mqtt_control_relay_name = dto.mqtt_control_relay_name;
        }
        if (dto.layout) {
            DataUpdate.layout = dto.layout;
        }
        if (dto.alert_set) {
            DataUpdate.alert_set = dto.alert_set;
        }
        if (dto.icon_normal) {
            DataUpdate.icon_normal = dto.icon_normal;
        }
        if (dto.icon_warning) {
            DataUpdate.icon_warning = dto.icon_warning;
        }
        if (dto.icon_alert) {
            DataUpdate.icon_alert = dto.icon_alert;
        }
        if (dto.icon) {
            DataUpdate.icon = dto.icon;
        }
        if (dto.color_normal) {
            DataUpdate.color_normal = dto.color_normal;
        }
        if (dto.color_warning) {
            DataUpdate.color_warning = dto.color_warning;
        }
        if (dto.color_alert) {
            DataUpdate.color_alert = dto.color_alert;
        }
        if (dto.code) {
            DataUpdate.code = dto.code;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.DeviceRepository.createQueryBuilder()
            .update('sd_iot_device')
            .set(DataUpdate)
            .where('device_id=:device_id', { device_id: device_id })
            .execute();
        return 200;
    }
    async update_device_mqtt_status_2(bucket, status) {
        console.log('bucket =>', bucket);
        console.log('status =>', status);
        try {
            var rs = this.DeviceRepository.update({ bucket: bucket }, { status });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_device_mqtt_status(bucket, status) {
        console.log(`Updating devices with bucket '${bucket}' to status ${status}`);
        try {
            const updateResult = await this.DeviceRepository.update({ bucket: bucket }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for bucket '${bucket}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${bucket}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for bucket '${bucket}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for bucket '${bucket}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async update_device_mqtt_status_device_id(device_id, status) {
        console.log(`Updating devices with device_id '${device_id}' to status ${status}`);
        try {
            const updateResult = await this.DeviceRepository.update({ device_id: device_id }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for device_id '${device_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with device_id '${device_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for device_id '${device_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for device_id '${device_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async update_device_status_mqtt_bucket(dto) {
        let bucket = dto.bucket;
        const DataUpdate = {};
        const query = await this.DeviceRepository.createQueryBuilder('d');
        query.select(['d.device_id AS device_id']);
        query.where('1=1');
        query.andWhere('d.bucket=:bucket', { bucket: bucket });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with device_id ${bucket} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found device_iddevice_id ${bucket}.`,
                message_th: `ไม่พบข้อมูล device_iddevice_id ${bucket}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        var status = dto.status;
        if (status != '') {
            DataUpdate.status = status;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.DeviceRepository.createQueryBuilder()
            .update('sd_iot_device')
            .set(DataUpdate)
            .where('bucket=:bucket', { bucket: bucket })
            .execute();
        return 200;
    }
    async device_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.DeviceRepository.createQueryBuilder('device');
            query.select(['d.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async deviceeditget(device_id) {
        console.log(`=device_id=` + device_id);
        try {
            const rs = await this.DeviceRepository.findOne({
                where: {
                    device_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async devicedetail(dto) {
        console.log(` device_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var status = dto.status || '';
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.sn AS sn',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS time_life',
                'd.period AS period',
                'd.work_status AS work_status',
                'd.*',
                'd.oid AS oid',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.status AS status',
                'd.unit AS unit',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.org AS device_org',
                'd.bucket AS device_bucket',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'mq.host AS mqtt_host',
                'mq.port AS mqtt_port',
                't.type_name AS type_name',
                'l.location_name AS location_name',
                'l.configdata AS configdata',
                'st.setting_name AS setting_name',
                'mq.mqtt_name AS mqtt_name',
            ]);
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            query.andWhere('d.device_id=:device_id', { device_id: device_id });
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy('mq.sort', 'ASC');
            query.addOrderBy('d.device_id', 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate(dto) {
        console.log(`device_list_paginate dto=`);
        console.info(dto);
        try {
            const device_id = dto.device_id;
            const keyword = dto.keyword || '';
            const status = dto.status || '';
            const createddate = dto.createddate;
            const updateddate = dto.updateddate;
            const sort = dto.sort;
            const page = dto.page || 1;
            const pageSize = dto.pageSize || 10;
            const isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                const countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    `CASE WHEN d.hardware_id = 1 THEN 'Sensor' ELSE 'IO' END AS hardware_type_name`,
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'h.host_name AS host_name',
                    'h.port AS port',
                    'h.host_id AS host_id',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id = d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id = d.location_id');
            query.leftJoin('sd_iot_host', 'h', 'h.idhost = mq.mqtt_main_id');
            query.where('1=1');
            if (status) {
                query.andWhere('d.status = :status', { status });
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            const conditions = [
                { field: 'device_id', param: 'device_id', value: device_id },
                { field: 'org', param: 'org', value: dto.org },
                { field: 'bucket', param: 'bucket', value: dto.bucket },
                { field: 'createddate', param: 'createddate', value: createddate },
                { field: 'updateddate', param: 'updateddate', value: updateddate },
                { field: 'type_id', param: 'type_id', value: dto.type_id },
                { field: 'location_id', param: 'location_id', value: dto.location_id },
                { field: 'sn', param: 'sn', value: dto.sn },
                {
                    field: 'status_warning',
                    param: 'status_warning',
                    value: dto.status_warning,
                },
                {
                    field: 'recovery_warning',
                    param: 'recovery_warning',
                    value: dto.recovery_warning,
                },
                {
                    field: 'status_alert',
                    param: 'status_alert',
                    value: dto.status_alert,
                },
                {
                    field: 'recovery_alert',
                    param: 'recovery_alert',
                    value: dto.recovery_alert,
                },
                { field: 'time_life', param: 'time_life', value: dto.time_life },
                { field: 'period', param: 'period', value: dto.period },
                { field: 'max', param: 'max', value: dto.max },
                { field: 'min', param: 'min', value: dto.min },
                { field: 'hardware_id', param: 'hardware_id', value: dto.hardware_id },
                { field: 'model', param: 'model', value: dto.model },
                { field: 'vendor', param: 'vendor', value: dto.vendor },
                {
                    field: 'comparevalue',
                    param: 'comparevalue',
                    value: dto.comparevalue,
                },
                { field: 'mqtt_id', param: 'mqtt_id', value: dto.mqtt_id },
                { field: 'oid', param: 'oid', value: dto.oid },
                { field: 'action_id', param: 'action_id', value: dto.action_id },
                {
                    field: 'mqtt_data_value',
                    param: 'mqtt_data_value',
                    value: dto.mqtt_data_value,
                },
                {
                    field: 'mqtt_data_control',
                    param: 'mqtt_data_control',
                    value: dto.mqtt_data_control,
                },
            ];
            conditions.forEach((cond) => {
                if (cond.value !== undefined &&
                    cond.value !== null &&
                    cond.value !== '') {
                    query.andWhere(`d.${cond.field} = :${cond.param}`, {
                        [cond.param]: cond.value,
                    });
                }
            });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                const count = await query.getCount();
                console.log(`count => ${count}`);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sortField = ${sortField}`);
                    console.log(`sortOrder = ${sortOrder}`);
                    let sortOrders = 'ASC';
                    if (sortOrder.toUpperCase() === 'DESC') {
                        sortOrders = 'DESC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders);
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            console.error('Error in device_list_paginate:', error);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error.message || JSON.stringify(error) },
                },
            });
        }
    }
    async device_list_paginate1(dto) {
        console.log(` device_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'h.host_name AS host_name',
                    'h.port AS port',
                    'h.host_id AS host_id',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.leftJoin('sd_iot_host', 'h', 'h.idhost= mq.mqtt_main_id');
            query.where('1=1');
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginateV22(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate_active(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var status = 1;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            var keyword = encodeURI(keyword);
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            var bucket = encodeURI(dto.bucket);
            if (bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: bucket });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate_active_al(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var status = 1;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    `CASE WHEN d.hardware_id = 1 THEN 'Sensor' ELSE 'IO' END AS hardware_type_name`,
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'h.host_name AS host_name',
                    'h.port AS port',
                    'h.host_id AS host_id',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.leftJoin('sd_iot_host', 'h', 'h.idhost = mq.mqtt_main_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            var keyword = encodeURI(keyword);
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            var bucket = encodeURI(dto.bucket);
            if (bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: bucket });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate_schedule(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = 1;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async deviceactive(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var bucket = dto.bucket || '';
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.distinctOn(['d.mqtt_data_value']);
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.sn AS sn',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS time_life',
                'd.period AS period',
                'd.work_status AS work_status',
                'd.*',
                'd.oid AS oid',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.status AS status',
                'd.unit AS unit',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.org AS device_org',
                'd.bucket AS device_bucket',
                'd.updateddate AS timestamp',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
            ]);
            query.where('1=1');
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (bucket) {
                query.andWhere('d.bucket=:bucket', { bucket: bucket });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            const deviceList = await query.getRawMany();
            return deviceList;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async deviceactiveAl(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var bucket = dto.bucket || '';
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.sn AS sn',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS time_life',
                'd.period AS period',
                'd.work_status AS work_status',
                'd.*',
                'd.oid AS oid',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.status AS status',
                'd.unit AS unit',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.org AS device_org',
                'd.bucket AS device_bucket',
                'd.updateddate AS timestamp',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'mq.host AS mqtt_host',
                'mq.port AS mqtt_port',
                't.type_name AS type_name',
                'l.location_name AS location_name',
            ]);
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= st.location_id');
            query.where('1=1');
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (bucket) {
                query.andWhere('d.bucket=:bucket', { bucket: bucket });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.orderBy('d.type_id', 'ASC');
            query.addOrderBy('d.device_id', 'ASC');
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            const deviceList = await query.getRawMany();
            return deviceList;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async deviceactiveAlarm(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var bucket = dto.bucket || '';
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'e.alarm_action_id as alarm_action_id',
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.sn AS sn',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS d_status_warning',
                'd.recovery_warning AS d_recovery_warning',
                'd.status_alert AS d_status_alert',
                'd.recovery_alert AS d_recovery_alert',
                'alarm.action_name as action_name',
                'alarm.status_warning as status_warning',
                'alarm.recovery_warning as recovery_warning',
                'alarm.status_alert as status_alert',
                'alarm.recovery_alert as recovery_alert',
                'd.time_life AS time_life',
                'd.period AS period',
                'd.work_status AS work_status',
                'd.*',
                'd.oid AS oid',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.status AS status',
                'd.unit AS unit',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.org AS device_org',
                'd.bucket AS device_bucket',
                'd.updateddate AS timestamp',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'mq.host AS mqtt_host',
                'mq.port AS mqtt_port',
                't.type_name AS type_name',
                'l.location_name AS location_name',
            ]);
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= st.location_id');
            query.innerJoin('sd_iot_alarm_device_event', 'e', 'e.device_id = d.device_id AND d.status = :status', { status: 1 });
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= e.alarm_action_id');
            query.where('1=1');
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (bucket) {
                query.andWhere('d.bucket=:bucket', { bucket: bucket });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.orderBy('d.type_id', 'ASC');
            query.addOrderBy('d.device_id', 'ASC');
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            const deviceList = await query.getRawMany();
            return deviceList;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async device_list_paginate_schedule_status(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate_all(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var hardware_id = dto.hardware_id || '';
            var status = 1;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'mq.sort AS sort',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'h.host_name AS host_name',
                    'h.port AS port',
                    'h.host_id AS host_id',
                    `CASE WHEN d.hardware_id = 1 THEN 'Sensor' ELSE 'IO' END AS hardware_type_name`,
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'h.host_name AS host_name',
                    'h.port AS port',
                    'h.host_id AS host_id',
                    `CASE WHEN d.hardware_id = 1 THEN 'Sensor' ELSE 'IO' END AS hardware_type_name`,
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.leftJoin('sd_iot_host', 'h', 'h.idhost= mq.mqtt_main_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate_all_active(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'h.host_name AS host_name',
                    'h.port AS port',
                    'h.host_id AS host_id',
                    `CASE WHEN d.hardware_id = 1 THEN 'Sensor' ELSE 'IO' END AS hardware_type_name`,
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.leftJoin('sd_iot_host', 'h', 'h.idhost= mq.mqtt_main_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async device_list_paginate_all_active_io(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            var type_id = dto.type_id;
            if (type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: type_id });
            }
            else {
                query.andWhere('d.type_id!=1');
            }
            var hardware_id_io = '2';
            query.andWhere('d.hardware_id=:hardware_id', {
                hardware_id: hardware_id_io,
            });
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async device_list_paginate_all_filter(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = 1;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_all(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm_all(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var option = dto.option;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var location_id = dto.location_id;
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (location_id) {
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm_fan(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            var location_id = dto.location_id;
            if (!location_id) {
                var location_id = 1;
            }
            query.andWhere('d.location_id=:location_id', {
                location_id: location_id,
            });
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm_fans(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var option = dto.option;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var location_id = dto.location_id;
            if (option) {
                if (option == 1) {
                    query.andWhere('d.type_id=1');
                }
                else {
                    query.andWhere('d.type_id>=2');
                }
            }
            else {
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm_air(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var option = dto.option;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var location_id = dto.location_id;
            if (option) {
                if (option == 1) {
                    query.andWhere('d.type_id=1');
                }
                else {
                    query.andWhere('d.type_id>=2');
                }
            }
            else {
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm_airs(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var option = dto.option;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var location_id = dto.location_id;
            if (option) {
                if (option == 1) {
                    query.andWhere('d.type_id=1');
                }
                else {
                    query.andWhere('d.type_id>=2');
                }
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm_airss(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var option = dto.option;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.status AS data_status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (!location_id) {
                var location_id = 5;
            }
            else {
                var location_id = 5;
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm_fanss(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var option = dto.option;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.status AS data_status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var location_id = dto.location_id;
            if (!location_id) {
                var location_id = 1;
            }
            else {
                var location_id = 1;
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm_airV2(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'mq.latitude AS latitude',
                    'mq.longitude AS longitude',
                    'mq.mqtt_main_id AS mqtt_main_id',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var location_id = dto.location_id;
            if (!location_id) {
                var location_id = 5;
                query.andWhere('d.type_id>3');
            }
            else {
                query.andWhere('d.type_id<=3');
            }
            if (dto.type_id) {
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_ststus_alarm_limit(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var type_id = dto.type_id;
            var pageSize = dto.pageSize || 30000;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.*',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.status AS status',
                'd.unit AS unit',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.org AS device_org',
                'd.bucket AS device_bucket',
                't.type_name AS type_name',
                'l.location_name AS location_name',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
            ]);
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: type_id });
            }
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            query.limit(pageSize);
            query.offset(pageSize * (page - 1));
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_air_lists(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var type_id = dto.type_id || '';
            var status = dto.status;
            var mqtt_data_value = dto.mqtt_data_value;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 1000;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.setting_id AS setting_id',
                'd.type_id AS type_id',
                't.type_name AS type_name',
                'l.location_id AS location_id',
                'l.location_name AS location_name',
                'l.configdata AS configdata',
                'd.device_name AS device_name',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS time_life',
                'd.period AS period',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.status AS status',
                'd.unit AS unit',
                'd.mqtt_id AS mqtt_id',
                'd.oid AS oid',
                'd.status_alert_id AS status_alert_id',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.measurement AS measurement',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'd.sn AS sn',
                'd.*',
                'd.hardware_id AS hardware_id',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.action_id AS action_id',
                'mq.host AS mqtt_host',
                'mq.port AS mqtt_port',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
            ]);
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var org = dto.original;
            var bucket = dto.bucket;
            var mqtt_data_value = dto.mqtt_data_value;
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (keyword) {
                query.andWhere('d.device_name like :device_name', {
                    device_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: type_id });
            }
            if (org) {
                query.andWhere('d.org =:org', { org: org });
            }
            if (bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: bucket });
            }
            if (mqtt_data_value) {
                query.andWhere('d.mqtt_data_value =:mqtt_data_value', {
                    mqtt_data_value: mqtt_data_value,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            query.limit(pageSize);
            query.offset(pageSize * (page - 1));
            return await query.getRawMany();
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    message: 'Failed to retrieve device list.',
                    details: error,
                },
            });
        }
    }
    async device_lists(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var type_id = dto.type_id || '';
            var status = dto.status;
            var mqtt_data_value = dto.mqtt_data_value;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 1000;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.setting_id AS setting_id',
                'd.type_id AS type_id',
                't.type_name AS type_name',
                'l.location_id AS location_id',
                'l.location_name AS location_name',
                'l.configdata AS configdata',
                'd.device_name AS device_name',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS time_life',
                'd.period AS period',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.status AS status',
                'd.unit AS unit',
                'd.mqtt_id AS mqtt_id',
                'd.oid AS oid',
                'd.status_alert_id AS status_alert_id',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.measurement AS measurement',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'd.sn AS sn',
                'd.*',
                'd.hardware_id AS hardware_id',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.action_id AS action_id',
                'mq.host AS mqtt_host',
                'mq.port AS mqtt_port',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
            ]);
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var org = dto.original;
            var bucket = dto.bucket;
            var mqtt_data_value = dto.mqtt_data_value;
            if (dto.location_id) {
                query.andWhere('d.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (keyword) {
                query.andWhere('d.device_name like :device_name', {
                    device_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: type_id });
            }
            if (org) {
                query.andWhere('d.org =:org', { org: org });
            }
            if (bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: bucket });
            }
            if (mqtt_data_value) {
                query.andWhere('d.mqtt_data_value =:mqtt_data_value', {
                    mqtt_data_value: mqtt_data_value,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            query.limit(pageSize);
            query.offset(pageSize * (page - 1));
            return await query.getRawMany();
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    message: 'Failed to retrieve device list.',
                    details: error,
                },
            });
        }
    }
    async device_lists_group(dto) {
        console.log(`device_lists_group dto=`);
        console.info(dto);
        try {
            const device_id = dto.device_id;
            const type_id = dto.type_id || '';
            const hardware_id = dto.hardware_id || '';
            const status = dto.status;
            const query = this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.hardware_id AS hardware_id',
                't.type_id AS type_id',
                't.type_name AS type_name',
                'l.location_id AS location_id',
                'l.location_name AS location_name',
            ]);
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id = d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id = d.location_id');
            query.where('1 = 1');
            const org = dto.original || dto.org;
            const bucket = dto.bucket;
            const mqtt_data_value = dto.mqtt_data_value;
            if (hardware_id) {
                query.andWhere('d.hardware_id = :hardware_id', { hardware_id });
            }
            if (device_id) {
                query.andWhere('d.device_id = :device_id', { device_id });
            }
            if (type_id) {
                query.andWhere('d.type_id = :type_id', { type_id });
            }
            if (org) {
                query.andWhere('d.org = :org', { org });
            }
            if (bucket) {
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (mqtt_data_value) {
                query.andWhere('d.mqtt_data_value = :mqtt_data_value', {
                    mqtt_data_value,
                });
            }
            if (status) {
                query.andWhere('d.status = :status', { status });
            }
            console.log('Generated SQL:', query.getSql());
            query
                .groupBy('t.type_id, l.location_id')
                .orderBy('t.type_id', 'ASC')
                .addOrderBy('l.location_name', 'ASC');
            const result = await query.getRawMany();
            console.log(`Found ${result.length} records`);
            return result;
        }
        catch (error) {
            console.error('Error in device_lists_group:', error);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    message: 'Failed to retrieve device list.',
                    details: error.message || error,
                },
            });
        }
    }
    async device_lists_groups(dto) {
        console.log(`device_lists_group dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var type_id = dto.type_id || '';
            var hardware_id = dto.hardware_id || '';
            var status = dto.status;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                't.type_id AS type_id',
                't.type_name AS type_name',
                'l.location_name AS location_id',
                'l.location_name AS location_name',
            ]);
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var org = dto.original;
            var bucket = dto.bucket;
            var mqtt_data_value = dto.mqtt_data_value;
            if (hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: hardware_id,
                });
            }
            if (type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: type_id });
            }
            if (org) {
                query.andWhere('d.org =:org', { org: org });
            }
            if (bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: bucket });
            }
            if (mqtt_data_value) {
                query.andWhere('d.mqtt_data_value =:mqtt_data_value', {
                    mqtt_data_value: mqtt_data_value,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy('mq.sort', 'ASC');
            query.addOrderBy('d.device_id', 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    message: 'Failed to retrieve device list.',
                    details: error,
                },
            });
        }
    }
    async device_lists_id(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var layout = dto.layout;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var type_id = dto.type_id || '';
            var hardware_id = dto.hardware_id || '';
            var status = dto.status;
            var mqtt_data_value = dto.mqtt_data_value;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 1000;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.type_id AS type_id',
                'd.hardware_id AS hardware_id',
                't.type_name AS type_name',
                'd.device_name AS device_name',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS time_life',
                'd.period AS period',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.status AS status',
                'd.unit AS unit',
                'd.mqtt_id AS mqtt_id',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.measurement AS measurement',
                'd.layout as layout',
                'd.menu as menu',
                'd.max as "max"',
                'd.min as "min"',
                'l.location_name AS location_name',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'd.action_id AS action_id',
                'mq.host AS mqtt_host',
                'mq.port AS mqtt_port',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                'd.alert_set AS alert_set',
                'd.icon_normal AS icon_normal',
                'd.icon_warning AS icon_warning',
                'd.icon_alert AS icon_alert',
                'd.icon AS icon',
                'd.color_normal AS color_normal',
                'd.color_warning AS color_warning',
                'd.color_alert AS color_alert',
                'd.code AS code',
            ]);
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= d.location_id');
            query.where('1=1');
            var org = dto.original;
            var bucket = dto.bucket;
            var mqtt_data_value = dto.mqtt_data_value;
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.layout) {
                query.andWhere('d.layout=:layout', { layout: dto.layout });
            }
            if (dto.alert_set) {
                query.andWhere('d.alert_set=:alert_set', { alert_set: dto.alert_set });
            }
            if (keyword) {
                query.andWhere('d.device_name like :device_name', {
                    device_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: hardware_id,
                });
            }
            if (type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: type_id });
            }
            if (layout) {
                query.andWhere('d.layout=:layout', { layout: layout });
            }
            if (org) {
                query.andWhere('d.org =:org', { org: org });
            }
            if (bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: bucket });
            }
            var measurement = dto.measurement;
            if (measurement) {
                query.andWhere('d.measurement =:measurement', {
                    measurement: measurement,
                });
            }
            if (mqtt_data_value) {
                query.andWhere('d.mqtt_data_value =:mqtt_data_value', {
                    mqtt_data_value: mqtt_data_value,
                });
            }
            if (status) {
                query.andWhere('d.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (sort) {
                const sortResult = (0, format_helper_1.convertSortInput)(sort);
                if (sortResult == false) {
                    throw new common_1.BadRequestException(`Invalid sort option.`);
                }
                const { sortField, sortOrder } = sortResult;
                console.log(`sort=`);
                console.info(sort);
                console.log(`sortField=` + sortField);
                console.log(`sortOrder=` + sortOrder);
                console.log(`sortResult=`);
                console.info(sortResult);
                if (sortOrder == 'ASC' || sortOrder == 'asc') {
                    var sortOrders = 'ASC';
                }
                else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                    var sortOrders = 'DESC';
                }
                else {
                    var sortOrders = 'ASC';
                }
                query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
            }
            else {
                query.orderBy('mq.sort', 'ASC');
                query.addOrderBy('d.device_id', 'ASC');
            }
            query.limit(pageSize);
            query.offset(pageSize * (page - 1));
            return await query.getRawMany();
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    message: 'Failed to retrieve device list.',
                    details: error,
                },
            });
        }
    }
    async scheduledevicepage(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var schedule_id = dto.schedule_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'sd.schedule_id AS schedule_id',
                    'scd.schedule_name AS schedule_name',
                    'scd.start AS schedule_event_start',
                    'scd.event AS schedule_event',
                    'scd.sunday AS sunday',
                    'scd.monday AS monday',
                    'scd.tuesday AS tuesday',
                    'scd.wednesday AS wednesday',
                    'scd.thursday AS thursday',
                    'scd.friday AS friday',
                    'scd.saturday AS saturday',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_schedule_device', 'sd', 'sd.device_id= d.device_id');
            query.innerJoin('sd_iot_schedule', 'scd', 'scd.schedule_id= sd.schedule_id');
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (dto.status == '') {
                var status = 1;
            }
            else {
                var status = dto.status;
            }
            if (status) {
            }
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            if (schedule_id) {
                query.andWhere('scd.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            if (device_id) {
                query.andWhere('scd.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async scheduleprocess(dto) {
        try {
            var device_id = dto.device_id;
            var schedule_id = dto.schedule_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            var query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'sd.schedule_id AS schedule_id',
                    'scd.schedule_name AS schedule_name',
                    'scd.start AS schedule_event_start',
                    'scd.event AS schedule_event',
                    'scd.sunday AS sunday',
                    'scd.monday AS monday',
                    'scd.tuesday AS tuesday',
                    'scd.wednesday AS wednesday',
                    'scd.thursday AS thursday',
                    'scd.friday AS friday',
                    'scd.saturday AS saturday',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.innerJoin('sd_iot_schedule_device', 'sd', 'sd.device_id= d.device_id');
            query.innerJoin('sd_iot_schedule', 'scd', 'scd.schedule_id= sd.schedule_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            query.andWhere('scd.status=:status', { status: status });
            if (schedule_id) {
                query.andWhere('scd.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            if (device_id) {
                query.andWhere('scd.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('scd.start', 'ASC');
                    query.addOrderBy('scd.schedule_id', 'ASC');
                    query.addOrderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async scheduledeviceCOUNT(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var schedule_id = dto.schedule_id;
            const query = await this.scheduleDeviceRepository.createQueryBuilder('sc');
            var countRs = await query.select('COUNT(DISTINCT sc.device_id)', 'cnt');
            query.where('1=1');
            if (schedule_id) {
                query.andWhere('sc.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            if (device_id) {
                query.andWhere('sc.device_id=:device_id', { device_id: device_id });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Email() {
        try {
            const RS = await this.EmailRepository.query('SELECT MAX(email_id) AS email_id FROM sd_iot_email');
            console.log('email_id');
            console.info(RS);
            var email_id = RS['0'].email_id;
            console.log('max_email_id=');
            console.info(email_id);
            var max_email_id = max_email_id + 1;
            console.log('max_email_id=');
            console.info(max_email_id);
            return max_email_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_email(dto) {
        console.log('create_email=>');
        console.info(dto);
        const result = await this.EmailRepository.save(this.EmailRepository.create(dto));
        return result;
    }
    async delete_email(email_id) {
        try {
            this.logger.log(`Deleting email with email_id: ${email_id}`);
            const constemail = await this.get_email(email_id);
            if (!constemail) {
                throw new common_1.NotFoundException(`email_id with email_id ${email_id} not found`);
            }
            var criteria = { email_id: email_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const deleteResult = await this.EmailRepository.delete(criteria);
            console.log(`deleteResult:`, deleteResult);
        }
        catch (error) {
            this.logger.error(`Error while deleting email_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_email(email_id) {
        try {
            const rs = await this.EmailRepository.findOne({
                where: {
                    email_id,
                },
            });
            console.log('get_email rs=>');
            console.info(rs);
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_email(email_name) {
        try {
            console.log('email_name=>');
            console.info(email_name);
            const rs = await this.EmailRepository.findOne({
                where: {
                    email_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_email(dto) {
        let email_id = dto.email_id;
        const DataUpdate = {};
        const query = await this.EmailRepository.createQueryBuilder('e');
        query.select(['e.email_id AS email_id']);
        query.where('1=1');
        query.andWhere('e.email_id=:email_id', { email_id: email_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with email_id ${email_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found email_idemail_id ${email_id}.`,
                message_th: `ไม่พบข้อมูล email_idemail_id ${email_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.email_type_id) {
            DataUpdate.email_type_id = dto.email_type_id;
        }
        if (dto.email_name) {
            DataUpdate.email_name = dto.email_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.username) {
            DataUpdate.username = dto.username;
        }
        if (dto.password) {
            DataUpdate.password = dto.password;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.EmailRepository.createQueryBuilder()
            .update('sd_iot_email')
            .set(DataUpdate)
            .where('email_id=:email_id', { email_id: email_id })
            .execute();
        return 200;
    }
    async update_email_status(email_id, status) {
        console.log(`Updating devices with bucket '${email_id}' to status ${status}`);
        try {
            if (status == 1) {
                var DataUpdate = {};
                var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
                var updateddate = moment(new Date(), DATE_TIME_FORMAT);
                var statusset = '0';
                DataUpdate.status = statusset;
                DataUpdate.updateddate = Date();
                console.log('update DataUpdate');
                console.info(DataUpdate);
                await this.HostRepository.createQueryBuilder()
                    .update('sd_iot_email')
                    .set(DataUpdate)
                    .execute();
            }
            var updateResult = await this.EmailRepository.update({ email_id: email_id }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for mqtt_id '${email_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${email_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for email_id '${email_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for mqtt_id '${email_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async email_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.EmailRepository.createQueryBuilder('e');
            query.select(['e.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async email_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var id = dto.id;
            var email_id = dto.email_id;
            var email_type_id = dto.email_type_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.EmailRepository.createQueryBuilder('e');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT e.email_id)', 'cnt');
            }
            else {
                query.select([
                    'e.email_id AS email_id',
                    'e.email_name AS email_name',
                    'e.host AS host',
                    'e.port AS port',
                    'e.username AS username',
                    'e.password AS password',
                    'e.updateddate AS updateddate',
                    'e.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('e.email_name like :email_name', {
                    email_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (id) {
                query.andWhere('e.id=:id', { id: id });
            }
            if (email_id) {
                query.andWhere('e.email_id=:email_id', { email_id: email_id });
            }
            if (createddate) {
                query.andWhere('e.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('e.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('e.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`e.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`e.email_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async create_mqtthost(dto) {
        console.log('create_mqtthost=>');
        console.info(dto);
        const result = await this.mqtthostRepository.save(this.mqtthostRepository.create(dto));
        return result;
    }
    async delete_mqtthost(id) {
        try {
            this.logger.log(`Deleting mqtt with id: ${id}`);
            const constmqtt = await this.get_mqtthost(id);
            if (!constmqtt) {
                throw new common_1.NotFoundException(`id with id ${id} not found`);
            }
            var criteria = { id: id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const deleteResult = await this.mqtthostRepository.delete(criteria);
            console.log(`deleteResult:`, deleteResult);
        }
        catch (error) {
            this.logger.error(`Error while deleting id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_mqtthost_id(id) {
        try {
            const rs = await this.mqtthostRepository.findOne({
                where: {
                    id,
                },
            });
            console.log('get_mqtthost rs=>');
            console.info(rs);
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_mqtthost(hostname) {
        try {
            const rs = await this.mqtthostRepository.findOne({
                where: {
                    hostname,
                },
            });
            console.log('get_mqtthost rs=>');
            console.info(rs);
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_mqtthost(hostname) {
        try {
            console.log('hostname=>');
            console.info(hostname);
            const rs = await this.mqtthostRepository.findOne({
                where: {
                    hostname,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_mqtthost(dto) {
        let id = dto.id;
        const DataUpdatmqtt = {};
        const query = await this.mqtthostRepository.createQueryBuilder('mqtt');
        query.select(['mqtt.id AS id']);
        query.where('1=1');
        query.andWhere('mqtt.id=:id', { id: id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with id ${id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found idid ${id}.`,
                message_th: `ไม่พบข้อมูล idid ${id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.hostname) {
            DataUpdatmqtt.hostname = dto.hostname;
        }
        if (dto.host) {
            DataUpdatmqtt.host = dto.host;
        }
        if (dto.port) {
            DataUpdatmqtt.port = dto.port;
        }
        if (dto.username) {
            DataUpdatmqtt.username = dto.username;
        }
        if (dto.password) {
            DataUpdatmqtt.password = dto.password;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdatmqtt.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdatmqtt);
        await this.mqtthostRepository
            .createQueryBuilder()
            .update('sd_mqtt_host')
            .set(DataUpdatmqtt)
            .where('id=:id', { id: id })
            .execute();
        return 200;
    }
    async update_mqtthost_status_v2(id, status) {
        console.log(`Updating devices with bucket '${id}' to status ${status}`);
        try {
            if (status == 1) {
                var DataUpdatmqtt = {};
                var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
                var updateddate = moment(new Date(), DATE_TIME_FORMAT);
                var statusset = status;
                DataUpdatmqtt.status = statusset;
                DataUpdatmqtt.updateddate = Date();
                console.log('update DataUpdate');
                console.info(DataUpdatmqtt);
                await this.HostRepository.createQueryBuilder()
                    .update('sd_mqtt_host')
                    .set(DataUpdatmqtt)
                    .where('id!=:id', { id: id })
                    .execute();
            }
            var updateResult = await this.mqtthostRepository.update({ id: id }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for mqtt_id '${id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for id '${id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for mqtt_id '${id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async update_mqtthost_status_v1(id, status) {
        console.log(`Updating devices with bucket '${id}' to status ${status}`);
        try {
            if (status == 1) {
                var DataUpdatmqtt = {};
                var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
                var updateddate = moment(new Date(), DATE_TIME_FORMAT);
                var statusset = '0';
                DataUpdatmqtt.status = statusset;
                DataUpdatmqtt.updateddate = Date();
                console.log('update DataUpdate');
                console.info(DataUpdatmqtt);
                await this.HostRepository.createQueryBuilder()
                    .update('sd_mqtt_host')
                    .set(DataUpdatmqtt)
                    .execute();
            }
            var updateResult = await this.mqtthostRepository.update({ id: id }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for mqtt_id '${id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for id '${id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for mqtt_id '${id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async update_mqtthost_status(id, status) {
        console.log(`Updating devices with bucket '${id}' to status ${status}`);
        try {
            if (status == 1) {
                var DataUpdatmqtt = {};
                var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
                var updateddate = moment(new Date(), DATE_TIME_FORMAT);
                var statusset = '0';
                DataUpdatmqtt.status = statusset;
                DataUpdatmqtt.updateddate = Date();
                console.log('update DataUpdate');
                console.info(DataUpdatmqtt);
                await this.HostRepository.createQueryBuilder()
                    .update('sd_mqtt_host')
                    .set(DataUpdatmqtt)
                    .execute();
            }
            var updateResult = await this.mqtthostRepository.update({ id: id }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for mqtt_id '${id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for id '${id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for mqtt_id '${id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async mqtthost_all() {
        console.log(`=mqtt_all=`);
        try {
            const query = await this.mqtthostRepository.createQueryBuilder('mqtt');
            query.select(['mqtt.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async mqtthost_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var id = dto.id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var username = dto.username;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.mqtthostRepository.createQueryBuilder('mqtt');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT mqtt.id)', 'cnt');
            }
            else {
                query.select([
                    'mqtt.id AS id',
                    'mqtt.hostname AS hostname',
                    'mqtt.host AS host',
                    'mqtt.port AS port',
                    'mqtt.username AS username',
                    'mqtt.password AS password',
                    'mqtt.updateddate AS updateddate',
                    'mqtt.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('mqtt.hostname like :hostname', {
                    hostname: keyword ? `%${keyword}%` : '%',
                });
            }
            if (id) {
                query.andWhere('mqtt.id=:id', { id: id });
            }
            if (username) {
                query.andWhere('username.id=:username', { username: username });
            }
            if (createddate) {
                query.andWhere('mqtt.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('mqtt.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('mqtt.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`mqtt.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`mqtt.updateddate`, 'DESC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Host() {
        try {
            const RS = await this.HostRepository.query('SELECT MAX(host_id) AS host_id FROM sd_iot_host');
            console.log('host_id');
            console.info(RS);
            var host_id = RS['0'].host_id;
            console.log('max_host_id=');
            console.info(host_id);
            var max_host_id = max_host_id + 1;
            console.log('max_host_id=');
            console.info(max_host_id);
            return max_host_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_host(dto) {
        console.log('create_host=>');
        console.info(dto);
        const result = await this.HostRepository.save(this.HostRepository.create(dto));
        return result;
    }
    async delete_host(host_id) {
        try {
            this.logger.log(`Deleting email with host_id: ${host_id}`);
            const constemail = await this.get_host(host_id);
            if (!constemail) {
                throw new common_1.NotFoundException(`host_id with host_id ${host_id} not found`);
            }
            var criteria = { host_id: host_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const deleteResult = await this.HostRepository.delete(criteria);
            console.log(`deleteResult:`, deleteResult);
        }
        catch (error) {
            this.logger.error(`Error while deleting host_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_host(host_id) {
        try {
            const rs = await this.HostRepository.findOne({
                where: {
                    host_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_host(host_name) {
        try {
            console.log('host_name=>');
            console.info(host_name);
            const rs = await this.HostRepository.findOne({
                where: {
                    host_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_host(dto) {
        let host_id = dto.host_id;
        const DataUpdate = {};
        const query = await this.HostRepository.createQueryBuilder('h');
        query.select(['h.host_id AS host_id']);
        query.where('1=1');
        query.andWhere('h.host_id=:host_id', { host_id: host_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with host_id ${host_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found host_idhost_id ${host_id}.`,
                message_th: `ไม่พบข้อมูล host_idhost_id ${host_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.host_type_id) {
            DataUpdate.host_type_id = dto.host_type_id;
        }
        if (dto.host_name) {
            DataUpdate.host_name = dto.host_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.username) {
            DataUpdate.username = dto.username;
        }
        if (dto.password) {
            DataUpdate.password = dto.password;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.HostRepository.createQueryBuilder()
            .update('sd_iot_host')
            .set(DataUpdate)
            .where('host_id=:host_id', { host_id: host_id })
            .execute();
        return 200;
    }
    async host_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.HostRepository.createQueryBuilder('h');
            query.select(['h.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async host_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var host_id = dto.host_id;
            var host_type_id = dto.host_type_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.HostRepository.createQueryBuilder('h');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT h.host_id)', 'cnt');
            }
            else {
                query.select([
                    'h.host_id AS host_id',
                    'h.host_name AS host_name',
                    'h.host AS host',
                    'h.port AS port',
                    'h.username AS username',
                    'h.password AS password',
                    'h.updateddate AS updateddate',
                    'h.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('h.host_name like :host_name', {
                    host_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (host_id) {
                query.andWhere('h.host_id=:host_id', { host_id: host_id });
            }
            if (createddate) {
                query.andWhere('h.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('h.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('h.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`h.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`h.host_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Influxdb() {
        try {
            const RS = await this.HostRepository.query('SELECT MAX(influxdb_id) AS influxdb_id FROM sd_iot_influxdb');
            console.log('influxdb_id');
            console.info(RS);
            var influxdb_id = RS['0'].influxdb_id;
            console.log('max_influxdb_id=');
            console.info(influxdb_id);
            var max_influxdb_id = max_influxdb_id + 1;
            console.log('max_influxdb_id=');
            console.info(max_influxdb_id);
            return max_influxdb_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_influxdb(dto) {
        console.log('create_influxdb=>');
        console.info(dto);
        const result = await this.InfluxdbRepository.save(this.InfluxdbRepository.create(dto));
        return result;
    }
    async delete_influxdb(influxdb_id) {
        try {
            this.logger.log(`Deleting email with influxdb_id: ${influxdb_id}`);
            const constemail = await this.get_influxdb(influxdb_id);
            if (!constemail) {
                throw new common_1.NotFoundException(`influxdb_id with influxdb_id ${influxdb_id} not found`);
            }
            var criteria = { influxdb_id: influxdb_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const deleteResult = await this.InfluxdbRepository.delete(criteria);
            console.log(`deleteResult:`, deleteResult);
        }
        catch (error) {
            this.logger.error(`Error while deleting influxdb_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_influxdb(influxdb_id) {
        try {
            const rs = await this.InfluxdbRepository.findOne({
                where: {
                    influxdb_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_influxdb(influxdb_name) {
        try {
            console.log('influxdb_name=>');
            console.info(influxdb_name);
            const rs = await this.InfluxdbRepository.findOne({
                where: {
                    influxdb_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_influxdb(dto) {
        let influxdb_id = dto.influxdb_id;
        const DataUpdate = {};
        const query = await this.InfluxdbRepository.createQueryBuilder('db');
        query.select(['db.influxdb_id AS influxdb_id']);
        query.where('1=1');
        query.andWhere('db.influxdb_id=:influxdb_id', { influxdb_id: influxdb_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with influxdb_id ${influxdb_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found influxdb_idinfluxdb_id ${influxdb_id}.`,
                message_th: `ไม่พบข้อมูล influxdb_idinfluxdb_id ${influxdb_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.influxdb_name) {
            DataUpdate.influxdb_name = dto.influxdb_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.username) {
            DataUpdate.username = dto.username;
        }
        if (dto.password) {
            DataUpdate.password = dto.password;
        }
        if (dto.token_value) {
            DataUpdate.token_value = dto.token_value;
        }
        if (dto.buckets) {
            DataUpdate.buckets = dto.buckets;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.InfluxdbRepository.createQueryBuilder()
            .update('sd_iot_influxdb')
            .set(DataUpdate)
            .where('influxdb_id=:influxdb_id', { influxdb_id: influxdb_id })
            .execute();
        return 200;
    }
    async influxdb_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.InfluxdbRepository.createQueryBuilder('db');
            query.select(['db.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async influxdb_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var influxdb_id = dto.influxdb_id;
            var keyword = dto.keyword || '';
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.InfluxdbRepository.createQueryBuilder('db');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT db.influxdb_id)', 'cnt');
            }
            else {
                query.select([
                    'db.influxdb_id AS influxdb_id',
                    'db.influxdb_name AS influxdb_name',
                    'db.host AS host',
                    'db.port AS port',
                    'db.username AS username',
                    'db.password AS password',
                    'db.buckets AS buckets',
                    'db.token_value AS token_value',
                    'db.updateddate AS updateddate',
                    'db.status AS status',
                ]);
            }
            if (dto.keyword) {
                query.andWhere('db.influxdb_name like :influxdb_name', {
                    name: keyword ? `%${dto.keyword}%` : '%',
                });
            }
            if (dto.influxdb_id) {
                query.andWhere('db.influxdb_id=:influxdb_id', {
                    influxdb_id: dto.influxdb_id,
                });
            }
            if (dto.username) {
                query.andWhere('db.username=:username', { username: dto.username });
            }
            if (dto.password) {
                query.andWhere('db.password=:password', { password: dto.password });
            }
            if (dto.buckets) {
                query.andWhere('db.buckets=:buckets', { buckets: dto.buckets });
            }
            if (dto.token_value) {
                query.andWhere('db.token_value=:token_value', {
                    token_value: dto.token_value,
                });
            }
            if (dto.status) {
                query.andWhere('db.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                query.orderBy(`db.createddate`, 'DESC');
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async update_influxdb_status(influxdb_id, status) {
        console.log(`Updating devices with bucket '${influxdb_id}' to status ${status}`);
        try {
            if (status == 1) {
                var DataUpdate = {};
                var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
                var updateddate = moment(new Date(), DATE_TIME_FORMAT);
                var statusset = '0';
                DataUpdate.status = statusset;
                DataUpdate.updateddate = Date();
                console.log('update DataUpdate');
                console.info(DataUpdate);
                await this.HostRepository.createQueryBuilder()
                    .update('sd_iot_influxdb')
                    .set(DataUpdate)
                    .execute();
            }
            var DataUpdatmqtt = {};
            var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
            var updateddate = moment(new Date(), DATE_TIME_FORMAT);
            DataUpdatmqtt.status = status;
            DataUpdatmqtt.updateddate = Date();
            console.log('update DataUpdate');
            console.info(DataUpdatmqtt);
            var updateResult = await this.HostRepository.createQueryBuilder()
                .update('sd_iot_influxdb')
                .set(DataUpdatmqtt)
                .where('influxdb_id=:influxdb_id', { influxdb_id: influxdb_id })
                .execute();
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for mqtt_id '${influxdb_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${influxdb_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for influxdb_id '${influxdb_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for mqtt_id '${influxdb_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async maxid_Line() {
        try {
            const RS = await this.LineRepository.query('SELECT MAX(line_id) AS line_id FROM sd_iot_line');
            console.log('line_id');
            console.info(RS);
            var line_id = RS['0'].line_id;
            console.log('max_line_id=');
            console.info(line_id);
            var max_line_id = max_line_id + 1;
            console.log('max_line_id=');
            console.info(max_line_id);
            return max_line_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_line(dto) {
        console.log('create_line=>');
        console.info(dto);
        const result = await this.LineRepository.save(this.LineRepository.create(dto));
        return result;
    }
    async delete_line(line_id) {
        try {
            this.logger.log(`Deleting email with line_id: ${line_id}`);
            const constemail = await this.get_line(line_id);
            if (!constemail) {
                throw new common_1.NotFoundException(`line_id with line_id ${line_id} not found`);
            }
            var criteria = { line_id: line_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const deleteResult = await this.LineRepository.delete(criteria);
            console.log(`deleteResult:`, deleteResult);
        }
        catch (error) {
            this.logger.error(`Error while deleting line_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_line(line_id) {
        try {
            const rs = await this.LineRepository.findOne({
                where: {
                    line_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_line_status(line_id, status) {
        console.log(`Updating devices with bucket '${line_id}' to status ${status}`);
        try {
            if (status == 1) {
                var DataUpdate = {};
                var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
                var updateddate = moment(new Date(), DATE_TIME_FORMAT);
                var statusset = '0';
                DataUpdate.status = statusset;
                DataUpdate.updateddate = Date();
                console.log('update DataUpdate');
                console.info(DataUpdate);
                await this.HostRepository.createQueryBuilder()
                    .update('sd_iot_line')
                    .set(DataUpdate)
                    .execute();
            }
            var updateResult = await this.LineRepository.update({ line_id: line_id }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for line_id '${line_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${line_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for line_id '${line_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for line_id '${line_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async get_name_create_line(line_name) {
        try {
            console.log('line_name=>');
            console.info(line_name);
            const rs = await this.LineRepository.findOne({
                where: {
                    line_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_line(dto) {
        let line_id = dto.line_id;
        const DataUpdate = {};
        const query = await this.LineRepository.createQueryBuilder('line');
        query.select(['line.line_id AS line_id']);
        query.where('1=1');
        query.andWhere('line.line_id=:line_id', { line_id: line_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with line_id ${line_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found line_idline_id ${line_id}.`,
                message_th: `ไม่พบข้อมูล line_idline_id ${line_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.line_name) {
            DataUpdate.line_name = dto.line_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.username) {
            DataUpdate.username = dto.username;
        }
        if (dto.password) {
            DataUpdate.password = dto.password;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.LineRepository.createQueryBuilder()
            .update('sd_iot_line')
            .set(DataUpdate)
            .where('line_id=:line_id', { line_id: line_id })
            .execute();
        return 200;
    }
    async line_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.LineRepository.createQueryBuilder('line');
            query.select(['line.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async line_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var line_id = dto.line_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.LineRepository.createQueryBuilder('line');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT line.line_id)', 'cnt');
            }
            else {
                query.select(['*']);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('line.line_name like :line_name', {
                    line_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (line_id) {
                query.andWhere('line.line_id=:line_id', { line_id: line_id });
            }
            if (createddate) {
                query.andWhere('line.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('line.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('line.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`line.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`line.line_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async update_Line_status(line_id, status) {
        console.log(`Updating devices with line_id '${line_id}' to status ${status}`);
        try {
            if (status == 1) {
                var DataUpdatmqtt = {};
                var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
                var updateddate = moment(new Date(), DATE_TIME_FORMAT);
                var statusset = '0';
                DataUpdatmqtt.status = statusset;
                DataUpdatmqtt.updateddate = Date();
                console.log('update DataUpdate');
                console.info(DataUpdatmqtt);
                await this.HostRepository.createQueryBuilder()
                    .update('sd_iot_influxdb')
                    .set(DataUpdatmqtt)
                    .where('line_id=:line_id', { line_id: line_id })
                    .execute();
            }
            var updateResult = await this.LineRepository.update({ line_id: line_id }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for line_id '${line_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${line_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for line_id '${line_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for line_id '${line_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async maxid_Nodered() {
        try {
            const RS = await this.NoderedRepository.query('SELECT MAX(token_id) AS token_id FROM sd_iot_nodered');
            console.log('token_id');
            console.info(RS);
            var token_id = RS['0'].token_id;
            console.log('max_token_id=');
            console.info(token_id);
            var max_token_id = max_token_id + 1;
            console.log('max_token_id=');
            console.info(max_token_id);
            return max_token_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_nodered(dto) {
        console.log('create_nodered=>');
        console.info(dto);
        const result = await this.NoderedRepository.save(this.NoderedRepository.create(dto));
        return result;
    }
    async delete_nodered(nodered_id) {
        try {
            this.logger.log(`Deleting email with nodered_id: ${nodered_id}`);
            const constemail = await this.get_nodered(nodered_id);
            if (!constemail) {
                throw new common_1.NotFoundException(`nodered_id with nodered_id ${nodered_id} not found`);
            }
            var criteria = { nodered_id: nodered_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const deleteResult = await this.NoderedRepository.delete(criteria);
            console.log(`deleteResult:`, deleteResult);
        }
        catch (error) {
            this.logger.error(`Error while deleting nodered_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_nodered(nodered_id) {
        try {
            const rs = await this.NoderedRepository.findOne({
                where: {
                    nodered_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_nodered(nodered_name) {
        try {
            console.log('nodered_name=>');
            console.info(nodered_name);
            const rs = await this.NoderedRepository.findOne({
                where: {
                    nodered_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_nodered(dto) {
        let nodered_id = dto.nodered_id;
        const DataUpdate = {};
        const query = await this.NoderedRepository.createQueryBuilder('nodered');
        query.select(['nodered.nodered_id AS nodered_id']);
        query.where('1=1');
        query.andWhere('nodered.nodered_id=:nodered_id', {
            nodered_id: nodered_id,
        });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with nodered_id ${nodered_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found nodered_idnodered_id ${nodered_id}.`,
                message_th: `ไม่พบข้อมูล nodered_idnodered_id ${nodered_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.nodered_name) {
            DataUpdate.nodered_name = dto.nodered_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.routing) {
            DataUpdate.routing = dto.routing;
        }
        if (dto.client_id) {
            DataUpdate.client_id = dto.client_id;
        }
        if (dto.grant_type) {
            DataUpdate.grant_type = dto.grant_type;
        }
        if (dto.scope) {
            DataUpdate.scope = dto.scope;
        }
        if (dto.username) {
            DataUpdate.username = dto.username;
        }
        if (dto.password) {
            DataUpdate.password = dto.password;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.NoderedRepository.createQueryBuilder()
            .update('sd_iot_nodered')
            .set(DataUpdate)
            .where('nodered_id=:nodered_id', { nodered_id: nodered_id })
            .execute();
        return 200;
    }
    async nodered_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.NoderedRepository.createQueryBuilder('nodered');
            query.select(['nodered.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async nodered_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var nodered_id = dto.nodered_id;
            var nodered_type_id = dto.nodered_type_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.NoderedRepository.createQueryBuilder('nodered');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT nodered.nodered_id)', 'cnt');
            }
            else {
                query.select([
                    'nodered.nodered_id AS nodered_id',
                    'nodered.nodered_name AS nodered_name',
                    'nodered.host AS host',
                    'nodered.port AS port',
                    'nodered.routing AS routing',
                    'nodered.client_id AS client_id',
                    'nodered.grant_type AS grant_type',
                    'nodered.scope AS scope',
                    'nodered.username AS username',
                    'nodered.password AS password',
                    'nodered.createddate AS createddate',
                    'nodered.updateddate AS updateddate',
                    'nodered.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('nodered.nodered_name like :nodered_name', {
                    nodered_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (nodered_id) {
                query.andWhere('nodered.nodered_id=:nodered_id', {
                    nodered_id: nodered_id,
                });
            }
            if (createddate) {
                query.andWhere('nodered.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('nodered.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (status) {
                query.andWhere('nodered.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`nodered.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`nodered.createddate`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async update_nodered_status(nodered_id, status) {
        console.log(`Updating devices with bucket '${nodered_id}' to status ${status}`);
        try {
            if (status == 1) {
                var DataUpdate = {};
                var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
                var updateddate = moment(new Date(), DATE_TIME_FORMAT);
                var statusset = '0';
                DataUpdate.status = statusset;
                DataUpdate.updateddate = Date();
                console.log('update DataUpdate');
                console.info(DataUpdate);
                await this.NoderedRepository.createQueryBuilder()
                    .update('sd_iot_nodered')
                    .set(DataUpdate)
                    .execute();
            }
            var DataUpdatmqtt = {};
            var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
            var updateddate = moment(new Date(), DATE_TIME_FORMAT);
            DataUpdatmqtt.status = status;
            DataUpdatmqtt.updateddate = Date();
            console.log('update DataUpdate');
            console.info(DataUpdatmqtt);
            var updateResult = await this.NoderedRepository.createQueryBuilder()
                .update('sd_iot_nodered')
                .set(DataUpdatmqtt)
                .where('nodered_id=:nodered_id', { nodered_id: nodered_id })
                .execute();
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for mqtt_id '${nodered_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${nodered_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for nodered_id '${nodered_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for mqtt_id '${nodered_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async maxid_Schedule() {
        try {
            const RS = await this.NoderedRepository.query('SELECT MAX(schedule_id) AS schedule_id FROM sd_iot_schedule');
            console.log('schedule_id');
            console.info(RS);
            var schedule_id = RS['0'].schedule_id;
            console.log('max_schedule_id=');
            console.info(schedule_id);
            var max_schedule_id = max_schedule_id + 1;
            console.log('max_schedule_id=');
            console.info(max_schedule_id);
            return max_schedule_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_schedule(dto) {
        console.log('create_schedule=>');
        console.info(dto);
        const result = await this.ScheduleRepository.save(this.ScheduleRepository.create(dto));
        return result;
    }
    async get_schedule(schedule_id) {
        try {
            const schedule = await this.ScheduleRepository.findOne({
                where: { schedule_id },
            });
            return schedule || null;
        }
        catch (err) {
            this.logger.error(`Error fetching schedule_id ${schedule_id}: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async delete_schedule(schedule_id) {
        try {
            this.logger.log(`Deleting schedule with schedule_id: ${schedule_id}`);
            const query = await this.scheduleDeviceRepository.createQueryBuilder('s');
            var countRs = await query.select('COUNT(DISTINCT s.schedule_id)', 'cnt');
            query.where('1=1');
            query.andWhere('s.schedule_id=:schedule_id', {
                schedule_id: schedule_id,
            });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = { schedule_id: schedule_id };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.scheduleDeviceRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
            }
            var criteria = { schedule_id: schedule_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const result = await this.ScheduleRepository.delete(criteria);
            console.log(`result:`, result);
            if (result.affected == 0) {
                throw new common_1.NotFoundException(`Schedule with schedule_id ${schedule_id} not found`);
            }
            this.logger.log(`Successfully deleted schedule_id: ${schedule_id}`);
        }
        catch (error) {
            this.logger.error(`Error while deleting schedule_id: ${schedule_id} - ${error.message}`);
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_name_create_schedule(schedule_name) {
        try {
            console.log('schedule_name=>');
            console.info(schedule_name);
            const rs = await this.ScheduleRepository.findOne({
                where: {
                    schedule_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_schedule(dto) {
        const schedule_id = dto.schedule_id;
        if (!schedule_id) {
            throw new common_1.BadRequestException('schedule_id is required');
        }
        const schedule = await this.ScheduleRepository.findOne({
            where: { schedule_id },
        });
        if (!schedule) {
            throw new common_1.NotFoundException(`Data with schedule_id ${schedule_id} not found`);
        }
        const DataUpdate = {};
        const updatableFields = [
            'schedule_name',
            'device_id',
            'start',
            'event',
            'sunday',
            'monday',
            'tuesday',
            'wednesday',
            'thursday',
            'friday',
            'saturday',
            'status',
            'calendar_time',
        ];
        for (const key of updatableFields) {
            if (dto[key] !== undefined) {
                DataUpdate[key] = dto[key];
            }
        }
        DataUpdate.updateddate = new Date();
        await this.ScheduleRepository.createQueryBuilder()
            .update('sd_iot_schedule')
            .set(DataUpdate)
            .where('schedule_id = :schedule_id', { schedule_id })
            .execute();
        return {
            statusCode: 200,
            code: 200,
            message: `Update successful`,
            message_th: `อัปเดตข้อมูลสำเร็จ`,
            payload: null,
        };
    }
    async schedule_alls() {
        console.log(`=group_all=`);
        try {
            const query = await this.ScheduleRepository.createQueryBuilder('schedule');
            query.select(['schedule.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async schedule_all(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            const query = await this.ScheduleRepository.createQueryBuilder('schedule');
            query.select([
                'schedule.schedule_id AS schedule_id',
                'schedule.schedule_name AS schedule_name',
                'schedule.device_id AS device_id',
                'schedule.start AS start',
                'schedule.event AS event',
                'schedule.sunday AS sunday',
                'schedule.monday AS monday',
                'schedule.tuesday AS tuesday',
                'schedule.wednesday AS wednesday',
                'schedule.thursday AS thursday',
                'schedule.friday AS friday',
                'schedule.saturday AS saturday',
                'schedule.createddate AS createddate',
                'schedule.updateddate AS updateddate',
                'schedule.status AS status',
            ]);
            query.andWhere('1=1');
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy(`schedule.schedule_id`, 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async schedule_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.ScheduleRepository.createQueryBuilder('schedule');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT schedule.schedule_id)', 'cnt');
            }
            else {
                query.select([
                    'schedule.schedule_id AS schedule_id',
                    'schedule.schedule_name AS schedule_name',
                    'd.device_name AS device_name',
                    'schedule.device_id AS device_id',
                    'schedule.start AS start',
                    'schedule.event AS event',
                    'schedule.sunday AS sunday',
                    'schedule.monday AS monday',
                    'schedule.tuesday AS tuesday',
                    'schedule.wednesday AS wednesday',
                    'schedule.thursday AS thursday',
                    'schedule.friday AS friday',
                    'schedule.saturday AS saturday',
                    'schedule.createddate AS createddate',
                    'schedule.updateddate AS updateddate',
                    'schedule.status AS status',
                ]);
                query.leftJoin('sd_iot_device', 'd', 'd.device_id= schedule.schedule_id');
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('schedule.schedule_name like :schedule_name', {
                    schedule_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (dto.schedule_id) {
                query.andWhere('schedule.schedule_id=:schedule_id', {
                    schedule_id: dto.schedule_id,
                });
            }
            if (dto.event) {
                query.andWhere('schedule.event=:event', { event: dto.event });
            }
            if (dto.sunday) {
                query.andWhere('schedule.sunday=:sunday', { sunday: dto.sunday });
            }
            if (dto.monday) {
                query.andWhere('schedule.monday=:monday', { monday: dto.monday });
            }
            if (dto.tuesday) {
                query.andWhere('schedule.tuesday=:tuesday', { tuesday: dto.tuesday });
            }
            if (dto.wednesday) {
                query.andWhere('schedule.wednesday=:wednesday', {
                    wednesday: dto.wednesday,
                });
            }
            if (dto.thursday) {
                query.andWhere('schedule.thursday=:thursday', {
                    thursday: dto.thursday,
                });
            }
            if (dto.friday) {
                query.andWhere('schedule.friday=:friday', { friday: dto.friday });
            }
            if (dto.saturday) {
                query.andWhere('schedule.saturday=:saturday', {
                    saturday: dto.saturday,
                });
            }
            if (dto.createddate) {
                query.andWhere('schedule.createddate=:createddate', {
                    createddate: dto.createddate,
                });
            }
            if (dto.updateddate) {
                query.andWhere('schedule.updateddate=:updateddate', {
                    updateddate: dto.updateddate,
                });
            }
            if (dto.status) {
                query.andWhere('schedule.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`schedule.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`schedule.schedule_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxidx_Sms() {
        try {
            const RS = await this.NoderedRepository.query('SELECT MAX(sms_id) AS sms_id FROM sd_iot_sms');
            console.log('sms_id');
            console.info(RS);
            var sms_id = RS['0'].sms_id;
            console.log('max_sms_id=');
            console.info(sms_id);
            var max_sms_id = max_sms_id + 1;
            console.log('max_sms_id=');
            console.info(max_sms_id);
            return max_sms_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async maxid_Sms() {
        try {
            const RS = await this.NoderedRepository.query('SELECT MAX(nodered_id) AS nodered_id FROM sd_iot_sms');
            console.log('sms_id');
            console.info(RS);
            var sms_id = RS['0'].sms_id;
            console.log('max_sms_id=');
            console.info(sms_id);
            var max_sms_id = max_sms_id + 1;
            console.log('max_sms_id=');
            console.info(max_sms_id);
            return max_sms_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_sms(dto) {
        console.log('create_sms=>');
        console.info(dto);
        const result = await this.SmsRepository.save(this.SmsRepository.create(dto));
        return result;
    }
    async delete_sms(sms_id) {
        try {
            this.logger.log(`Deleting sms with sms_id: ${sms_id}`);
            const constsms = await this.get_sms(sms_id);
            if (!constsms) {
                throw new common_1.NotFoundException(`sms_id with sms_id ${sms_id} not found`);
            }
            var criteria = { sms_id: sms_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const result = await this.SmsRepository.delete(criteria);
            console.log(`result:`, result);
        }
        catch (error) {
            this.logger.error(`Error while deleting sms_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_sms(sms_id) {
        try {
            const rs = await this.SmsRepository.findOne({
                where: {
                    sms_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_sms_status(sms_id, status) {
        console.log(`Updating devices with bucket '${sms_id}' to status ${status}`);
        try {
            if (status == 1) {
                var DataUpdate = {};
                var DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
                var updateddate = moment(new Date(), DATE_TIME_FORMAT);
                var statusset = '0';
                DataUpdate.status = statusset;
                DataUpdate.updateddate = Date();
                console.log('update DataUpdate');
                console.info(DataUpdate);
                await this.HostRepository.createQueryBuilder()
                    .update('sd_iot_sms')
                    .set(DataUpdate)
                    .execute();
            }
            var updateResult = await this.SmsRepository.update({ sms_id: sms_id }, { status: status });
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for mqtt_id '${sms_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with bucket '${sms_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for sms_id '${sms_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for mqtt_id '${sms_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async get_name_create_sms(sms_name) {
        try {
            console.log('sms_name=>');
            console.info(sms_name);
            const rs = await this.SmsRepository.findOne({
                where: {
                    sms_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_sms(dto) {
        let sms_id = dto.sms_id;
        const DataUpdate = {};
        const query = await this.SmsRepository.createQueryBuilder('sms');
        query.select(['sms.sms_id AS sms_id']);
        query.where('1=1');
        query.andWhere('sms.sms_id=:sms_id', { sms_id: sms_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with sms_id ${sms_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found sms_idsms_id ${sms_id}.`,
                message_th: `ไม่พบข้อมูล sms_idsms_id ${sms_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.sms_name) {
            DataUpdate.sms_name = dto.sms_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.username) {
            DataUpdate.username = dto.username;
        }
        if (dto.password) {
            DataUpdate.password = dto.password;
        }
        if (dto.apikey) {
            DataUpdate.apikey = dto.apikey;
        }
        if (dto.originator) {
            DataUpdate.originator = dto.originator;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.SmsRepository.createQueryBuilder()
            .update('sd_iot_sms')
            .set(DataUpdate)
            .where('sms_id=:sms_id', { sms_id: sms_id })
            .execute();
        return 200;
    }
    async sms_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.SmsRepository.createQueryBuilder('sms');
            query.select(['sms.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async sms_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var sms_id = dto.sms_id;
            var sms_type_id = dto.sms_type_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.SmsRepository.createQueryBuilder('sms');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT sms.sms_id)', 'cnt');
            }
            else {
                query.select([
                    'sms.sms_id AS sms_id',
                    'sms.sms_name AS sms_name',
                    'sms.host AS host',
                    'sms.port AS port',
                    'sms.username AS username',
                    'sms.password AS password',
                    'sms.apikey AS apikey',
                    'sms.originator AS originator',
                    'sms.updateddate AS updateddate',
                    'sms.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('sms.sms_name like :sms_name', {
                    sms_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (sms_id) {
                query.andWhere('sms.sms_id=:sms_id', { sms_id: sms_id });
            }
            if (dto.host) {
                query.andWhere('sms.host=:host', { host: dto.host });
            }
            if (dto.port) {
                query.andWhere('sms.port=:port', { port: dto.port });
            }
            if (dto.username) {
                query.andWhere('sms.username=:username', { username: dto.username });
            }
            if (dto.password) {
                query.andWhere('sms.password=:password', { password: dto.password });
            }
            if (sms_id) {
                query.andWhere('sms.sms_id=:sms_id', { sms_id: sms_id });
            }
            if (dto.apikey) {
                query.andWhere('sms.apikey=:apikey', { apikey: dto.apikey });
            }
            if (dto.originator) {
                query.andWhere('sms.originator=:originator', {
                    originator: dto.originator,
                });
            }
            if (dto.updateddate) {
                query.andWhere('sms.updateddate=:updateddate', {
                    updateddate: dto.updateddate,
                });
            }
            if (dto.status) {
                query.andWhere('sms.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                query.orderBy(`sms.createddate`, 'DESC');
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Token() {
        try {
            const RS = await this.TokenRepository.query('SELECT MAX(token_id) AS token_id FROM sd_iot_token');
            console.log('token_id');
            console.info(RS);
            var token_id = RS['0'].token_id;
            console.log('max_token_id=');
            console.info(token_id);
            var max_token_id = max_token_id + 1;
            console.log('max_token_id=');
            console.info(max_token_id);
            return max_token_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_token(dto) {
        console.log('create_token=>');
        console.info(dto);
        const result = await this.TokenRepository.save(this.TokenRepository.create(dto));
        return result;
    }
    async delete_token(token_id) {
        try {
            this.logger.log(`Deleting sms with token_id: ${token_id}`);
            const constsms = await this.get_token(token_id);
            if (!constsms) {
                throw new common_1.NotFoundException(`token_id with token_id ${token_id} not found`);
            }
            var criteria = { token_id: token_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const result = await this.TokenRepository.delete(criteria);
            console.log(`result:`, result);
        }
        catch (error) {
            this.logger.error(`Error while deleting token_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_token(token_id) {
        try {
            const rs = await this.TokenRepository.findOne({
                where: {
                    token_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_token(token_name) {
        try {
            console.log('token_name=>');
            console.info(token_name);
            const rs = await this.TokenRepository.findOne({
                where: {
                    token_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_token(dto) {
        let token_id = dto.token_id;
        const DataUpdate = {};
        const query = await this.TokenRepository.createQueryBuilder('sms');
        query.select(['sms.token_id AS token_id']);
        query.where('1=1');
        query.andWhere('sms.token_id=:token_id', { token_id: token_id });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with token_id ${token_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found token_idtoken_id ${token_id}.`,
                message_th: `ไม่พบข้อมูล token_idtoken_id ${token_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.token_name) {
            DataUpdate.token_name = dto.token_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.username) {
            DataUpdate.username = dto.username;
        }
        if (dto.password) {
            DataUpdate.password = dto.password;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.TokenRepository.createQueryBuilder()
            .update('sd_iot_token')
            .set(DataUpdate)
            .where('token_id=:token_id', { token_id: token_id })
            .execute();
        return 200;
    }
    async token_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.TokenRepository.createQueryBuilder('sms');
            query.select(['sms.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async token_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var token_id = dto.token_id;
            var token_type_id = dto.token_type_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.TokenRepository.createQueryBuilder('token');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT token.token_id)', 'cnt');
            }
            else {
                query.select([
                    'token.token_id AS token_id',
                    'token.token_name AS token_name',
                    'token.host AS host',
                    'token.port AS port',
                    'token.username AS username',
                    'token.password AS password',
                    'token.updateddate AS updateddate',
                    'token.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('token.token_name like :token_name', {
                    token_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (token_id) {
                query.andWhere('token.token_id=:token_id', { token_id: token_id });
            }
            if (dto.host) {
                query.andWhere('token.host=:host', { host: dto.host });
            }
            if (dto.port) {
                query.andWhere('token.port=:port', { port: dto.port });
            }
            if (dto.username) {
                query.andWhere('token.username=:username', { username: dto.username });
            }
            if (dto.password) {
                query.andWhere('token.password=:password', { password: dto.password });
            }
            if (dto.updateddate) {
                query.andWhere('token.updateddate=:updateddate', {
                    updateddate: dto.updateddate,
                });
            }
            if (dto.status) {
                query.andWhere('token.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`token.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`token.token_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_telegram() {
        try {
            const RS = await this.TelegramRepository.query('SELECT MAX(telegram_id) AS telegram_id FROM sd_iot_telegram');
            console.log('telegram_id');
            console.info(RS);
            var telegram_id = RS['0'].telegram_id;
            console.log('max_telegram_id=');
            console.info(telegram_id);
            var max_telegram_id = max_telegram_id + 1;
            console.log('max_telegram_id=');
            console.info(max_telegram_id);
            return max_telegram_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_telegram(dto) {
        console.log('create_Telegram=>');
        console.info(dto);
        const result = await this.TelegramRepository.save(this.TelegramRepository.create(dto));
        return result;
    }
    async delete_telegram(telegram_id) {
        try {
            this.logger.log(`Deleting Telegram with telegram_id: ${telegram_id}`);
            const constTelegram = await this.get_telegram(telegram_id);
            if (!constTelegram) {
                throw new common_1.NotFoundException(`telegram_id with telegram_id ${telegram_id} not found`);
            }
            var criteria = { telegram_id: telegram_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const result = await this.TelegramRepository.delete(criteria);
            console.log(`result:`, result);
        }
        catch (error) {
            this.logger.error(`Error while deleting telegram_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async get_telegram(telegram_id) {
        try {
            const rs = await this.TelegramRepository.findOne({
                where: {
                    telegram_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_telegram(telegram_name) {
        try {
            console.log('telegram_name=>');
            console.info(telegram_name);
            const rs = await this.TelegramRepository.findOne({
                where: {
                    telegram_name,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_telegram(dto) {
        let telegram_id = dto.telegram_id;
        const DataUpdate = {};
        const query = await this.TelegramRepository.createQueryBuilder('Telegram');
        query.select(['Telegram.telegram_id AS telegram_id']);
        query.where('1=1');
        query.andWhere('Telegram.telegram_id=:telegram_id', {
            telegram_id: telegram_id,
        });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with telegram_id ${telegram_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found telegram_idtelegram_id ${telegram_id}.`,
                message_th: `ไม่พบข้อมูล telegram_idtelegram_id ${telegram_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.telegram_name) {
            DataUpdate.telegram_name = dto.telegram_name;
        }
        if (dto.host) {
            DataUpdate.host = dto.host;
        }
        if (dto.port) {
            DataUpdate.port = dto.port;
        }
        if (dto.username) {
            DataUpdate.username = dto.username;
        }
        if (dto.password) {
            DataUpdate.password = dto.password;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        console.log('update DataUpdate');
        console.info(DataUpdate);
        await this.TelegramRepository.createQueryBuilder()
            .update('sd_iot_telegram')
            .set(DataUpdate)
            .where('telegram_id=:telegram_id', { telegram_id: telegram_id })
            .execute();
        return 200;
    }
    async telegram_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.TelegramRepository.createQueryBuilder('Telegram');
            query.select(['Telegram.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async telegram_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var telegram_id = dto.telegram_id;
            var telegram_type_id = dto.telegram_type_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.TelegramRepository.createQueryBuilder('Telegram');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT Telegram.telegram_id)', 'cnt');
            }
            else {
                query.select([
                    'Telegram.telegram_id AS telegram_id',
                    'Telegram.telegram_name AS telegram_name',
                    'Telegram.host AS host',
                    'Telegram.port AS port',
                    'Telegram.username AS username',
                    'Telegram.password AS password',
                    'Telegram.updateddate AS updateddate',
                    'Telegram.status AS status',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('Telegram.telegram_name like :telegram_name', {
                    telegram_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (telegram_id) {
                query.andWhere('Telegram.telegram_id=:telegram_id', {
                    telegram_id: telegram_id,
                });
            }
            if (dto.host) {
                query.andWhere('Telegram.host=:host', { host: dto.host });
            }
            if (dto.port) {
                query.andWhere('Telegram.port=:port', { port: dto.port });
            }
            if (dto.username) {
                query.andWhere('Telegram.username=:username', {
                    username: dto.username,
                });
            }
            if (dto.password) {
                query.andWhere('Telegram.password=:password', {
                    password: dto.password,
                });
            }
            if (dto.updateddate) {
                query.andWhere('Telegram.updateddate=:updateddate', {
                    updateddate: dto.updateddate,
                });
            }
            if (dto.status) {
                query.andWhere('Telegram.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`Telegram.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`Telegram.telegram_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_Deviceactionlog() {
        try {
            const RS = await this.DeviceactionlogRepository.query('SELECT MAX(log_id) AS log_id FROM sd_iot_device_action_log');
            console.log('log_id');
            console.info(RS);
            var log_id = RS['0'].log_id;
            console.log('max_log_id=');
            console.info(log_id);
            var max_log_id = max_log_id + 1;
            console.log('max_log_id=');
            console.info(max_log_id);
            return max_log_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_deviceactionuserlog(dto) {
        console.log('create_deviceactionuserlog=>');
        console.info(dto);
        const result = await this.DeviceactionlogRepository.save(this.DeviceactionlogRepository.create(dto));
        return result;
    }
    async delete_deviceactionuserlog(log_id) {
        try {
            this.logger.log(`Deleting log with log_id: ${log_id}`);
            const constlog = await this.get_deviceactionuserlog(log_id);
            if (!constlog) {
                throw new common_1.NotFoundException(`log_id with log_id ${log_id} not found`);
            }
            var criteria = { log_id: log_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const result = await this.DeviceactionlogRepository.delete(criteria);
            console.log(`result:`, result);
        }
        catch (error) {
            this.logger.error(`Error while deleting log_id = ${error}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async deleteAlarmuserlog(dto) {
        const query = await this.DeviceactionlogRepository.createQueryBuilder('log');
        var countRs = await query.select('COUNT(DISTINCT log.*)', 'cnt');
        if (dto.alarm_action_id) {
            query.andWhere('log.alarm_action_id=:alarm_action_id', {
                alarm_action_id: dto.alarm_action_id,
            });
        }
        if (dto.device_id) {
            query.andWhere('log.device_id=:device_id', { device_id: dto.device_id });
        }
        if (dto.uid) {
            query.andWhere('log.uid=:uid', { uid: dto.uid });
        }
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        let tempCounts = {};
        tempCounts.count = countRs;
        console.log(`count =>` + count);
        console.log(`tempCountt.count =>` + tempCounts.count);
        if (tempCounts.count == 0) {
            return tempCounts.count;
        }
        else if (count == 0) {
            return count;
        }
        var result = await this.DeviceactionlogRepository.delete({
            alarm_action_id: dto.alarm_action_id,
            device_id: dto.device_id,
            uid: dto.uid,
        });
        if (result.affected == 0) {
            throw new common_1.NotFoundException('No alarm record found matching the criteria.');
        }
        return result;
    }
    async get_deviceactionuserlog(log_id) {
        try {
            const rs = await this.DeviceactionlogRepository.findOne({
                where: {
                    log_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_name_create_deviceactionuserlog(alarm_action_id) {
        try {
            console.log('alarm_action_id=>');
            console.info(alarm_action_id);
            const rs = await this.DeviceactionlogRepository.findOne({
                where: {
                    alarm_action_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async deviceactionuserlog_all() {
        console.log(`=group_all=`);
        try {
            const query = await this.DeviceactionlogRepository.createQueryBuilder('log');
            query.select(['log.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async deviceactionuserlog_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var log_id = dto.log_id;
            var device_id = dto.device_id;
            var uid = dto.uid || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceactionlogRepository.createQueryBuilder('log');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT log.log_id)', 'cnt');
            }
            else {
                query.select([
                    'log.log_id AS log_id',
                    'log.alarm_action_id AS alarm_action_id',
                    'log.device_id AS device_id',
                    'log.uid AS uid',
                    'log.createddate AS createddate',
                    'log.status AS status',
                ]);
            }
            if (log_id) {
                query.andWhere('log.log_id=:log_id', { log_id: log_id });
            }
            if (dto.device_id) {
                query.andWhere('log.device_id=:device_id', {
                    device_id: dto.device_id,
                });
            }
            if (dto.uid) {
                query.andWhere('log.uid=:uid', { uid: dto.uid });
            }
            if (dto.createddate) {
                query.andWhere('log.createddate=:createddate', {
                    createddate: dto.createddate,
                });
            }
            if (dto.status) {
                query.andWhere('log.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`log.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`log.log_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async maxid_alarmDevice() {
        try {
            const RS = await this.alarmDeviceRepository.query('SELECT MAX(id) AS id FROM sd_iot_alarm_device');
            console.log('id');
            console.info(RS);
            var id = RS['0'].id;
            console.log('max_id=');
            console.info(id);
            var max_id = max_id + 1;
            console.log('max_id=');
            console.info(max_id);
            return max_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async alarm_device_alarm_all() {
        console.log(`=alarmDevice=`);
        try {
            const query = await this.alarmDeviceRepository.createQueryBuilder('al');
            query.select(['al.*']);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async update_alarm_device_alarm(dto) {
        let alarm_action_id = dto.alarm_action_id;
        const DataUpdate = {};
        const query = await this.alarmDeviceRepository.createQueryBuilder('al');
        query.select(['al.alarm_action_id AS alarm_action_id']);
        query.where('1=1');
        query.andWhere('al.alarm_action_id=:alarm_action_id', {
            alarm_action_id: alarm_action_id,
        });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with alarm_action_id ${alarm_action_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found alarm_action_id ${alarm_action_id}.`,
                message_th: `ไม่พบข้อมูล alarm_action_id ${alarm_action_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.alarm_action_id) {
            DataUpdate.alarm_action_id = dto.alarm_action_id;
        }
        if (dto.device_id) {
            DataUpdate.device_id = dto.device_id;
        }
        if (dto.action_name) {
            DataUpdate.action_name = dto.action_name;
        }
        if (dto.event) {
            DataUpdate.event = dto.event;
        }
        if (dto.status_warning) {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.recovery_warning) {
            DataUpdate.recovery_warning = dto.recovery_warning;
        }
        if (dto.status_alert) {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.recovery_alert) {
            DataUpdate.recovery_alert = dto.recovery_alert;
        }
        if (dto.email_alarm) {
            DataUpdate.email_alarm = dto.email_alarm;
        }
        if (dto.line_alarm) {
            DataUpdate.line_alarm = dto.line_alarm;
        }
        if (dto.telegram_alarm) {
            DataUpdate.telegram_alarm = dto.telegram_alarm;
        }
        if (dto.sms_alarm) {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.nonc_alarm) {
            DataUpdate.nonc_alarm = dto.nonc_alarm;
        }
        if (dto.time_life) {
            DataUpdate.time_life = dto.time_life;
        }
        if (dto.status) {
            DataUpdate.status = dto.status;
        }
        await this.alarmDeviceRepository
            .createQueryBuilder()
            .update('sd_iot_sensor')
            .set(DataUpdate)
            .where('alarm_action_id=:alarm_action_id', {
            alarm_action_id: alarm_action_id,
        })
            .execute();
        return 200;
    }
    async create_alarm_device(dto) {
        console.log('create_alarmdevice=>');
        console.info(dto);
        var result = await this.alarmDeviceRepository.save(this.alarmDeviceRepository.create(dto));
        return result;
    }
    async get_alarm_device_alarm_action_id(alarm_action_id) {
        try {
            var alarmdevice = await this.alarmDeviceRepository.findOne({
                where: { alarm_action_id },
            });
            return alarmdevice || null;
        }
        catch (err) {
            this.logger.error(`Error fetching alarm_action_id ${alarm_action_id}: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async delete_alarm_device_alarm_action_id_get(alarm_action_id) {
        try {
            this.logger.log(`Deleting alarmdevice with alarm_action_id: ${alarm_action_id}`);
            const query = await this.alarmDeviceRepository.createQueryBuilder('al');
            var countRs = await query.select('COUNT(DISTINCT al.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.andWhere('al.alarm_action_id=:alarm_action_id', {
                alarm_action_id: alarm_action_id,
            });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = { alarm_action_id: alarm_action_id };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmDeviceRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
            }
            const result = await this.alarmDeviceRepository.delete(alarm_action_id);
            if (result.affected == 0) {
                throw new common_1.NotFoundException(`Schedule with alarm_action_id ${alarm_action_id} not found`);
            }
            this.logger.log(`Successfully deleted alarm_action_id: ${alarm_action_id}`);
        }
        catch (error) {
            this.logger.error(`Error while deleting alarm_action_id: ${alarm_action_id} - ${error.message}`);
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async delete_alarm_device_id_alarm_get(device_id) {
        try {
            this.logger.log(`Deleting alarmdevice with alarm_action_id: ${device_id}`);
            const query = await this.alarmDeviceRepository.createQueryBuilder('al');
            var countRs = await query.select('COUNT(DISTINCT al.device_id)', 'cnt');
            query.where('1=1');
            query.andWhere('al.device_id=:device_id', { device_id: device_id });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = { device_id: device_id };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmDeviceRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
            }
            var criteria = { device_id: device_id };
            console.log(`Attempting to delete record with criteria:`, criteria);
            const result = await this.alarmDeviceRepository.delete(criteria);
            console.log(`result:`, result);
            if (result.affected == 0) {
                throw new common_1.NotFoundException(`Schedule with device_id ${device_id} not found`);
            }
            this.logger.log(`Successfully deleted device_id: ${device_id}`);
        }
        catch (error) {
            this.logger.error(`Error while deleting device_id: ${device_id} - ${error.message}`);
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: error.message,
                },
            });
        }
    }
    async alarm_device_id_alarm_delete(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            const query = await this.DevicealarmactionRepository.createQueryBuilder('al');
            var countRs = await query.select('COUNT(DISTINCT al.device_id)', 'cnt');
            query.where('1=1');
            if (alarm_action_id) {
                query.andWhere('al.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('al.device_id=:device_id', { device_id: device_id });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                if (alarm_action_id) {
                    const criteria = { alarm_action_id: alarm_action_id };
                    console.log(`Attempting to delete record with criteria:`, criteria);
                    const deleteResult = await this.DevicealarmactionRepository.delete(criteria);
                    var criteria1 = { alarm_action_id: alarm_action_id };
                    console.log(`Attempting to delete record with criteria1:`, criteria1);
                    const deleteResults = await this.alarmDeviceRepository.delete(criteria1);
                    console.log(`deleteResults:`, deleteResults);
                    const deleteResults2 = await this.alarmDeviceEventRepository.delete(criteria1);
                    console.log(`deleteResults2:`, deleteResults2);
                    if (deleteResult.affected && deleteResult.affected > 0) {
                        console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                    }
                    else {
                        console.log('No records found matching the criteria. Nothing was deleted.');
                    }
                }
                if (device_id) {
                    const criteria = { device_id: device_id };
                    console.log(`Attempting to delete record with criteria:`, criteria);
                    const deleteResult = await this.alarmDeviceRepository.delete(criteria);
                    if (deleteResult.affected && deleteResult.affected > 0) {
                        console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                    }
                    else {
                        console.log('No records found matching the criteria. Nothing was deleted.');
                    }
                }
            }
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_device_id_alarm_deletev2(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            const query = await this.alarmDeviceRepository.createQueryBuilder('al');
            var countRs = await query.select('COUNT(DISTINCT al.device_id)', 'cnt');
            query.where('1=1');
            if (alarm_action_id) {
                query.andWhere('al.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('al.device_id=:device_id', { device_id: device_id });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                if (alarm_action_id) {
                    const criteria = { alarm_action_id: alarm_action_id };
                    console.log(`Attempting to delete record with criteria:`, criteria);
                    const deleteResult = await this.alarmDeviceRepository.delete(criteria);
                    await this.DevicealarmactionRepository.delete(criteria);
                    if (deleteResult.affected && deleteResult.affected > 0) {
                        console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                    }
                    else {
                        console.log('No records found matching the criteria. Nothing was deleted.');
                    }
                }
                if (device_id) {
                    const criteria = { device_id: device_id };
                    console.log(`Attempting to delete record with criteria:`, criteria);
                    const deleteResult = await this.alarmDeviceRepository.delete(criteria);
                    if (deleteResult.affected && deleteResult.affected > 0) {
                        console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                    }
                    else {
                        console.log('No records found matching the criteria. Nothing was deleted.');
                    }
                }
            }
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_device_id_alarm_count(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var alarm_action_id = dto.alarm_action_id;
            var device_id = dto.device_id;
            const query = await this.alarmDeviceRepository.createQueryBuilder('al');
            var countRs = await query.select('COUNT(DISTINCT al.device_id)', 'cnt');
            query.where('1=1');
            if (alarm_action_id) {
                query.andWhere('al.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('al.device_id=:device_id', { device_id: device_id });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_device_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var alarm_action_id = dto.alarm_action_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DevicealarmactionRepository.createQueryBuilder('al');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT al.alarm_action_id)', 'cnt');
            }
            else {
                query.select(['al.*']);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('al.action_name like :action_name', {
                    action_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.event) {
                query.andWhere('al.event=:event', { event: dto.event });
            }
            if (status) {
                query.andWhere('al.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`al.alarm_action_id.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`al.alarm_action_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_device_paginate_status(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var alarm_action_id = dto.alarm_action_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DevicealarmactionRepository.createQueryBuilder('al');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT al.alarm_action_id)', 'cnt');
            }
            else {
                query.select(['al.*']);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('al.action_name like :action_name', {
                    action_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.event) {
                query.andWhere('al.event=:event', { event: dto.event });
            }
            var status = 1;
            query.andWhere('al.status=:status', { status: status });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`al.alarm_action_id.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`al.alarm_action_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async get_alarm_device_map(alarm_action_id) {
        try {
            const rs = await this.alarmDeviceRepository.findOne({
                where: { alarm_action_id },
            });
            return rs || null;
        }
        catch (err) {
            this.logger.error(`Error fetching alarm_action_id ${alarm_action_id}: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async get_alarm_device(alarm_action_id) {
        try {
            const schedule = await this.DevicealarmactionRepository.findOne({
                where: { alarm_action_id },
            });
            return schedule || null;
        }
        catch (err) {
            this.logger.error(`Error fetching alarm_action_id ${alarm_action_id}: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async update_alarm_device_status_val(alarm_action_id, dto) {
        try {
            console.log(`Updating devices with alarm_action_id '${alarm_action_id}'`);
            console.log(`dto:`, dto);
            const DataUpdate = {};
            const valdata1 = [
                'status_warning',
                'recovery_warning',
                'status_alert',
                'recovery_alert',
                'email_alarm',
                'line_alarm',
                'telegram_alarm',
                'sms_alarm',
                'nonc_alarm',
                'event',
                'status',
            ];
            const valdata = [
                'action_name',
                'status_warning',
                'recovery_warning',
                'status_alert',
                'recovery_alert',
                'email_alarm',
                'line_alarm',
                'telegram_alarm',
                'sms_alarm',
                'nonc_alarm',
                'time_life',
                'event',
                'status',
            ];
            for (const da of valdata) {
                if (dto[da] !== undefined && dto[da] !== '') {
                    DataUpdate[da] = dto[da];
                }
            }
            if (Object.keys(DataUpdate).length == 0) {
                this.logger.warn(`No valid fields to update for alarm_action_id '${alarm_action_id}'.`);
                throw new common_1.UnprocessableEntityException('No valid fields to update.');
            }
            const updateResult = await this.scheduleDeviceRepository
                .createQueryBuilder()
                .update('sd_iot_device_alarm_action')
                .set(DataUpdate)
                .where('alarm_action_id=:alarm_action_id', { alarm_action_id })
                .execute();
            if (updateResult.affected == 0) {
                this.logger.warn(`No devices found for alarm_action_id '${alarm_action_id}'. Update failed.`);
                throw new common_1.NotFoundException(`No devices found with alarm_action_id '${alarm_action_id}'`);
            }
            this.logger.log(`${updateResult.affected} device(s) updated successfully for alarm_action_id '${alarm_action_id}'.`);
            return updateResult.affected;
        }
        catch (err) {
            if (err instanceof common_1.NotFoundException) {
                throw err;
            }
            this.logger.error(`Failed to update device status for schedule_id '${alarm_action_id}'. Error: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException('An unexpected error occurred while updating status.');
        }
    }
    async update_alarm_device(dto) {
        var alarm_action_id = dto.alarm_action_id;
        var DataUpdate = {};
        var query = await this.DevicealarmactionRepository.createQueryBuilder('al');
        query.select(['al.alarm_action_id AS alarm_action_id']);
        query.where('1=1');
        query.andWhere('al.alarm_action_id=:alarm_action_id', {
            alarm_action_id: dto.alarm_action_id,
        });
        query.printSql();
        query.maxExecutionTime(10000);
        query.getSql();
        var count = await query.getCount();
        var dataRs = await query.getRawMany();
        if (!dataRs) {
            throw new common_1.NotFoundException(`Data with alarm_action_id ${alarm_action_id} not found`);
            var result = {
                statusCode: 200,
                code: 422,
                message: `Data not found alarm_action_id ${alarm_action_id}.`,
                message_th: `ไม่พบข้อมูล alarm_action_id ${alarm_action_id}.`,
                payload: null,
            };
            return result;
        }
        else {
        }
        if (dto.action_name != '') {
            DataUpdate.action_name = dto.action_name;
        }
        if (dto.status_warning != '') {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.recovery_warning != '') {
            DataUpdate.recovery_warning = dto.recovery_warning;
        }
        if (dto.status_alert != '') {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.recovery_alert != '') {
            DataUpdate.recovery_alert = dto.recovery_alert;
        }
        if (dto.email_alarm != '') {
            DataUpdate.email_alarm = dto.email_alarm;
        }
        if (dto.line_alarm != '') {
            DataUpdate.line_alarm = dto.line_alarm;
        }
        if (dto.telegram_alarm) {
            DataUpdate.telegram_alarm = dto.telegram_alarm;
        }
        if (dto.sms_alarm != '') {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.nonc_alarm != '') {
            DataUpdate.nonc_alarm = dto.nonc_alarm;
        }
        if (dto.time_life != '') {
            DataUpdate.time_life = dto.time_life;
        }
        if (dto.event != '') {
            DataUpdate.event = dto.event;
        }
        if (dto.status != '') {
            DataUpdate.status = dto.status;
        }
        await this.alarmDeviceRepository
            .createQueryBuilder()
            .update('sd_iot_device_alarm_action')
            .set(DataUpdate)
            .where('alarm_action_id=:alarm_action_id', {
            alarm_action_id: alarm_action_id,
        })
            .execute();
        return 200;
    }
    async create_alarmdevice(dto) {
        console.log('create dto=>');
        console.info(dto);
        const DataAdd = {};
        const valdata = [
            'action_name',
            'status_warning',
            'recovery_warning',
            'status_alert',
            'recovery_alert',
            'email_alarm',
            'line_alarm',
            'telegram_alarm',
            'sms_alarm',
            'nonc_alarm',
            'time_life',
            'event',
            'status',
        ];
        for (const da of valdata) {
            if (dto[da] !== undefined && dto[da] !== '') {
                DataAdd[da] = dto[da];
            }
        }
        DataAdd.status = 1;
        const result = await this.DevicealarmactionRepository.save(this.DevicealarmactionRepository.create(DataAdd));
        return result;
    }
    async device_alarm_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DevicealarmactionRepository.createQueryBuilder('alarm');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT alarm.alarm_action_id)', 'cnt');
            }
            else {
                query.select([
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                ]);
                query.leftJoin('sd_iot_alarm_device', 'al', 'al.alarm_action_id= alarm.alarm_action_id');
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('alarm.action_name like :action_name', {
                    action_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (dto.alarm_action_id) {
                query.andWhere('alarm.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.event) {
                query.andWhere('alarm.event=:event', { event: dto.event });
            }
            if (dto.status_warning) {
                query.andWhere('alarm.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('alarm.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('alarm.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('alarm.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.email_alarm) {
                query.andWhere('alarm.email_alarm=:email_alarm', {
                    email_alarm: dto.email_alarm,
                });
            }
            if (dto.line_alarm) {
                query.andWhere('alarm.line_alarm=:line_alarm', {
                    line_alarm: dto.line_alarm,
                });
            }
            if (dto.telegram_alarm) {
                query.andWhere('alarm.telegram_alarm=:telegram_alarm', {
                    telegram_alarm: dto.telegram_alarm,
                });
            }
            if (dto.sms_alarm) {
                query.andWhere('alarm.sms_alarm=:sms_alarm', {
                    sms_alarm: dto.sms_alarm,
                });
            }
            if (dto.nonc_alarm) {
                query.andWhere('alarm.nonc_alarm=:nonc_alarm', {
                    nonc_alarm: dto.nonc_alarm,
                });
            }
            if (dto.status) {
                query.andWhere('alarm.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`alarm.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`alarm.alarm_action_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_device_list_paginate_all_active(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var alarm_action_id = dto.alarm_action_id;
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'ad.alarm_action_id AS alarm_action_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                ]);
            }
            query.leftJoin('sd_iot_alarm_device', 'ad', 'ad.device_id= d.device_id');
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async device_alarm_event_list_paginate_active(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.ScheduleRepository.createQueryBuilder('alarm');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT alarm.alarm_action_id)', 'cnt');
            }
            else {
                query.select([
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                ]);
            }
            query.leftJoin('sd_iot_alarm_device_event', 'ev', 'ev.alarm_action_id= alarm.alarm_action_id');
            query.leftJoin('sd_iot_device', 'd', 'd.device_id= ev.device_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (dto.event) {
                query.andWhere('alarm.event=:event', { event: dto.event });
            }
            if (dto.status_warning) {
                query.andWhere('alarm.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('alarm.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('alarm.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('alarm.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.email_alarm) {
                query.andWhere('alarm.email_alarm=:email_alarm', {
                    email_alarm: dto.email_alarm,
                });
            }
            if (dto.line_alarm) {
                query.andWhere('alarm.line_alarm=:line_alarm', {
                    line_alarm: dto.line_alarm,
                });
            }
            if (dto.telegram_alarm) {
                query.andWhere('alarm.telegram_alarm=:telegram_alarm', {
                    telegram_alarm: dto.telegram_alarm,
                });
            }
            if (dto.sms_alarm) {
                query.andWhere('alarm.sms_alarm=:sms_alarm', {
                    sms_alarm: dto.sms_alarm,
                });
            }
            if (dto.nonc_alarm) {
                query.andWhere('alarm.nonc_alarm=:nonc_alarm', {
                    nonc_alarm: dto.nonc_alarm,
                });
            }
            if (dto.status) {
                query.andWhere('alarm.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`alarm.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`alarm.alarm_action_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_alarm_action_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.ScheduleRepository.createQueryBuilder('alarm');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT alarm.alarm_action_id)', 'cnt');
            }
            else {
                query.select([
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                ]);
            }
            query.leftJoin('sd_iot_alarm_device', 'ad', 'ad.alarm_action_id= alarm.alarm_action_id');
            query.leftJoin('sd_iot_device', 'd', 'd.device_id= ad.device_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('alarm.action_name like :action_name', {
                    action_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (dto.alarm_action_id) {
                query.andWhere('alarm.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.event) {
                query.andWhere('alarm.event=:event', { event: dto.event });
            }
            if (dto.status_warning) {
                query.andWhere('alarm.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('alarm.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('alarm.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('alarm.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.email_alarm) {
                query.andWhere('alarm.email_alarm=:email_alarm', {
                    email_alarm: dto.email_alarm,
                });
            }
            if (dto.line_alarm) {
                query.andWhere('alarm.line_alarm=:line_alarm', {
                    line_alarm: dto.line_alarm,
                });
            }
            if (dto.telegram_alarm) {
                query.andWhere('alarm.telegram_alarm=:telegram_alarm', {
                    telegram_alarm: dto.telegram_alarm,
                });
            }
            if (dto.sms_alarm) {
                query.andWhere('alarm.sms_alarm=:sms_alarm', {
                    sms_alarm: dto.sms_alarm,
                });
            }
            if (dto.nonc_alarm) {
                query.andWhere('alarm.nonc_alarm=:nonc_alarm', {
                    nonc_alarm: dto.nonc_alarm,
                });
            }
            if (dto.status) {
                query.andWhere('alarm.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`alarm.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`alarm.alarm_action_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_alarm_event_list_paginate(dto) {
        console.log(`type_list_paginate dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var keyword = dto.keyword || '';
            var status = dto.status;
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.ScheduleRepository.createQueryBuilder('alarm');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT alarm.alarm_action_id)', 'cnt');
            }
            else {
                query.select([
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                ]);
            }
            query.leftJoin('sd_iot_alarm_device_event', 'ev', 'ev.alarm_action_id= alarm.alarm_action_id');
            query.leftJoin('sd_iot_device', 'd', 'd.device_id= ev.device_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('alarm.action_name like :action_name', {
                    action_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (dto.alarm_action_id) {
                query.andWhere('alarm.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.event) {
                query.andWhere('alarm.event=:event', { event: dto.event });
            }
            if (dto.status_warning) {
                query.andWhere('alarm.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('alarm.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('alarm.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('alarm.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.email_alarm) {
                query.andWhere('alarm.email_alarm=:email_alarm', {
                    email_alarm: dto.email_alarm,
                });
            }
            if (dto.line_alarm) {
                query.andWhere('alarm.line_alarm=:line_alarm', {
                    line_alarm: dto.line_alarm,
                });
            }
            if (dto.telegram_alarm) {
                query.andWhere('alarm.telegram_alarm=:telegram_alarm', {
                    telegram_alarm: dto.telegram_alarm,
                });
            }
            if (dto.sms_alarm) {
                query.andWhere('alarm.sms_alarm=:sms_alarm', {
                    sms_alarm: dto.sms_alarm,
                });
            }
            if (dto.nonc_alarm) {
                query.andWhere('alarm.nonc_alarm=:nonc_alarm', {
                    nonc_alarm: dto.nonc_alarm,
                });
            }
            if (dto.status) {
                query.andWhere('alarm.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`alarm.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`alarm.alarm_action_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_device_id_event_count(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            const query = await this.alarmDeviceEventRepository.createQueryBuilder('al');
            var countRs = await query.select('COUNT(DISTINCT al.device_id)', 'cnt');
            query.where('1=1');
            if (alarm_action_id) {
                query.andWhere('al.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('al.device_id=:device_id', { device_id: device_id });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_device_id_event_rss(dto) {
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var bucket = dto.bucket;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.work_status AS work_status',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.bucket AS bucket',
                'd.updateddate AS timestamp',
                'd.mqtt_device_name AS mqtt_device_name',
                'alarm.*',
            ]);
            query.innerJoin('sd_iot_alarm_device_event', 'alarm', 'alarm.device_id= d.device_id');
            query.where('1=1');
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            if (bucket) {
                query.andWhere('d.bucket=:bucket', { bucket: bucket });
            }
            if (type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: type_id });
            }
            if (device_id) {
                query.andWhere('alarm.device_id != :device_id', { device_id });
            }
            if (alarm_action_id) {
                query.andWhere('alarm.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            const deviceList = await query.getRawMany();
            return deviceList;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async alarm_device_id_event_crt(dto) {
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var bucket = dto.bucket;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.work_status AS work_status',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.bucket AS bucket',
                'd.updateddate AS timestamp',
                'd.mqtt_device_name AS mqtt_device_name',
                'alarm.*',
            ]);
            query.innerJoin('sd_iot_alarm_device_event', 'alarm', 'alarm.device_id= d.device_id');
            query.where('1=1');
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            if (bucket) {
                query.andWhere('d.bucket=:bucket', { bucket: bucket });
            }
            if (type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: type_id });
            }
            if (device_id) {
                query.andWhere('alarm.device_id=:device_id', { device_id: device_id });
            }
            if (alarm_action_id) {
                query.andWhere('alarm.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            const deviceList = await query.getRawMany();
            return deviceList;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async alarm_device_id_event_rsss(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            const query = await this.alarmDeviceEventRepository.createQueryBuilder('al');
            query.select(['al.*, d.*']);
            query.innerJoin('sd_iot_device', 'd', 'al.device_id= d.device_id');
            var countRs = await query.select('al.*');
            query.where('1=1');
            if (alarm_action_id) {
                query.andWhere('al.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('al.device_id=:device_id', { device_id: device_id });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async get_alarm_device_event_map(alarm_action_id) {
        try {
            const schedule = await this.alarmDeviceEventRepository.findOne({
                where: { alarm_action_id },
            });
            return schedule || null;
        }
        catch (err) {
            this.logger.error(`Error fetching alarm_action_id ${alarm_action_id}: ${err.message}`, err.stack);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_alarm_device_map(dto) {
        console.log('create_nodered=>');
        console.info(dto);
        const result = await this.alarmDeviceRepository.save(this.alarmDeviceRepository.create(dto));
        return result;
    }
    async create_alarm_device_event_map(dto) {
        console.log('create_nodered=>');
        console.info(dto);
        const result = await this.alarmDeviceEventRepository.save(this.alarmDeviceEventRepository.create(dto));
        return result;
    }
    async delete_alarm_device_map(dto) {
        try {
            var device_id = dto.device_id || '';
            var alarm_action_id = dto.alarm_action_id || '';
            const query = await this.alarmDeviceRepository.createQueryBuilder('a');
            var countRs = await query.select('COUNT(DISTINCT a.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.andWhere('a.device_id=:device_id', { device_id: device_id });
            query.andWhere('a.alarm_action_id=:alarm_action_id', {
                alarm_action_id: alarm_action_id,
            });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = {
                    device_id: device_id,
                    alarm_action_id: alarm_action_id,
                };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmDeviceRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async delete_alarm_device_event_map(dto) {
        try {
            var device_id = dto.device_id || '';
            var alarm_action_id = dto.alarm_action_id || '';
            const query = await this.alarmDeviceEventRepository.createQueryBuilder('a');
            var countRs = await query.select('COUNT(DISTINCT a.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.andWhere('a.device_id=:device_id', { device_id: device_id });
            query.andWhere('a.alarm_action_id=:alarm_action_id', {
                alarm_action_id: alarm_action_id,
            });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = {
                    device_id: device_id,
                    alarm_action_id: alarm_action_id,
                };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmDeviceEventRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate_alarm_active(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                ]);
            }
            query.innerJoin('sd_iot_alarm_device', 'alarm', 'alarm.device_id= d.device_id');
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async device_event_list_paginate_alarm_active(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    'd.updateddate AS timestamp',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                ]);
            }
            query.innerJoin('sd_iot_alarm_device_event', 'alarm', 'alarm.device_id= d.device_id');
            query.leftJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name LIKE :keyword', {
                    keyword: `%${keyword}%`,
                });
            }
            var status = 1;
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: dto.mqtt_id });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                const deviceList = await query.getRawMany();
                return deviceList;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: { args: { errorMessage: error.message || error } },
            });
        }
    }
    async maxid_UID_scheduleprocesslog() {
        try {
            const RS = await this.scheduleprocesslogRepository.query('SELECT MAX(id) AS id FROM sd_schedule_process_log');
            console.log('id');
            console.info(RS);
            var id = RS['0'].id;
            console.log('max_id=');
            console.info(id);
            var max_id = max_id + 1;
            console.log('max_id=');
            console.info(max_id);
            return max_id;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async create_scheduleprocesslog(dto) {
        var schedule_id = dto.schedule_id;
        var device_id = dto.device_id;
        var schedule_event_start = dto.schedule_event_start;
        var day = dto.day;
        var dotime = dto.dotime;
        var schedule_event = dto.schedule_event;
        if (dto.device_status == 'undefined' || dto.device_status == '0') {
            dto.device_status = 0;
        }
        if (dto.status == 'undefined' || dto.status == '0') {
            var status = dto.status;
        }
        var date = dto.date;
        var time = dto.time;
        const chkset = {
            schedule_id: schedule_id,
            device_id: device_id,
            schedule_event_start: schedule_event_start,
            day: day,
            date: date,
        };
        let count_alarmprocesslog = await this.scheduleprocesslog_count(chkset);
        if (count_alarmprocesslog == 0) {
            if (dto.device_status == dto.schedule_event) {
                dto.status = 1;
            }
            else {
                dto.status = 0;
            }
            var createset = {
                schedule_id: schedule_id,
                device_id: device_id,
                schedule_event_start: schedule_event_start,
                day: dto.day,
                doday: dto.doday,
                dotime: dto.dotime,
                schedule_event: dto.schedule_event,
                device_status: dto.device_status,
                status: dto.status,
                date: dto.date,
                time: dto.time,
                createddate: Date(),
                updateddate: Date(),
            };
            await this.scheduleprocesslogRepository.save(this.scheduleprocesslogRepository.create(createset));
            var rss = 1;
            return rss;
        }
        else if (count_alarmprocesslog >= 1) {
            var DataUpdate = {};
            if (dto.day != '') {
                DataUpdate.day = dto.day;
            }
            if (dto.doday != '') {
                DataUpdate.doday = dto.doday;
            }
            if (dto.dotime != '') {
                DataUpdate.dotime = dto.dotime;
            }
            if (dto.time != '') {
                DataUpdate.time = dto.time;
            }
            if (dto.device_status) {
                DataUpdate.device_status = dto.device_status;
            }
            if (dto.status != '') {
                DataUpdate.status = dto.status;
            }
            DataUpdate.updateddate = Date();
            const query = await this.scheduleprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.schedule_id) {
                query.andWhere('l.schedule_id=:schedule_id', {
                    schedule_id: dto.schedule_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.schedule_event_start) {
                query.andWhere('l.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: dto.schedule_event_start,
                });
            }
            if (dto.schedule_event) {
                query.andWhere('l.schedule_event=:schedule_event', {
                    schedule_event: dto.schedule_event,
                });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            var result = await query.getRawMany();
            if (result) {
                var result_get = result['0'];
                var device_status = result_get.device_status;
                var status = result_get.status;
                if (device_status != null || device_status != '') {
                    if (dto.device_status == dto.schedule_event) {
                        DataUpdate.status = 1;
                    }
                    else {
                        DataUpdate.status = 0;
                    }
                    await this.scheduleprocesslogRepository
                        .createQueryBuilder()
                        .update('sd_schedule_process_log')
                        .set(DataUpdate)
                        .where('schedule_id=:schedule_id', { schedule_id: dto.schedule_id })
                        .andWhere('device_id=:device_id', { device_id: dto.device_id })
                        .andWhere('schedule_event_start=:schedule_event_start', {
                        schedule_event_start: dto.schedule_event_start,
                    })
                        .andWhere('schedule_event=:schedule_event', {
                        schedule_event: dto.schedule_event,
                    })
                        .andWhere('date=:date', { date: dto.date })
                        .execute();
                    var rs = 1;
                    return rs;
                }
            }
            var rs = 0;
            return rs;
        }
    }
    async update_scheduleprocesslog(dto) {
        var id = dto.id;
        var DataUpdate = {};
        if (dto.schedule_id != '') {
            DataUpdate.schedule_id = dto.schedule_id;
        }
        if (dto.device_id != '') {
            DataUpdate.device_id = dto.device_id;
        }
        if (dto.schedule_event_start != '') {
            DataUpdate.schedule_event_start = dto.schedule_event_start;
        }
        if (dto.day != '') {
            DataUpdate.day = dto.day;
        }
        if (dto.doday != '') {
            DataUpdate.doday = dto.doday;
        }
        if (dto.dotime != '') {
            DataUpdate.dotime = dto.dotime;
        }
        if (dto.schedule_event != '') {
            DataUpdate.schedule_event = dto.schedule_event;
        }
        if (dto.device_status) {
            DataUpdate.device_status = dto.device_status;
        }
        if (dto.status != '') {
            DataUpdate.status = dto.status;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        await this.alarmDeviceRepository
            .createQueryBuilder()
            .update('sd_schedule_process_log')
            .set(DataUpdate)
            .where('id=:id', { id: id })
            .execute();
        return 200;
    }
    async update_scheduleprocesslog_v2(dto) {
        var id = dto.id;
        var DataUpdate = {};
        if (dto.day != '') {
            DataUpdate.day = dto.day;
        }
        if (dto.doday != '') {
            DataUpdate.doday = dto.doday;
        }
        if (dto.dotime != '') {
            DataUpdate.dotime = dto.dotime;
        }
        if (dto.time != '') {
            DataUpdate.time = dto.time;
        }
        if (dto.device_status) {
            DataUpdate.device_status = dto.device_status;
        }
        if (dto.device_status == dto.schedule_event) {
            DataUpdate.status = 1;
        }
        else {
            DataUpdate.status = 0;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        await this.alarmDeviceRepository
            .createQueryBuilder()
            .update('sd_schedule_process_log')
            .set(DataUpdate)
            .where('schedule_id=:schedule_id', { schedule_id: dto.schedule_id })
            .andWhere('device_id=:device_id', { device_id: dto.device_id })
            .andWhere('schedule_event_start=:schedule_event_start', {
            schedule_event_start: dto.schedule_event_start,
        })
            .andWhere('schedule_event=:schedule_event', {
            schedule_event: dto.schedule_event,
        })
            .andWhere('date=:date', { date: dto.date })
            .execute();
        return 200;
    }
    async scheduleprocesslog_count_status(dto) {
        console.log(`scheduleprocesslog_count_status_dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            const query = await this.scheduleprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (schedule_id) {
                query.andWhere('l.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            if (device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: device_id });
            }
            if (schedule_event_start) {
                query.andWhere('l.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: schedule_event_start,
                });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.schedule_event) {
                query.andWhere('l.schedule_event=:schedule_event', {
                    schedule_event: dto.schedule_event,
                });
            }
            var status = 1;
            query.andWhere('l.status=:status', { status: status });
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async scheduleprocesslog_count(dto) {
        console.log(`scheduleprocesslog_count_dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            const query = await this.scheduleprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (schedule_id) {
                query.andWhere('l.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            if (device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: device_id });
            }
            if (schedule_event_start) {
                query.andWhere('l.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: schedule_event_start,
                });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.schedule_event) {
                query.andWhere('l.schedule_event=:schedule_event', {
                    schedule_event: dto.schedule_event,
                });
            }
            if (dto.device_status) {
                query.andWhere('l.device_status=:device_status', {
                    device_status: dto.device_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async scheduleprocesslog_count_v2(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            const query = await this.scheduleprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (schedule_id) {
                query.andWhere('l.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            if (device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: device_id });
            }
            if (schedule_event_start) {
                query.andWhere('l.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: schedule_event_start,
                });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { date: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async scheduleprocesslog_rs(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            var status = dto.status;
            const query = await this.scheduleprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (schedule_id) {
                query.andWhere('l.schedule_id=:schedule_id', {
                    schedule_id: schedule_id,
                });
            }
            if (device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: device_id });
            }
            if (schedule_event_start) {
                query.andWhere('l.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: schedule_event_start,
                });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            const rss = await query.getRawMany();
            return rss;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async scheduleprocesslog_paginate(dto) {
        console.log(`dto=>`);
        console.info(dto);
        try {
            var keyword = dto.keyword || '';
            var status = dto.status;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.scheduleprocesslogRepository.createQueryBuilder('sl');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT sl.device_id)', 'cnt');
            }
            else {
                query.select([
                    'sl.id AS id',
                    'sl.schedule_id AS schedule_id',
                    'sl.schedule_event_start AS schedule_event_start',
                    'sl.day AS day',
                    'sl.doday AS doday',
                    'sl.dotime AS dotime',
                    'sl.schedule_event AS schedule_event',
                    'sl.device_status AS device_status',
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                ]);
            }
            query.leftJoin('sd_iot_device', 'd', 'd.device_id= sl.device_id');
            query.leftJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.leftJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.leftJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.device_name like :device_name', {
                    device_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.schedule_id) {
                query.andWhere('l.schedule_id=:schedule_id', {
                    schedule_id: dto.schedule_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.schedule_event_start) {
                query.andWhere('l.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: dto.schedule_event_start,
                });
            }
            if (dto.day) {
                query.andWhere('l.day=:day', { day: dto.day });
            }
            if (dto.doday) {
                query.andWhere('l.doday=:doday', { doday: dto.doday });
            }
            if (dto.dotime) {
                query.andWhere('l.dotime=:dotime', { dotime: dto.dotime });
            }
            if (dto.schedule_event) {
                query.andWhere('l.schedule_event=:schedule_event', {
                    schedule_event: dto.schedule_event,
                });
            }
            if (dto.device_status) {
                query.andWhere('l.device_status=:device_status', {
                    device_status: dto.device_status,
                });
            }
            if (status) {
                query.andWhere('l.status=:status', { status: status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`alarm.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`alarm.alarm_action_id`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async scheduleprocesslogpaginate(dto) {
        console.log(`dto=>`);
        console.info(dto);
        try {
            var bucket = dto.bucket || '';
            var keyword = dto.keyword || '';
            var event = dto.event || '';
            var status = dto.status;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.scheduleprocesslogRepository.createQueryBuilder('sl');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT sl.id)', 'cnt');
            }
            else {
                query.select([
                    'sl.id AS id',
                    'd.device_id AS device_id',
                    'd.bucket AS bucket',
                    'sdd.schedule_id AS schedule_id',
                    'sl.schedule_event_start AS schedule_event_start',
                    'sl.day AS day',
                    'sl.doday AS doday',
                    'sl.dotime AS dotime',
                    'sl.schedule_event AS schedule_event',
                    'sl.device_status AS device_status',
                    'sl.status AS status',
                    'sl.date AS date',
                    'sl.time AS time',
                    'sl.createddate AS createddate',
                    'sl.updateddate AS updateddate',
                    'd.device_id AS deviceid',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'sdc.schedule_name AS schedule_name',
                    'sdc.event AS event',
                ]);
            }
            query.innerJoin('sd_iot_schedule_device', 'sdd', 'sdd.schedule_id= sl.schedule_id  and sdd.device_id = sl.device_id');
            query.innerJoin('sd_iot_schedule', 'sdc', 'sdc.schedule_id= sdd.schedule_id');
            query.innerJoin('sd_iot_device', 'd', 'd.device_id= sdd.device_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('sdc.schedule_name like :schedule_name', {
                    schedule_name: keyword ? `%${keyword}%` : '%',
                });
            }
            if (dto.event) {
                query.andWhere('sdc.event=:event', { event: dto.event });
            }
            if (dto.schedule_id) {
                query.andWhere('sdc.schedule_id=:schedule_id', {
                    schedule_id: dto.schedule_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: dto.device_id });
            }
            if (status) {
                query.andWhere('sdc.status=:status', { status: status });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('l.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket=:bucket', { bucket: dto.bucket });
            }
            if (dto.start && dto.end) {
                query.andWhere('sl.createddate BETWEEN :startDate AND :endDate', {
                    startDate: dto.start,
                    endDate: dto.end,
                });
            }
            else if (dto.start) {
                query.andWhere('sl.createddate >= :startDate', {
                    startDate: dto.start,
                });
            }
            else if (dto.end) {
                query.andWhere('sl.createddate <= :endDate', { endDate: dto.end });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`sl.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`sl.date`, 'DESC');
                    query.addOrderBy('sl.time', 'DESC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate_active_alarm_device(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var type_id = dto.type_id;
            var location_id = dto.location_id;
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'sad.alarm_action_id AS alarm_action_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS time_life',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                ]);
            }
            query.innerJoin('sd_iot_alarm_device', 'sad', 'sad.device_id= d.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= sad.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.keyword LIKE :keyword', { keyword: `%${keyword}%` });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            query.andWhere('alarm.status=:status', { status: status });
            if (alarm_action_id) {
                query.andWhere('sad.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate_alarm_device_event(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT d.device_id)', 'cnt');
            }
            else {
                query.select([
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'sad.alarm_action_id AS alarm_action_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS timelife',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                ]);
            }
            query.innerJoin('sd_iot_alarm_device_event', 'sad', 'sad.device_id= d.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= sad.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.keyword LIKE :keyword', { keyword: `%${keyword}%` });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            query.andWhere('alarm.status=:status', { status: status });
            if (alarm_action_id) {
                query.andWhere('sad.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCountt.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`d.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy('mq.sort', 'ASC');
                    query.addOrderBy('d.device_id', 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async sd_iot_alarm_device_list(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'sad.alarm_action_id AS alarm_action_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.sn AS sn',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS timelife',
                'd.period AS period',
                'd.work_status AS work_status',
                'd.*',
                'd.oid AS oid',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.status AS status',
                'd.unit AS unit',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.org AS device_org',
                'd.bucket AS device_bucket',
                't.type_name AS type_name',
                'l.location_name AS location_name',
                'l.configdata AS configdata',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'mq.host AS mqtt_host',
                'mq.port AS mqtt_port',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                'alarm.alarm_action_id AS alarm_action_id',
                'alarm.action_name AS action_name',
                'alarm.status_warning AS status_warning',
                'alarm.recovery_warning AS recovery_warning',
                'alarm.status_alert AS status_alert',
                'alarm.recovery_alert AS recovery_alert',
                'alarm.email_alarm AS email_alarm',
                'alarm.line_alarm AS line_alarm',
                'alarm.telegram_alarm AS telegram_alarm',
                'alarm.sms_alarm AS sms_alarm',
                'alarm.nonc_alarm AS nonc_alarm',
                'alarm.time_life AS time_life',
                'alarm.event AS event',
                'alarm.status AS status',
            ]);
            query.innerJoin('sd_iot_alarm_device', 'sad', 'sad.device_id= d.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= sad.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.keyword LIKE :keyword', { keyword: `%${keyword}%` });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            query.andWhere('alarm.status=:status', { status: status });
            if (alarm_action_id) {
                query.andWhere('sad.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy('mq.sort', 'ASC');
            query.addOrderBy('d.device_id', 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async sd_iot_alarm_device_event_list(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'sad.alarm_action_id AS alarm_action_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.sn AS sn',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS timelife',
                'd.period AS period',
                'd.work_status AS work_status',
                'd.*',
                'd.oid AS oid',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.status AS status',
                'd.unit AS unit',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.org AS device_org',
                'd.bucket AS device_bucket',
                't.type_name AS type_name',
                'l.location_name AS location_name',
                'l.configdata AS configdata',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'mq.host AS mqtt_host',
                'mq.port AS mqtt_port',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                'alarm.alarm_action_id AS alarm_action_id',
                'alarm.action_name AS action_name',
                'alarm.status_warning AS status_warning',
                'alarm.recovery_warning AS recovery_warning',
                'alarm.status_alert AS status_alert',
                'alarm.recovery_alert AS recovery_alert',
                'alarm.email_alarm AS email_alarm',
                'alarm.line_alarm AS line_alarm',
                'alarm.telegram_alarm AS telegram_alarm',
                'alarm.sms_alarm AS sms_alarm',
                'alarm.nonc_alarm AS nonc_alarm',
                'alarm.time_life AS time_life',
                'alarm.event AS event',
                'alarm.status AS status',
            ]);
            query.innerJoin('sd_iot_alarm_device_event', 'sad', 'sad.device_id= d.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= sad.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.keyword LIKE :keyword', { keyword: `%${keyword}%` });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            query.andWhere('alarm.status=:status', { status: status });
            if (alarm_action_id) {
                query.andWhere('sad.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy('mq.sort', 'ASC');
            query.addOrderBy('d.device_id', 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async device_list_paginate_alarm_device_event_control(dto) {
        console.log(`device_list_paginate_alarm_device_event_control dto=`);
        console.info(dto);
        try {
            var type_id = dto.type_id;
            var location_id = dto.location_id;
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'sad.alarm_action_id AS alarm_action_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS time_life',
                'd.period AS period',
                'd.work_status AS work_status',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.model AS model',
                'd.vendor AS vendor',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.status AS status',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.org AS device_org',
                'd.bucket AS device_bucket',
                't.type_name AS type_name',
                'l.location_name AS location_name',
                'l.configdata AS configdata',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                'alarm.alarm_action_id AS alarm_action_id',
                'alarm.action_name AS action_name',
                'alarm.status_warning AS status_warning',
                'alarm.recovery_warning AS recovery_warning',
                'alarm.status_alert AS status_alert',
                'alarm.recovery_alert AS recovery_alert',
                'alarm.email_alarm AS email_alarm',
                'alarm.line_alarm AS line_alarm',
                'alarm.telegram_alarm AS telegram_alarm',
                'alarm.sms_alarm AS sms_alarm',
                'alarm.nonc_alarm AS nonc_alarm',
                'alarm.time_life AS time_life',
                'alarm.event AS event',
                'alarm.status AS status',
            ]);
            query.innerJoin('sd_iot_alarm_device', 'sad', 'sad.device_id= d.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= sad.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.keyword LIKE :keyword', { keyword: `%${keyword}%` });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            query.andWhere('alarm.status=:status', { status: status });
            if (alarm_action_id) {
                query.andWhere('sad.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy('mq.sort', 'ASC');
            query.addOrderBy('d.device_id', 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async create_alarmprocesslog(dto) {
        console.log('dto=>');
        console.info(dto);
        const result = await this.alarmprocesslogRepository.save(this.alarmprocesslogRepository.create(dto));
        return result;
    }
    async update_alarmprocesslog(dto) {
        var id = dto.id;
        var DataUpdate = {};
        if (dto.event != '') {
            DataUpdate.event = dto.event;
        }
        if (dto.alarm_type != '') {
            DataUpdate.alarm_type = dto.alarm_type;
        }
        if (dto.status_warning != '') {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.recovery_warning != '') {
            DataUpdate.recovery_warning = dto.recovery_warning;
        }
        if (dto.status_alert != '') {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.recovery_alert != '') {
            DataUpdate.recovery_alert = dto.recovery_alert;
        }
        if (dto.email_alarm != '') {
            DataUpdate.email_alarm = dto.email_alarm;
        }
        if (dto.line_alarm != '') {
            DataUpdate.line_alarm = dto.line_alarm;
        }
        if (dto.telegram_alarm != '') {
            DataUpdate.telegram_alarm = dto.telegram_alarm;
        }
        if (dto.sms_alarm != '') {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.nonc_alarm != '') {
            DataUpdate.nonc_alarm = dto.nonc_alarm;
        }
        if (dto.status != '') {
            DataUpdate.status = dto.status;
        }
        if (dto.time != '') {
            DataUpdate.time = dto.time;
        }
        if (dto.data != '') {
            DataUpdate.data = dto.data;
        }
        if (dto.alarm_status != '') {
            DataUpdate.alarm_status = dto.alarm_status;
        }
        if (dto.subject != '') {
            DataUpdate.subject = dto.subject;
        }
        if (dto.content != '') {
            DataUpdate.content = dto.content;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        await this.alarmprocesslogRepository
            .createQueryBuilder()
            .update('sd_alarm_process_log')
            .set(DataUpdate)
            .where('alarm_action_id=:alarm_action_id', {
            alarm_action_id: dto.alarm_action_id,
        })
            .andWhere('device_id =:device_id', { device_id: dto.device_id })
            .andWhere('type_id =:type_id', { type_id: dto.type_id })
            .andWhere('data_alarm =:data_alarm', { data_alarm: dto.data_alarm })
            .andWhere('date =:date', { date: dto.date })
            .execute();
        return 200;
    }
    async delete_alarmprocesslogal(dto) {
        try {
            console.log(`----delete_alarmprocesslog---`);
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            if (dto.id) {
                query.andWhere('l.id=:id', { id: dto.id });
            }
            if (device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: device_id });
            }
            if (alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: type_id });
            }
            if (date_now) {
                query.andWhere('l.date=:date', { date: date_now });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            }
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = {};
                criteria.alarm_action_id = alarm_action_id;
                if (dto.id) {
                    query.andWhere('l.id=:id', { id: dto.id });
                }
                if (device_id) {
                    criteria.device_id = device_id;
                }
                if (type_id) {
                    criteria.type_id = type_id;
                }
                if (alarm_status) {
                    criteria.alarm_status = alarm_status;
                }
                if (dto.event) {
                    criteria.event = dto.event;
                }
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                var rt = parseInt('1');
                return rt;
            }
            else {
                var rt = parseInt('0');
                return rt;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async delete_alarmprocesslog(dto) {
        try {
            console.log(`----delete_alarmprocesslog---`);
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.andWhere('l.device_id=:device_id', { device_id: device_id });
            query.andWhere('l.alarm_action_id=:alarm_action_id', {
                alarm_action_id: alarm_action_id,
            });
            query.andWhere('l.type_id=:type_id', { type_id: type_id });
            query.andWhere('l.date=:date', { date: date_now });
            query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                if (alarm_status) {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                        alarm_status: alarm_status,
                    };
                }
                else {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                    };
                }
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                var rt = parseInt('1');
                return rt;
            }
            else {
                var rt = parseInt('0');
                return rt;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async delete_alarm_process_log_by_id(dto) {
        try {
            console.log(`----delete_alarmprocesslog---`);
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            if (device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: device_id });
            }
            if (alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: type_id });
            }
            if (date_now) {
                query.andWhere('l.date=:date', { date: date_now });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            }
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                var criteria = {
                    alarm_action_id: alarm_action_id,
                    device_id: device_id,
                };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                var rt = parseInt('1');
                return rt;
            }
            else {
                var rt = parseInt('0');
                return rt;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async delete_alarm_process_log_fillter(dto) {
        try {
            console.log(`----delete_alarm_process_log_fillter--`);
            const query = this.alarmprocesslogRepository.createQueryBuilder('l');
            query.where('1=1');
            if (dto.id)
                query.andWhere('l.id = :id', { id: dto.id });
            if (dto.device_id)
                query.andWhere('l.device_id = :device_id', {
                    device_id: dto.device_id,
                });
            if (dto.alarm_action_id)
                query.andWhere('l.alarm_action_id = :alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            if (dto.alarm_status)
                query.andWhere('l.alarm_status = :alarm_status', {
                    date: dto.alarm_status,
                });
            if (dto.type_id)
                query.andWhere('l.type_id = :type_id', { type_id: dto.type_id });
            if (dto.date_now)
                query.andWhere('l.date = :date', { date: dto.date_now });
            query.maxExecutionTime(10000);
            const count = await query.getCount();
            console.log(`count => `, count);
            if (count >= 1) {
                const criteria = {};
                if (dto.id)
                    criteria.id = dto.id;
                if (dto.device_id)
                    criteria.device_id = dto.device_id;
                if (dto.alarm_action_id)
                    criteria.alarm_action_id = dto.alarm_action_id;
                if (dto.alarm_status)
                    criteria.alarm_status = dto.alarm_status;
                if (dto.type_id)
                    criteria.type_id = dto.type_id;
                if (dto.date_now)
                    criteria.date = dto.date_now;
                const deleteResult = await this.alarmprocesslogRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                    return 1;
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                    return 0;
                }
            }
            else {
                return 0;
            }
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error.message || error },
                },
            });
        }
    }
    async delete_alarmprocesslog_Cleardata(dto) {
        try {
            console.log(`----delete_alarmprocesslog---`);
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const deleteResult = await this.alarmprocesslogRepository
                    .createQueryBuilder()
                    .delete()
                    .where('1=1')
                    .execute();
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                var rt = parseInt('1');
                return rt;
            }
            else {
                var rt = parseInt('0');
                return rt;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async delete_alarmprocesslog_Recovery(dto) {
        try {
            console.log(`----delete_alarmprocesslog---`);
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            if (device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: device_id });
            }
            if (alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: type_id });
            }
            if (date_now) {
                query.andWhere('l.date=:date', { date: date_now });
            }
            if (data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            }
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                if (date_now) {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                    };
                }
                else {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                    };
                }
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                var rt = parseInt('1');
                return rt;
            }
            else {
                var rt = parseInt('0');
                return rt;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async count_alarmprocesslog(dto) {
        console.log(`count_alarmprocesslogdto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            var status = dto.status;
            const query = await this.alarmprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count_alarmprocesslog-count =>` + count);
            console.log(`tempCountt.count =>`);
            console.info(count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async get_alarmprocesslog(alarm_action_id) {
        try {
            const rs = await this.alarmprocesslogRepository.findOne({
                where: {
                    alarm_action_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async alarm_processlog_page(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.alarmprocesslogRepository.createQueryBuilder('l');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            }
            else {
                query.select([
                    'l.*',
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'sad.alarm_action_id AS alarm_action_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS timelife',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                ]);
            }
            query.innerJoin('sd_iot_alarm_device_event', 'sad', 'sad.device_id= l.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= l.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.keyword) {
                query.andWhere('d.device_name like :device_name', {
                    device_name: keyword ? `%${dto.keyword}%` : '%',
                });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.schedule_id) {
                query.andWhere('l.schedule_id=:schedule_id', {
                    schedule_id: dto.schedule_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.schedule_event_start) {
                query.andWhere('l.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: dto.schedule_event_start,
                });
            }
            if (dto.day) {
                query.andWhere('l.day=:day', { day: dto.day });
            }
            if (dto.doday) {
                query.andWhere('l.doday=:doday', { doday: dto.doday });
            }
            if (dto.dotime) {
                query.andWhere('l.dotime=:dotime', { dotime: dto.dotime });
            }
            if (dto.schedule_event) {
                query.andWhere('l.schedule_event=:schedule_event', {
                    schedule_event: dto.schedule_event,
                });
            }
            if (dto.device_status) {
                query.andWhere('l.device_status=:device_status', {
                    device_status: dto.device_status,
                });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarmprocesslog(dto) {
        console.log(`chk_alarmprocesslog_dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarm_temp_log(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogtempRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarm_temp_log_asc(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogtempRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'ASC');
            query.addOrderBy('l.updateddate', 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarm_temp_log_desc(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogtempRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    removeDuplicatesByCreatedDate(results) {
        const seen = new Set();
        return results.filter((item) => {
            const createdDateKey = item.createddate
                ? new Date(item.createddate).toISOString()
                : '';
            if (seen.has(createdDateKey)) {
                return false;
            }
            seen.add(createdDateKey);
            return true;
        });
    }
    async __alarmlogpaginate(dto) {
        console.log('dto=>');
        console.info(dto);
        try {
            const bucket = dto.bucket || '';
            const keyword = dto.keyword || '';
            const event = dto.event || '';
            const status = dto.status;
            const sort = dto.sort;
            const page = Number(dto.page) || 1;
            const pageSize = Number(dto.pageSize) || 10;
            const isCount = Number(dto.isCount) || 0;
            const type_id_log = Number(dto.type_id_log);
            let email_alarm = undefined;
            let line_alarm = undefined;
            let telegram_alarm = undefined;
            let sms_alarm = undefined;
            let nonc_alarm = undefined;
            switch (type_id_log) {
                case 1:
                    email_alarm = 1;
                    break;
                case 2:
                    line_alarm = 1;
                    break;
                case 3:
                    telegram_alarm = 1;
                    break;
                case 4:
                    sms_alarm = 1;
                    break;
                case 5:
                    nonc_alarm = 1;
                    break;
            }
            const query = this.alarmprocesslogtempRepository.createQueryBuilder('al');
            if (isCount == 1) {
                query.distinctOn(['d.device_id', 'al.date', 'al.time']);
                query.select(['al.id AS id']);
            }
            else {
                query.distinctOn(['d.device_id', 'al.date', 'al.time']);
                query.select([
                    'al.id AS id',
                    'al.alarm_action_id AS alarm_action_id',
                    'al.event AS event_log',
                    'al.alarm_type AS alarm_type',
                    'al.status_warning AS status_warning',
                    'al.recovery_warning AS recovery_warning',
                    'al.status_alert AS status_alert',
                    'al.recovery_alert AS recovery_alert',
                    'al.email_alarm AS email_alarm',
                    'al.line_alarm AS line_alarm',
                    'al.telegram_alarm AS telegram_alarm',
                    'al.sms_alarm AS sms_alarm',
                    'al.nonc_alarm AS nonc_alarm',
                    'al.status AS status',
                    'al.date AS date',
                    'al.time AS time',
                    'al.data AS data',
                    'al.data_alarm AS data_alarm',
                    'al.alarm_status AS alarm_status',
                    'al.updateddate AS updateddate',
                    'al.subject AS subject',
                    'al.content AS content',
                    'al.createddate AS createddate',
                    'd.device_id AS device_id',
                    'd.bucket AS bucket',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'daa.action_name AS action_name',
                    'daa.status_warning AS warning',
                    'daa.recovery_warning AS recoverywarning',
                    'daa.status_alert AS alert',
                    'daa.recovery_alert AS recoveryalert',
                    'daa.email_alarm AS emailalarm',
                    'daa.line_alarm AS linealarm',
                    'daa.telegram_alarm AS telegramalarm',
                    'daa.sms_alarm AS smsalarm',
                    'daa.nonc_alarm AS noncalarm',
                    'daa.time_life AS timelife',
                    'daa.event AS event',
                ]);
            }
            query.innerJoin('sd_iot_device_alarm_action', 'daa', 'daa.alarm_action_id = al.alarm_action_id');
            query.innerJoin('sd_iot_device', 'd', 'd.device_id = al.device_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('daa.action_name LIKE :action_name', {
                    action_name: `%${keyword}%`,
                });
            }
            if (event) {
                query.andWhere('daa.event = :event', { event });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id = :alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('d.device_id = :device_id', {
                    device_id: dto.device_id,
                });
            }
            if (status !== undefined && status !== null && status !== '') {
                query.andWhere('daa.status = :status', { status });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id = :type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('l.location_id = :location_id', {
                    location_id: dto.location_id,
                });
            }
            if (bucket) {
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (dto.start && dto.end) {
                query.andWhere('al.date BETWEEN :startDate AND :endDate', {
                    startDate: dto.start,
                    endDate: dto.end,
                });
            }
            else if (dto.start) {
                query.andWhere('al.date >= :startDate', { startDate: dto.start });
            }
            else if (dto.end) {
                query.andWhere('al.date <= :endDate', { endDate: dto.end });
            }
            if (email_alarm !== undefined) {
                query.andWhere('al.email_alarm = :email_alarm', { email_alarm });
            }
            if (line_alarm !== undefined) {
                query.andWhere('al.line_alarm = :line_alarm', { line_alarm });
            }
            if (telegram_alarm !== undefined) {
                query.andWhere('al.telegram_alarm = :telegram_alarm', {
                    telegram_alarm,
                });
            }
            if (sms_alarm !== undefined) {
                query.andWhere('al.sms_alarm = :sms_alarm', { sms_alarm });
            }
            if (nonc_alarm !== undefined) {
                query.andWhere('al.nonc_alarm = :nonc_alarm', { nonc_alarm });
            }
            query.maxExecutionTime(10000);
            if (isCount == 1) {
                const results = await query.getRawMany();
                let count = results.length;
                return count ? Number(count) : 0;
            }
            else {
                query.orderBy('al.time', 'DESC');
                query.addOrderBy('al.date', 'DESC');
                query.addOrderBy('d.device_id', 'ASC');
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (!sortResult) {
                        throw new common_1.BadRequestException('Invalid sort option.');
                    }
                    const { sortField, sortOrder } = sortResult;
                    query.addOrderBy(`al.${sortField}`, sortOrder.toUpperCase());
                }
                else {
                    query.addOrderBy('al.id', 'DESC');
                }
                query.limit(pageSize);
                query.offset((page - 1) * pageSize);
                const results = await query.getRawMany();
                return this.removeDuplicateByDateTime(results);
            }
        }
        catch (error) {
            console.error('alarmlogpaginate error:', error);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    message: error.message || 'An error occurred',
                },
            });
        }
    }
    async alarmlogpaginate(dto) {
        console.log('dto=>');
        console.info(dto);
        try {
            const bucket = dto.bucket || '';
            const keyword = dto.keyword || '';
            const event = dto.event || '';
            const status = dto.status;
            const sort = dto.sort;
            const page = Number(dto.page) || 1;
            const pageSize = Number(dto.pageSize) || 10;
            const isCount = Number(dto.isCount) || 0;
            const type_id_log = Number(dto.type_id_log);
            let email_alarm = undefined;
            let line_alarm = undefined;
            let telegram_alarm = undefined;
            let sms_alarm = undefined;
            let nonc_alarm = undefined;
            switch (type_id_log) {
                case 1:
                    email_alarm = 1;
                    break;
                case 2:
                    line_alarm = 1;
                    break;
                case 3:
                    telegram_alarm = 1;
                    break;
                case 4:
                    sms_alarm = 1;
                    break;
                case 5:
                    nonc_alarm = 1;
                    break;
            }
            const query = this.alarmprocesslogtempRepository.createQueryBuilder('al');
            if (isCount == 1) {
                await query.select('COUNT(al.id)', 'cnt');
            }
            else {
                query.select([
                    'al.id AS id',
                    'al.alarm_action_id AS alarm_action_id',
                    'al.event AS event_log',
                    'al.alarm_type AS alarm_type',
                    'al.status_warning AS status_warning',
                    'al.recovery_warning AS recovery_warning',
                    'al.status_alert AS status_alert',
                    'al.recovery_alert AS recovery_alert',
                    'al.email_alarm AS email_alarm',
                    'al.line_alarm AS line_alarm',
                    'al.telegram_alarm AS telegram_alarm',
                    'al.sms_alarm AS sms_alarm',
                    'al.nonc_alarm AS nonc_alarm',
                    'al.status AS status',
                    'al.date AS date',
                    'al.time AS time',
                    'al.data AS data',
                    'al.data_alarm AS data_alarm',
                    'al.alarm_status AS alarm_status',
                    'al.updateddate AS updateddate',
                    'al.subject AS subject',
                    'al.content AS content',
                    'al.createddate AS createddate',
                    'd.device_id AS device_id',
                    'd.bucket AS bucket',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'daa.action_name AS action_name',
                    'daa.status_warning AS warning',
                    'daa.recovery_warning AS recoverywarning',
                    'daa.status_alert AS alert',
                    'daa.recovery_alert AS recoveryalert',
                    'daa.email_alarm AS emailalarm',
                    'daa.line_alarm AS linealarm',
                    'daa.telegram_alarm AS telegramalarm',
                    'daa.sms_alarm AS smsalarm',
                    'daa.nonc_alarm AS noncalarm',
                    'daa.time_life AS timelife',
                    'daa.event AS event',
                ]);
            }
            query.innerJoin('sd_iot_device_alarm_action', 'daa', 'daa.alarm_action_id = al.alarm_action_id');
            query.innerJoin('sd_iot_device', 'd', 'd.device_id = al.device_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('daa.action_name LIKE :action_name', {
                    action_name: `%${keyword}%`,
                });
            }
            if (event) {
                query.andWhere('daa.event = :event', { event });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id = :alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('d.device_id = :device_id', {
                    device_id: dto.device_id,
                });
            }
            if (status !== undefined && status !== null && status !== '') {
                query.andWhere('daa.status = :status', { status });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id = :type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('l.location_id = :location_id', {
                    location_id: dto.location_id,
                });
            }
            if (bucket) {
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (dto.start && dto.end) {
                query.andWhere('al.date BETWEEN :startDate AND :endDate', {
                    startDate: dto.start,
                    endDate: dto.end,
                });
            }
            else if (dto.start) {
                query.andWhere('al.date >= :startDate', { startDate: dto.start });
            }
            else if (dto.end) {
                query.andWhere('al.date <= :endDate', { endDate: dto.end });
            }
            if (email_alarm !== undefined) {
                query.andWhere('al.email_alarm = :email_alarm', { email_alarm });
            }
            if (line_alarm !== undefined) {
                query.andWhere('al.line_alarm = :line_alarm', { line_alarm });
            }
            if (telegram_alarm !== undefined) {
                query.andWhere('al.telegram_alarm = :telegram_alarm', {
                    telegram_alarm,
                });
            }
            if (sms_alarm !== undefined) {
                query.andWhere('al.sms_alarm = :sms_alarm', { sms_alarm });
            }
            if (nonc_alarm !== undefined) {
                query.andWhere('al.nonc_alarm = :nonc_alarm', { nonc_alarm });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                console.log(`count =>` + count);
                return count;
            }
            else {
                query.orderBy('al.date', 'DESC');
                query.addOrderBy('al.time', 'DESC');
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    removeDuplicateByDateTime(results) {
        const seen = new Set();
        return results.filter((item) => {
            const date = item.date;
            const time = item.time;
            if (!date || !time)
                return true;
            const dateTimeKey = `${date}-${time}`;
            if (seen.has(dateTimeKey)) {
                return false;
            }
            seen.add(dateTimeKey);
            return true;
        });
    }
    async alarmlogpaginateemail(dto) {
        console.log('dto=>');
        console.info(dto);
        try {
            const bucket = dto.bucket || '';
            const keyword = dto.keyword || '';
            const event = dto.event || '';
            const status = dto.status;
            const sort = dto.sort;
            const page = Number(dto.page) || 1;
            const pageSize = Number(dto.pageSize) || 10;
            const isCount = Number(dto.isCount) || 0;
            const type_id_log = Number(dto.type_id_log);
            let email_alarm = undefined;
            let line_alarm = undefined;
            let telegram_alarm = undefined;
            let sms_alarm = undefined;
            let nonc_alarm = undefined;
            switch (type_id_log) {
                case 1:
                    email_alarm = parseInt('1');
                    break;
                case 2:
                    line_alarm = parseInt('1');
                    break;
                case 3:
                    telegram_alarm = parseInt('1');
                    break;
                case 4:
                    sms_alarm = parseInt('1');
                    break;
                case 5:
                    nonc_alarm = parseInt('1');
                    break;
            }
            const query = this.alarmprocesslogemailRepository.createQueryBuilder('al');
            if (isCount !== 1) {
                query.select([
                    'al.id AS id',
                    'al.alarm_action_id AS alarm_action_id',
                    'al.event AS event_log',
                    'al.alarm_type AS alarm_type',
                    'al.status_warning AS status_warning',
                    'al.recovery_warning AS recovery_warning',
                    'al.status_alert AS status_alert',
                    'al.recovery_alert AS recovery_alert',
                    'al.email_alarm AS email_alarm',
                    'al.line_alarm AS line_alarm',
                    'al.telegram_alarm AS telegram_alarm',
                    'al.sms_alarm AS sms_alarm',
                    'al.nonc_alarm AS nonc_alarm',
                    'al.status AS status',
                    'al.date AS date',
                    'al.time AS time',
                    'al.data AS data',
                    'al.data_alarm AS data_alarm',
                    'al.alarm_status AS alarm_status',
                    'al.date AS date',
                    'al.createddate AS createddate',
                    'al.updateddate AS updateddate',
                    'al.subject AS subject',
                    'al.content AS content',
                    'd.device_id AS device_id',
                    'd.bucket AS bucket',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'daa.action_name AS action_name',
                    'daa.status_warning AS warning',
                    'daa.recovery_warning AS recoverywarning',
                    'daa.status_alert AS alert',
                    'daa.recovery_alert AS recoveryalert',
                    'daa.email_alarm AS emailalarm',
                    'daa.line_alarm AS linealarm',
                    'daa.telegram_alarm AS telegramalarm',
                    'daa.sms_alarm AS smsalarm',
                    'daa.nonc_alarm AS noncalarm',
                    'daa.time_life AS timelife',
                    'daa.event AS event',
                ]);
            }
            else {
                query.select('COUNT(DISTINCT al.id)', 'cnt');
            }
            query.innerJoin('sd_iot_device_alarm_action', 'daa', 'daa.alarm_action_id = al.alarm_action_id');
            query.innerJoin('sd_iot_device', 'd', 'd.device_id = al.device_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('daa.action_name LIKE :action_name', {
                    action_name: `%${keyword}%`,
                });
            }
            if (event) {
                query.andWhere('daa.event = :event', { event });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id = :alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('d.device_id = :device_id', {
                    device_id: dto.device_id,
                });
            }
            if (status !== undefined && status !== null && status !== '') {
                query.andWhere('daa.status = :status', { status });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id = :type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('l.location_id = :location_id', {
                    location_id: dto.location_id,
                });
            }
            if (bucket) {
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (dto.start && dto.end) {
                query.andWhere('al.createddate BETWEEN :startDate AND :endDate', {
                    startDate: dto.start,
                    endDate: dto.end,
                });
            }
            else if (dto.start) {
                query.andWhere('al.createddate >= :startDate', {
                    startDate: dto.start,
                });
            }
            else if (dto.end) {
                query.andWhere('al.createddate <= :endDate', { endDate: dto.end });
            }
            if (email_alarm !== undefined) {
                query.andWhere('al.email_alarm = :email_alarm', { email_alarm });
            }
            if (line_alarm !== undefined) {
                query.andWhere('al.line_alarm = :line_alarm', { line_alarm });
            }
            if (telegram_alarm !== undefined) {
                query.andWhere('al.telegram_alarm = :telegram_alarm', {
                    telegram_alarm,
                });
            }
            if (sms_alarm !== undefined) {
                query.andWhere('al.sms_alarm = :sms_alarm', { sms_alarm });
            }
            if (nonc_alarm !== undefined) {
                query.andWhere('al.nonc_alarm = :nonc_alarm', { nonc_alarm });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                const countResult = await query.getRawOne();
                const count = countResult ? Number(countResult.cnt) : 0;
                console.log('count =>', count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException('Invalid sort option.');
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log('sort=', sort);
                    console.log('sortField=', sortField);
                    console.log('sortOrder=', sortOrder);
                    query.orderBy(`al.${sortField}`, sortOrder.toUpperCase());
                }
                else {
                    query.orderBy('al.createddate', 'DESC');
                    query.addOrderBy('al.updateddate', 'DESC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                var rs = await query.getRawMany();
                return rs;
            }
        }
        catch (error) {
            console.error('alarmlogpaginate error:', error);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error.message || error },
                },
            });
        }
    }
    async alarmlogpaginateecontrol(dto) {
        console.log('dto=>');
        console.info(dto);
        try {
            const bucket = dto.bucket || '';
            const keyword = dto.keyword || '';
            const event = dto.event || '';
            const status = dto.status;
            const sort = dto.sort;
            const page = Number(dto.page) || 1;
            const pageSize = Number(dto.pageSize) || 10;
            const isCount = Number(dto.isCount) || 0;
            const type_id_log = Number(dto.type_id_log);
            let email_alarm = undefined;
            let line_alarm = undefined;
            let telegram_alarm = undefined;
            let sms_alarm = undefined;
            let nonc_alarm = undefined;
            switch (type_id_log) {
                case 1:
                    email_alarm = parseInt('1');
                    break;
                case 2:
                    line_alarm = parseInt('1');
                    break;
                case 3:
                    telegram_alarm = parseInt('1');
                    break;
                case 4:
                    sms_alarm = parseInt('1');
                    break;
                case 5:
                    nonc_alarm = parseInt('1');
                    break;
            }
            const query = this.alarmprocesslogRepository.createQueryBuilder('al');
            if (isCount !== 1) {
                query.select([
                    'al.id AS id',
                    'al.alarm_action_id AS alarm_action_id',
                    'al.event AS event_log',
                    'al.alarm_type AS alarm_type',
                    'al.status_warning AS status_warning',
                    'al.recovery_warning AS recovery_warning',
                    'al.status_alert AS status_alert',
                    'al.recovery_alert AS recovery_alert',
                    'al.email_alarm AS email_alarm',
                    'al.line_alarm AS line_alarm',
                    'al.telegram_alarm AS telegram_alarm',
                    'al.sms_alarm AS sms_alarm',
                    'al.nonc_alarm AS nonc_alarm',
                    'al.status AS status',
                    'al.date AS date',
                    'al.time AS time',
                    'al.data AS data',
                    'al.data_alarm AS data_alarm',
                    'al.alarm_status AS alarm_status',
                    'al.date AS date',
                    'al.createddate AS createddate',
                    'al.updateddate AS updateddate',
                    'al.subject AS subject',
                    'al.content AS content',
                    'd.device_id AS device_id',
                    'd.bucket AS bucket',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'daa.action_name AS action_name',
                    'daa.status_warning AS warning',
                    'daa.recovery_warning AS recoverywarning',
                    'daa.status_alert AS alert',
                    'daa.recovery_alert AS recoveryalert',
                    'daa.email_alarm AS emailalarm',
                    'daa.line_alarm AS linealarm',
                    'daa.telegram_alarm AS telegramalarm',
                    'daa.sms_alarm AS smsalarm',
                    'daa.nonc_alarm AS noncalarm',
                    'daa.time_life AS timelife',
                    'daa.event AS event',
                ]);
            }
            else {
                query.select('COUNT(DISTINCT al.id)', 'cnt');
            }
            query.innerJoin('sd_iot_device_alarm_action', 'daa', 'daa.alarm_action_id = al.alarm_action_id');
            query.innerJoin('sd_iot_device', 'd', 'd.device_id = al.device_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('daa.action_name LIKE :action_name', {
                    action_name: `%${keyword}%`,
                });
            }
            if (event) {
                query.andWhere('daa.event = :event', { event });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id = :alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('d.device_id = :device_id', {
                    device_id: dto.device_id,
                });
            }
            if (status !== undefined && status !== null && status !== '') {
                query.andWhere('daa.status = :status', { status });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id = :type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('l.location_id = :location_id', {
                    location_id: dto.location_id,
                });
            }
            if (bucket) {
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (dto.start && dto.end) {
                query.andWhere('al.createddate BETWEEN :startDate AND :endDate', {
                    startDate: dto.start,
                    endDate: dto.end,
                });
            }
            else if (dto.start) {
                query.andWhere('al.createddate >= :startDate', {
                    startDate: dto.start,
                });
            }
            else if (dto.end) {
                query.andWhere('al.createddate <= :endDate', { endDate: dto.end });
            }
            if (email_alarm !== undefined) {
                query.andWhere('al.email_alarm = :email_alarm', { email_alarm });
            }
            if (line_alarm !== undefined) {
                query.andWhere('al.line_alarm = :line_alarm', { line_alarm });
            }
            if (telegram_alarm !== undefined) {
                query.andWhere('al.telegram_alarm = :telegram_alarm', {
                    telegram_alarm,
                });
            }
            if (sms_alarm !== undefined) {
                query.andWhere('al.sms_alarm = :sms_alarm', { sms_alarm });
            }
            if (nonc_alarm !== undefined) {
                query.andWhere('al.nonc_alarm = :nonc_alarm', { nonc_alarm });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                const countResult = await query.getRawOne();
                const count = countResult ? Number(countResult.cnt) : 0;
                console.log('count =>', count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException('Invalid sort option.');
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log('sort=', sort);
                    console.log('sortField=', sortField);
                    console.log('sortOrder=', sortOrder);
                    query.orderBy(`al.${sortField}`, sortOrder.toUpperCase());
                }
                else {
                    query.orderBy('al.createddate', 'DESC');
                    query.addOrderBy('al.updateddate', 'DESC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                var rs = await query.getRawMany();
                return rs;
            }
        }
        catch (error) {
            console.error('alarmlogpaginate error:', error);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error.message || error },
                },
            });
        }
    }
    async alarmlogpagline(dto) {
        console.log('dto=>');
        console.info(dto);
        try {
            const bucket = dto.bucket || '';
            const keyword = dto.keyword || '';
            const event = dto.event || '';
            const status = dto.status;
            const sort = dto.sort;
            const page = Number(dto.page) || 1;
            const pageSize = Number(dto.pageSize) || 10;
            const isCount = Number(dto.isCount) || 0;
            const type_id_log = Number(dto.type_id_log);
            let email_alarm = undefined;
            let line_alarm = undefined;
            let telegram_alarm = undefined;
            let sms_alarm = undefined;
            let nonc_alarm = undefined;
            switch (type_id_log) {
                case 1:
                    email_alarm = parseInt('1');
                    break;
                case 2:
                    line_alarm = parseInt('1');
                    break;
                case 3:
                    telegram_alarm = parseInt('1');
                    break;
                case 4:
                    sms_alarm = parseInt('1');
                    break;
                case 5:
                    nonc_alarm = parseInt('1');
                    break;
            }
            const query = this.alarmprocessloglineRepository.createQueryBuilder('al');
            if (isCount !== 1) {
                query.select([
                    'al.id AS id',
                    'al.alarm_action_id AS alarm_action_id',
                    'al.event AS event_log',
                    'al.alarm_type AS alarm_type',
                    'al.status_warning AS status_warning',
                    'al.recovery_warning AS recovery_warning',
                    'al.status_alert AS status_alert',
                    'al.recovery_alert AS recovery_alert',
                    'al.email_alarm AS email_alarm',
                    'al.line_alarm AS line_alarm',
                    'al.telegram_alarm AS telegram_alarm',
                    'al.sms_alarm AS sms_alarm',
                    'al.nonc_alarm AS nonc_alarm',
                    'al.status AS status',
                    'al.date AS date',
                    'al.time AS time',
                    'al.data AS data',
                    'al.data_alarm AS data_alarm',
                    'al.alarm_status AS alarm_status',
                    'al.date AS date',
                    'al.createddate AS createddate',
                    'al.updateddate AS updateddate',
                    'al.subject AS subject',
                    'al.content AS content',
                    'd.device_id AS device_id',
                    'd.bucket AS bucket',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'daa.action_name AS action_name',
                    'daa.status_warning AS warning',
                    'daa.recovery_warning AS recoverywarning',
                    'daa.status_alert AS alert',
                    'daa.recovery_alert AS recoveryalert',
                    'daa.email_alarm AS emailalarm',
                    'daa.line_alarm AS linealarm',
                    'daa.telegram_alarm AS telegramalarm',
                    'daa.sms_alarm AS smsalarm',
                    'daa.nonc_alarm AS noncalarm',
                    'daa.time_life AS timelife',
                    'daa.event AS event',
                ]);
            }
            else {
                query.select('COUNT(DISTINCT al.id)', 'cnt');
            }
            query.innerJoin('sd_iot_device_alarm_action', 'daa', 'daa.alarm_action_id = al.alarm_action_id');
            query.innerJoin('sd_iot_device', 'd', 'd.device_id = al.device_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('daa.action_name LIKE :action_name', {
                    action_name: `%${keyword}%`,
                });
            }
            if (event) {
                query.andWhere('daa.event = :event', { event });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id = :alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('d.device_id = :device_id', {
                    device_id: dto.device_id,
                });
            }
            if (status !== undefined && status !== null && status !== '') {
                query.andWhere('daa.status = :status', { status });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id = :type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('l.location_id = :location_id', {
                    location_id: dto.location_id,
                });
            }
            if (bucket) {
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (dto.start && dto.end) {
                query.andWhere('al.createddate BETWEEN :startDate AND :endDate', {
                    startDate: dto.start,
                    endDate: dto.end,
                });
            }
            else if (dto.start) {
                query.andWhere('al.createddate >= :startDate', {
                    startDate: dto.start,
                });
            }
            else if (dto.end) {
                query.andWhere('al.createddate <= :endDate', { endDate: dto.end });
            }
            if (email_alarm !== undefined) {
                query.andWhere('al.email_alarm = :email_alarm', { email_alarm });
            }
            if (line_alarm !== undefined) {
                query.andWhere('al.line_alarm = :line_alarm', { line_alarm });
            }
            if (telegram_alarm !== undefined) {
                query.andWhere('al.telegram_alarm = :telegram_alarm', {
                    telegram_alarm,
                });
            }
            if (sms_alarm !== undefined) {
                query.andWhere('al.sms_alarm = :sms_alarm', { sms_alarm });
            }
            if (nonc_alarm !== undefined) {
                query.andWhere('al.nonc_alarm = :nonc_alarm', { nonc_alarm });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                const countResult = await query.getRawOne();
                const count = countResult ? Number(countResult.cnt) : 0;
                console.log('count =>', count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException('Invalid sort option.');
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log('sort=', sort);
                    console.log('sortField=', sortField);
                    console.log('sortOrder=', sortOrder);
                    query.orderBy(`al.${sortField}`, sortOrder.toUpperCase());
                }
                else {
                    query.orderBy('al.createddate', 'DESC');
                    query.addOrderBy('al.updateddate', 'DESC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                var rs = await query.getRawMany();
                return rs;
            }
        }
        catch (error) {
            console.error('alarmlogpaginate error:', error);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error.message || error },
                },
            });
        }
    }
    async alarmlogpagesms(dto) {
        console.log('dto=>');
        console.info(dto);
        try {
            const bucket = dto.bucket || '';
            const keyword = dto.keyword || '';
            const event = dto.event || '';
            const status = dto.status;
            const sort = dto.sort;
            const page = Number(dto.page) || 1;
            const pageSize = Number(dto.pageSize) || 10;
            const isCount = Number(dto.isCount) || 0;
            const type_id_log = Number(dto.type_id_log);
            let email_alarm = undefined;
            let line_alarm = undefined;
            let telegram_alarm = undefined;
            let sms_alarm = undefined;
            let nonc_alarm = undefined;
            switch (type_id_log) {
                case 1:
                    email_alarm = parseInt('1');
                    break;
                case 2:
                    line_alarm = parseInt('1');
                    break;
                case 3:
                    telegram_alarm = parseInt('1');
                    break;
                case 4:
                    sms_alarm = parseInt('1');
                    break;
                case 5:
                    nonc_alarm = parseInt('1');
                    break;
            }
            const query = this.alarmprocesslogsmsRepository.createQueryBuilder('al');
            if (isCount !== 1) {
                query.select([
                    'al.id AS id',
                    'al.alarm_action_id AS alarm_action_id',
                    'al.event AS event_log',
                    'al.alarm_type AS alarm_type',
                    'al.status_warning AS status_warning',
                    'al.recovery_warning AS recovery_warning',
                    'al.status_alert AS status_alert',
                    'al.recovery_alert AS recovery_alert',
                    'al.email_alarm AS email_alarm',
                    'al.line_alarm AS line_alarm',
                    'al.telegram_alarm AS telegram_alarm',
                    'al.sms_alarm AS sms_alarm',
                    'al.nonc_alarm AS nonc_alarm',
                    'al.status AS status',
                    'al.date AS date',
                    'al.time AS time',
                    'al.data AS data',
                    'al.data_alarm AS data_alarm',
                    'al.alarm_status AS alarm_status',
                    'al.date AS date',
                    'al.createddate AS createddate',
                    'al.updateddate AS updateddate',
                    'al.subject AS subject',
                    'al.content AS content',
                    'd.device_id AS device_id',
                    'd.bucket AS bucket',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'daa.action_name AS action_name',
                    'daa.status_warning AS warning',
                    'daa.recovery_warning AS recoverywarning',
                    'daa.status_alert AS alert',
                    'daa.recovery_alert AS recoveryalert',
                    'daa.email_alarm AS emailalarm',
                    'daa.line_alarm AS linealarm',
                    'daa.telegram_alarm AS telegramalarm',
                    'daa.sms_alarm AS smsalarm',
                    'daa.nonc_alarm AS noncalarm',
                    'daa.time_life AS timelife',
                    'daa.event AS event',
                ]);
            }
            else {
                query.select('COUNT(DISTINCT al.id)', 'cnt');
            }
            query.innerJoin('sd_iot_device_alarm_action', 'daa', 'daa.alarm_action_id = al.alarm_action_id');
            query.innerJoin('sd_iot_device', 'd', 'd.device_id = al.device_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('daa.action_name LIKE :action_name', {
                    action_name: `%${keyword}%`,
                });
            }
            if (event) {
                query.andWhere('daa.event = :event', { event });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id = :alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('d.device_id = :device_id', {
                    device_id: dto.device_id,
                });
            }
            if (status !== undefined && status !== null && status !== '') {
                query.andWhere('daa.status = :status', { status });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id = :type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('l.location_id = :location_id', {
                    location_id: dto.location_id,
                });
            }
            if (bucket) {
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (dto.start && dto.end) {
                query.andWhere('al.createddate BETWEEN :startDate AND :endDate', {
                    startDate: dto.start,
                    endDate: dto.end,
                });
            }
            else if (dto.start) {
                query.andWhere('al.createddate >= :startDate', {
                    startDate: dto.start,
                });
            }
            else if (dto.end) {
                query.andWhere('al.createddate <= :endDate', { endDate: dto.end });
            }
            if (email_alarm !== undefined) {
                query.andWhere('al.email_alarm = :email_alarm', { email_alarm });
            }
            if (line_alarm !== undefined) {
                query.andWhere('al.line_alarm = :line_alarm', { line_alarm });
            }
            if (telegram_alarm !== undefined) {
                query.andWhere('al.telegram_alarm = :telegram_alarm', {
                    telegram_alarm,
                });
            }
            if (sms_alarm !== undefined) {
                query.andWhere('al.sms_alarm = :sms_alarm', { sms_alarm });
            }
            if (nonc_alarm !== undefined) {
                query.andWhere('al.nonc_alarm = :nonc_alarm', { nonc_alarm });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                const countResult = await query.getRawOne();
                const count = countResult ? Number(countResult.cnt) : 0;
                console.log('count =>', count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException('Invalid sort option.');
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log('sort=', sort);
                    console.log('sortField=', sortField);
                    console.log('sortOrder=', sortOrder);
                    query.orderBy(`al.${sortField}`, sortOrder.toUpperCase());
                }
                else {
                    query.orderBy('al.createddate', 'DESC');
                    query.addOrderBy('al.updateddate', 'DESC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                var rs = await query.getRawMany();
                return rs;
            }
        }
        catch (error) {
            console.error('alarmlogpaginate error:', error);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error.message || error },
                },
            });
        }
    }
    async alarmlogpaginatetelegram(dto) {
        console.log('dto=>');
        console.info(dto);
        try {
            const bucket = dto.bucket || '';
            const keyword = dto.keyword || '';
            const event = dto.event || '';
            const status = dto.status;
            const sort = dto.sort;
            const page = Number(dto.page) || 1;
            const pageSize = Number(dto.pageSize) || 10;
            const isCount = Number(dto.isCount) || 0;
            const type_id_log = Number(dto.type_id_log);
            let email_alarm = undefined;
            let line_alarm = undefined;
            let telegram_alarm = undefined;
            let sms_alarm = undefined;
            let nonc_alarm = undefined;
            switch (type_id_log) {
                case 1:
                    email_alarm = parseInt('1');
                    break;
                case 2:
                    line_alarm = parseInt('1');
                    break;
                case 3:
                    telegram_alarm = parseInt('1');
                    break;
                case 4:
                    sms_alarm = parseInt('1');
                    break;
                case 5:
                    nonc_alarm = parseInt('1');
                    break;
            }
            const query = this.alarmprocesslogtelegramRepository.createQueryBuilder('al');
            if (isCount !== 1) {
                query.select([
                    'al.id AS id',
                    'al.alarm_action_id AS alarm_action_id',
                    'al.event AS event_log',
                    'al.alarm_type AS alarm_type',
                    'al.status_warning AS status_warning',
                    'al.recovery_warning AS recovery_warning',
                    'al.status_alert AS status_alert',
                    'al.recovery_alert AS recovery_alert',
                    'al.email_alarm AS email_alarm',
                    'al.line_alarm AS line_alarm',
                    'al.telegram_alarm AS telegram_alarm',
                    'al.sms_alarm AS sms_alarm',
                    'al.nonc_alarm AS nonc_alarm',
                    'al.status AS status',
                    'al.date AS date',
                    'al.time AS time',
                    'al.data AS data',
                    'al.data_alarm AS data_alarm',
                    'al.alarm_status AS alarm_status',
                    'al.date AS date',
                    'al.createddate AS createddate',
                    'al.updateddate AS updateddate',
                    'al.subject AS subject',
                    'al.content AS content',
                    'd.device_id AS device_id',
                    'd.bucket AS bucket',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'daa.action_name AS action_name',
                    'daa.status_warning AS warning',
                    'daa.recovery_warning AS recoverywarning',
                    'daa.status_alert AS alert',
                    'daa.recovery_alert AS recoveryalert',
                    'daa.email_alarm AS emailalarm',
                    'daa.line_alarm AS linealarm',
                    'daa.telegram_alarm AS telegramalarm',
                    'daa.sms_alarm AS smsalarm',
                    'daa.nonc_alarm AS noncalarm',
                    'daa.time_life AS timelife',
                    'daa.event AS event',
                ]);
            }
            else {
                query.select('COUNT(DISTINCT al.id)', 'cnt');
            }
            query.innerJoin('sd_iot_device_alarm_action', 'daa', 'daa.alarm_action_id = al.alarm_action_id');
            query.innerJoin('sd_iot_device', 'd', 'd.device_id = al.device_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('daa.action_name LIKE :action_name', {
                    action_name: `%${keyword}%`,
                });
            }
            if (event) {
                query.andWhere('daa.event = :event', { event });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id = :alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('d.device_id = :device_id', {
                    device_id: dto.device_id,
                });
            }
            if (status !== undefined && status !== null && status !== '') {
                query.andWhere('daa.status = :status', { status });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id = :type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('l.location_id = :location_id', {
                    location_id: dto.location_id,
                });
            }
            if (bucket) {
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (dto.start && dto.end) {
                query.andWhere('al.createddate BETWEEN :startDate AND :endDate', {
                    startDate: dto.start,
                    endDate: dto.end,
                });
            }
            else if (dto.start) {
                query.andWhere('al.createddate >= :startDate', {
                    startDate: dto.start,
                });
            }
            else if (dto.end) {
                query.andWhere('al.createddate <= :endDate', { endDate: dto.end });
            }
            if (email_alarm !== undefined) {
                query.andWhere('al.email_alarm = :email_alarm', { email_alarm });
            }
            if (line_alarm !== undefined) {
                query.andWhere('al.line_alarm = :line_alarm', { line_alarm });
            }
            if (telegram_alarm !== undefined) {
                query.andWhere('al.telegram_alarm = :telegram_alarm', {
                    telegram_alarm,
                });
            }
            if (sms_alarm !== undefined) {
                query.andWhere('al.sms_alarm = :sms_alarm', { sms_alarm });
            }
            if (nonc_alarm !== undefined) {
                query.andWhere('al.nonc_alarm = :nonc_alarm', { nonc_alarm });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                const countResult = await query.getRawOne();
                const count = countResult ? Number(countResult.cnt) : 0;
                console.log('count =>', count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException('Invalid sort option.');
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log('sort=', sort);
                    console.log('sortField=', sortField);
                    console.log('sortOrder=', sortOrder);
                    query.orderBy(`al.${sortField}`, sortOrder.toUpperCase());
                }
                else {
                    query.orderBy('al.createddate', 'DESC');
                    query.addOrderBy('al.updateddate', 'DESC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                var rs = await query.getRawMany();
                return rs;
            }
        }
        catch (error) {
            console.error('alarmlogpaginate error:', error);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error.message || error },
                },
            });
        }
    }
    async create_alarmprocesslogtemp(dto) {
        console.log('dto=>');
        console.info(dto);
        const result = await this.alarmprocesslogtempRepository.save(this.alarmprocesslogtempRepository.create(dto));
        return result;
    }
    async create_alarmprocesslogmqtt(dto) {
        console.log('dto=>');
        console.info(dto);
        const result = await this.alarmprocesslogmqttRepository.save(this.alarmprocesslogmqttRepository.create(dto));
        return result;
    }
    async count_alarmprocesslogmqtt(dto) {
        console.log(`count_dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            var status = dto.status;
            const query = await this.alarmprocesslogmqttRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarmprocesslogmqtt(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogmqttRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async mqttlogpaginate(dto) {
        console.log('dto=>');
        console.info(dto);
        try {
            const bucket = dto.bucket || '';
            const keyword = dto.keyword || '';
            const event = dto.event || '';
            const status = dto.status;
            const sort = dto.sort;
            const page = Number(dto.page) || 1;
            const pageSize = Number(dto.pageSize) || 10;
            const isCount = Number(dto.isCount) || 0;
            const type_id_log = Number(dto.type_id_log);
            let email_alarm = undefined;
            let line_alarm = undefined;
            let telegram_alarm = undefined;
            let sms_alarm = undefined;
            let nonc_alarm = undefined;
            switch (type_id_log) {
                case 1:
                    email_alarm = parseInt('1');
                    break;
                case 2:
                    line_alarm = parseInt('1');
                    break;
                case 3:
                    telegram_alarm = parseInt('1');
                    break;
                case 4:
                    sms_alarm = parseInt('1');
                    break;
                case 5:
                    nonc_alarm = parseInt('1');
                    break;
            }
            const query = this.alarmprocesslogmqttRepository.createQueryBuilder('al');
            if (isCount !== 1) {
                query.select([
                    'al.id AS id',
                    'al.alarm_action_id AS alarm_action_id',
                    'al.event AS event_log',
                    'al.alarm_type AS alarm_type',
                    'al.status_warning AS status_warning',
                    'al.recovery_warning AS recovery_warning',
                    'al.status_alert AS status_alert',
                    'al.recovery_alert AS recovery_alert',
                    'al.email_alarm AS email_alarm',
                    'al.line_alarm AS line_alarm',
                    'al.telegram_alarm AS telegram_alarm',
                    'al.sms_alarm AS sms_alarm',
                    'al.nonc_alarm AS nonc_alarm',
                    'al.status AS status',
                    'al.date AS date',
                    'al.time AS time',
                    'al.data AS data',
                    'al.data_alarm AS data_alarm',
                    'al.alarm_status AS alarm_status',
                    'al.date AS date',
                    'al.createddate AS createddate',
                    'al.updateddate AS updateddate',
                    'al.subject AS subject',
                    'al.content AS content',
                    'd.device_id AS device_id',
                    'd.bucket AS bucket',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.mqtt_device_name AS mqtt_device_name',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'daa.action_name AS action_name',
                    'daa.status_warning AS warning',
                    'daa.recovery_warning AS recoverywarning',
                    'daa.status_alert AS alert',
                    'daa.recovery_alert AS recoveryalert',
                    'daa.email_alarm AS emailalarm',
                    'daa.line_alarm AS linealarm',
                    'daa.telegram_alarm AS telegramalarm',
                    'daa.sms_alarm AS smsalarm',
                    'daa.nonc_alarm AS noncalarm',
                    'daa.time_life AS timelife',
                    'daa.event AS event',
                ]);
            }
            else {
                query.select('COUNT(DISTINCT al.id)', 'cnt');
            }
            query.innerJoin('sd_iot_device_alarm_action', 'daa', 'daa.alarm_action_id = al.alarm_action_id');
            query.innerJoin('sd_iot_device', 'd', 'd.device_id = al.device_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id = mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('daa.action_name LIKE :action_name', {
                    action_name: `%${keyword}%`,
                });
            }
            if (event) {
                query.andWhere('daa.event = :event', { event });
            }
            if (dto.alarm_action_id) {
                query.andWhere('al.alarm_action_id = :alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('d.device_id = :device_id', {
                    device_id: dto.device_id,
                });
            }
            if (status !== undefined && status !== null && status !== '') {
                query.andWhere('daa.status = :status', { status });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id = :type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('l.location_id = :location_id', {
                    location_id: dto.location_id,
                });
            }
            if (bucket) {
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (dto.start && dto.end) {
                query.andWhere('al.createddate BETWEEN :startDate AND :endDate', {
                    startDate: dto.start,
                    endDate: dto.end,
                });
            }
            else if (dto.start) {
                query.andWhere('al.createddate >= :startDate', {
                    startDate: dto.start,
                });
            }
            else if (dto.end) {
                query.andWhere('al.createddate <= :endDate', { endDate: dto.end });
            }
            if (email_alarm !== undefined) {
                query.andWhere('al.email_alarm = :email_alarm', { email_alarm });
            }
            if (line_alarm !== undefined) {
                query.andWhere('al.line_alarm = :line_alarm', { line_alarm });
            }
            if (telegram_alarm !== undefined) {
                query.andWhere('al.telegram_alarm = :telegram_alarm', {
                    telegram_alarm,
                });
            }
            if (sms_alarm !== undefined) {
                query.andWhere('al.sms_alarm = :sms_alarm', { sms_alarm });
            }
            if (nonc_alarm !== undefined) {
                query.andWhere('al.nonc_alarm = :nonc_alarm', { nonc_alarm });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                const countResult = await query.getRawOne();
                const count = countResult ? Number(countResult.cnt) : 0;
                console.log('count =>', count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException('Invalid sort option.');
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log('sort=', sort);
                    console.log('sortField=', sortField);
                    console.log('sortOrder=', sortOrder);
                    query.orderBy(`al.${sortField}`, sortOrder.toUpperCase());
                }
                else {
                    query.orderBy('al.createddate', 'DESC');
                    query.addOrderBy('al.updateddate', 'DESC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                var rs = await query.getRawMany();
                return rs;
            }
        }
        catch (error) {
            console.error('alarmlogpaginate error:', error);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error.message || error },
                },
            });
        }
    }
    async delete_alarmprocesslog_mqtt(dto) {
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogmqttRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.andWhere('l.device_id=:device_id', { device_id: device_id });
            query.andWhere('l.alarm_action_id=:alarm_action_id', {
                alarm_action_id: alarm_action_id,
            });
            query.andWhere('l.type_id=:type_id', { type_id: type_id });
            query.andWhere('l.date=:date', { date: date_now });
            query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                if (alarm_status) {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                        alarm_status: alarm_status,
                    };
                }
                else {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                    };
                }
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogmqttRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async update_alarmprocesslogtemp(dto) {
        var id = dto.id;
        var DataUpdate = {};
        if (dto.event != '') {
            DataUpdate.event = dto.event;
        }
        if (dto.alarm_type != '') {
            DataUpdate.alarm_type = dto.alarm_type;
        }
        if (dto.status_warning != '') {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.recovery_warning != '') {
            DataUpdate.recovery_warning = dto.recovery_warning;
        }
        if (dto.status_alert != '') {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.recovery_alert != '') {
            DataUpdate.recovery_alert = dto.recovery_alert;
        }
        if (dto.email_alarm != '') {
            DataUpdate.email_alarm = dto.email_alarm;
        }
        if (dto.line_alarm != '') {
            DataUpdate.line_alarm = dto.line_alarm;
        }
        if (dto.telegram_alarm != '') {
            DataUpdate.telegram_alarm = dto.telegram_alarm;
        }
        if (dto.sms_alarm != '') {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.nonc_alarm != '') {
            DataUpdate.nonc_alarm = dto.nonc_alarm;
        }
        if (dto.status != '') {
            DataUpdate.status = dto.status;
        }
        if (dto.time != '') {
            DataUpdate.time = dto.time;
        }
        if (dto.data != '') {
            DataUpdate.data = dto.data;
        }
        if (dto.alarm_status != '') {
            DataUpdate.alarm_status = dto.alarm_status;
        }
        if (dto.subject != '') {
            DataUpdate.subject = dto.subject;
        }
        if (dto.content != '') {
            DataUpdate.content = dto.content;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        await this.alarmprocesslogRepository
            .createQueryBuilder()
            .update('sd_alarm_process_log_temp')
            .set(DataUpdate)
            .where('alarm_action_id=:alarm_action_id', {
            alarm_action_id: dto.alarm_action_id,
        })
            .andWhere('device_id =:device_id', { device_id: dto.device_id })
            .andWhere('type_id =:type_id', { type_id: dto.type_id })
            .andWhere('data_alarm =:data_alarm', { data_alarm: dto.data_alarm })
            .andWhere('date =:date', { date: dto.date })
            .execute();
        return 200;
    }
    async count_alarmprocesslogtemp(dto) {
        console.log(`count_alarmprocesslogdto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            var status = dto.status;
            const query = await this.alarmprocesslogtempRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async get_alarmprocesslogtemp(alarm_action_id) {
        try {
            const rs = await this.alarmprocesslogtempRepository.findOne({
                where: {
                    alarm_action_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async alarm_processlog_page_temp(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.alarmprocesslogtempRepository.createQueryBuilder('lg');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT lg.id)', 'cnt');
            }
            else {
                query.select([
                    'lg.*',
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'sad.alarm_action_id AS alarm_action_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS timelife',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                ]);
            }
            query.innerJoin('sd_iot_alarm_device', 'sad', 'sad.device_id= lg.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= lg.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            query.andWhere('lg.alarm_status=1');
            if (dto.alarm_action_id) {
                query.andWhere('lg.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('lg.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.alarm_type) {
                query.andWhere('lg.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('lg.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('lg.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('lg.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('lg.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('lg.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('lg.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('lg.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.keyword) {
                query.andWhere('d.device_name like :device_name', {
                    device_name: keyword ? `%${dto.keyword}%` : '%',
                });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.schedule_id) {
                query.andWhere('lg.schedule_id=:schedule_id', {
                    schedule_id: dto.schedule_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('lg.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.schedule_event_start) {
                query.andWhere('lg.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: dto.schedule_event_start,
                });
            }
            if (dto.day) {
                query.andWhere('lg.day=:day', { day: dto.day });
            }
            if (dto.doday) {
                query.andWhere('lg.doday=:doday', { doday: dto.doday });
            }
            if (dto.dotime) {
                query.andWhere('lg.dotime=:dotime', { dotime: dto.dotime });
            }
            if (dto.schedule_event) {
                query.andWhere('lg.schedule_event=:schedule_event', {
                    schedule_event: dto.schedule_event,
                });
            }
            if (dto.device_status) {
                query.andWhere('lg.device_status=:device_status', {
                    device_status: dto.device_status,
                });
            }
            if (dto.status) {
                query.andWhere('lg.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('lg.createddate', 'DESC');
            query.addOrderBy('lg.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_processlog_page_temp_control(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.alarmprocesslogtempRepository.createQueryBuilder('lg');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT lg.id)', 'cnt');
            }
            else {
                query.select([
                    'lg.*',
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'sad.alarm_action_id AS alarm_action_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS timelife',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                ]);
            }
            query.innerJoin('sd_iot_alarm_device_event', 'sad', 'sad.device_id= lg.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= lg.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            query.andWhere('lg.alarm_status=2');
            if (dto.alarm_action_id) {
                query.andWhere('lg.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('lg.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.alarm_type) {
                query.andWhere('lg.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('lg.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('lg.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('lg.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('lg.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('lg.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('lg.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('lg.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.keyword) {
                query.andWhere('d.device_name like :device_name', {
                    device_name: keyword ? `%${dto.keyword}%` : '%',
                });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.schedule_id) {
                query.andWhere('lg.schedule_id=:schedule_id', {
                    schedule_id: dto.schedule_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('lg.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.schedule_event_start) {
                query.andWhere('lg.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: dto.schedule_event_start,
                });
            }
            if (dto.day) {
                query.andWhere('lg.day=:day', { day: dto.day });
            }
            if (dto.doday) {
                query.andWhere('lg.doday=:doday', { doday: dto.doday });
            }
            if (dto.dotime) {
                query.andWhere('lg.dotime=:dotime', { dotime: dto.dotime });
            }
            if (dto.schedule_event) {
                query.andWhere('lg.schedule_event=:schedule_event', {
                    schedule_event: dto.schedule_event,
                });
            }
            if (dto.device_status) {
                query.andWhere('lg.device_status=:device_status', {
                    device_status: dto.device_status,
                });
            }
            if (dto.status) {
                query.andWhere('lg.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('lg.createddate', 'DESC');
            query.addOrderBy('lg.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarmprocesslogtemp(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogtempRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async create_alarmprocesslogemail(dto) {
        console.log('dto=>');
        console.info(dto);
        const result = await this.alarmprocesslogemailRepository.save(this.alarmprocesslogemailRepository.create(dto));
        return result;
    }
    async update_alarmprocesslogemail(dto) {
        var id = dto.id;
        var DataUpdate = {};
        if (dto.event != '') {
            DataUpdate.event = dto.event;
        }
        if (dto.alarm_type != '') {
            DataUpdate.alarm_type = dto.alarm_type;
        }
        if (dto.status_warning != '') {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.recovery_warning != '') {
            DataUpdate.recovery_warning = dto.recovery_warning;
        }
        if (dto.status_alert != '') {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.recovery_alert != '') {
            DataUpdate.recovery_alert = dto.recovery_alert;
        }
        if (dto.email_alarm != '') {
            DataUpdate.email_alarm = dto.email_alarm;
        }
        if (dto.line_alarm != '') {
            DataUpdate.line_alarm = dto.line_alarm;
        }
        if (dto.telegram_alarm != '') {
            DataUpdate.telegram_alarm = dto.telegram_alarm;
        }
        if (dto.sms_alarm != '') {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.nonc_alarm != '') {
            DataUpdate.nonc_alarm = dto.nonc_alarm;
        }
        if (dto.status != '') {
            DataUpdate.status = dto.status;
        }
        if (dto.time != '') {
            DataUpdate.time = dto.time;
        }
        if (dto.data != '') {
            DataUpdate.data = dto.data;
        }
        if (dto.alarm_status != '') {
            DataUpdate.alarm_status = dto.alarm_status;
        }
        if (dto.subject != '') {
            DataUpdate.subject = dto.subject;
        }
        if (dto.content != '') {
            DataUpdate.content = dto.content;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        await this.alarmprocesslogRepository
            .createQueryBuilder()
            .update('sd_alarm_process_log_email')
            .set(DataUpdate)
            .where('alarm_action_id=:alarm_action_id', {
            alarm_action_id: dto.alarm_action_id,
        })
            .andWhere('device_id =:device_id', { device_id: dto.device_id })
            .andWhere('type_id =:type_id', { type_id: dto.type_id })
            .andWhere('data_alarm =:data_alarm', { data_alarm: dto.data_alarm })
            .andWhere('date =:date', { date: dto.date })
            .execute();
        return 200;
    }
    async chk_alarmprocesslog_email(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async delete_alarmprocesslog_email(dto) {
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.andWhere('l.device_id=:device_id', { device_id: device_id });
            query.andWhere('l.alarm_action_id=:alarm_action_id', {
                alarm_action_id: alarm_action_id,
            });
            query.andWhere('l.type_id=:type_id', { type_id: type_id });
            if (date_now) {
                query.andWhere('l.date=:date', { date: date_now });
            }
            if (data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            }
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                if (date_now) {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                    };
                }
                else {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                    };
                }
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogemailRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async delete_alarmprocesslog_email_al(dto) {
        try {
            console.log(`----delete_alarmprocesslogemail---`);
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            if (device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: device_id });
            }
            if (alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: type_id });
            }
            if (date_now) {
                query.andWhere('l.date=:date', { date: date_now });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            }
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                var criteria = {
                    device_id: device_id,
                    alarm_action_id: alarm_action_id,
                    type_id: type_id,
                };
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogemailRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                var rt = parseInt('1');
                return rt;
            }
            else {
                var rt = parseInt('0');
                return rt;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async count_alarmprocesslogemail(dto) {
        console.log(`count_alarmprocesslogdto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            var status = dto.status;
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async get_alarmprocesslogemail(alarm_action_id) {
        try {
            const rs = await this.alarmprocesslogemailRepository.findOne({
                where: {
                    alarm_action_id,
                },
            });
            return rs;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async alarm_proce_log_page_email(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('lg');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT lg.id)', 'cnt');
            }
            else {
                query.select([
                    'lg.*',
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'sad.alarm_action_id AS alarm_action_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS timelife',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                ]);
            }
            query.innerJoin('sd_iot_alarm_device', 'sad', 'sad.device_id= lg.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= lg.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            query.andWhere('lg.alarm_status=1');
            if (dto.alarm_action_id) {
                query.andWhere('lg.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('lg.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.alarm_type) {
                query.andWhere('lg.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('lg.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('lg.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('lg.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('lg.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('lg.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('lg.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('lg.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.keyword) {
                query.andWhere('d.device_name like :device_name', {
                    device_name: keyword ? `%${dto.keyword}%` : '%',
                });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.schedule_id) {
                query.andWhere('lg.schedule_id=:schedule_id', {
                    schedule_id: dto.schedule_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('lg.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.schedule_event_start) {
                query.andWhere('lg.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: dto.schedule_event_start,
                });
            }
            if (dto.day) {
                query.andWhere('lg.day=:day', { day: dto.day });
            }
            if (dto.doday) {
                query.andWhere('lg.doday=:doday', { doday: dto.doday });
            }
            if (dto.dotime) {
                query.andWhere('lg.dotime=:dotime', { dotime: dto.dotime });
            }
            if (dto.schedule_event) {
                query.andWhere('lg.schedule_event=:schedule_event', {
                    schedule_event: dto.schedule_event,
                });
            }
            if (dto.device_status) {
                query.andWhere('lg.device_status=:device_status', {
                    device_status: dto.device_status,
                });
            }
            if (dto.status) {
                query.andWhere('lg.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('lg.createddate', 'DESC');
            query.addOrderBy('lg.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_proce_log_paging_email(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('lg');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT lg.id)', 'cnt');
            }
            else {
                query.select([
                    'lg.*',
                    'd.device_id AS device_id',
                    'd.mqtt_id AS mqtt_id',
                    'd.setting_id AS setting_id',
                    'sad.alarm_action_id AS alarm_action_id',
                    'd.type_id AS type_id',
                    'd.device_name AS device_name',
                    'd.sn AS sn',
                    'd.hardware_id AS hardware_id',
                    'd.status_warning AS status_warning',
                    'd.recovery_warning AS recovery_warning',
                    'd.status_alert AS status_alert',
                    'd.recovery_alert AS recovery_alert',
                    'd.time_life AS timelife',
                    'd.period AS period',
                    'd.work_status AS work_status',
                    'd.*',
                    'd.oid AS oid',
                    'd.mqtt_data_value AS mqtt_data_value',
                    'd.mqtt_data_control AS mqtt_data_control',
                    'd.model AS model',
                    'd.vendor AS vendor',
                    'd.comparevalue AS comparevalue',
                    'd.createddate AS createddate',
                    'd.updateddate AS updateddate',
                    'd.status AS status',
                    'd.unit AS unit',
                    'd.action_id AS action_id',
                    'd.status_alert_id AS status_alert_id',
                    'd.measurement AS measurement',
                    'd.mqtt_control_on AS mqtt_control_on',
                    'd.mqtt_control_off AS mqtt_control_off',
                    'd.org AS device_org',
                    'd.bucket AS device_bucket',
                    't.type_name AS type_name',
                    'l.location_name AS location_name',
                    'l.configdata AS configdata',
                    'mq.mqtt_name AS mqtt_name',
                    'mq.org AS mqtt_org',
                    'mq.bucket AS mqtt_bucket',
                    'mq.envavorment AS mqtt_envavorment',
                    'mq.host AS mqtt_host',
                    'mq.port AS mqtt_port',
                    'd.mqtt_device_name AS mqtt_device_name',
                    'd.mqtt_status_over_name AS mqtt_status_over_name',
                    'd.mqtt_status_data_name AS mqtt_status_data_name',
                    'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                    'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                    'alarm.alarm_action_id AS alarm_action_id',
                    'alarm.action_name AS action_name',
                    'alarm.status_warning AS status_warning',
                    'alarm.recovery_warning AS recovery_warning',
                    'alarm.status_alert AS status_alert',
                    'alarm.recovery_alert AS recovery_alert',
                    'alarm.email_alarm AS email_alarm',
                    'alarm.line_alarm AS line_alarm',
                    'alarm.telegram_alarm AS telegram_alarm',
                    'alarm.sms_alarm AS sms_alarm',
                    'alarm.nonc_alarm AS nonc_alarm',
                    'alarm.time_life AS time_life',
                    'alarm.event AS event',
                    'alarm.status AS status',
                ]);
            }
            query.innerJoin('sd_iot_alarm_device_event', 'sad', 'sad.device_id= lg.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= lg.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            query.andWhere('lg.alarm_status=2');
            if (dto.alarm_action_id) {
                query.andWhere('lg.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('lg.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.alarm_type) {
                query.andWhere('lg.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('lg.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('lg.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('lg.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('lg.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('lg.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('lg.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('lg.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.keyword) {
                query.andWhere('d.device_name like :device_name', {
                    device_name: keyword ? `%${dto.keyword}%` : '%',
                });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.schedule_id) {
                query.andWhere('lg.schedule_id=:schedule_id', {
                    schedule_id: dto.schedule_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('lg.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.schedule_event_start) {
                query.andWhere('lg.schedule_event_start=:schedule_event_start', {
                    schedule_event_start: dto.schedule_event_start,
                });
            }
            if (dto.day) {
                query.andWhere('lg.day=:day', { day: dto.day });
            }
            if (dto.doday) {
                query.andWhere('lg.doday=:doday', { doday: dto.doday });
            }
            if (dto.dotime) {
                query.andWhere('lg.dotime=:dotime', { dotime: dto.dotime });
            }
            if (dto.schedule_event) {
                query.andWhere('lg.schedule_event=:schedule_event', {
                    schedule_event: dto.schedule_event,
                });
            }
            if (dto.device_status) {
                query.andWhere('lg.device_status=:device_status', {
                    device_status: dto.device_status,
                });
            }
            if (dto.status) {
                query.andWhere('lg.status=:status', { status: dto.status });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('lg.createddate', 'DESC');
            query.addOrderBy('lg.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarmprocesslogemail(dto) {
        console.log(`chk_alarmprocesslogemail dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('l');
            query.select(['l.*']);
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            console.log(`chk_alarmprocesslogemail count =>` + count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            var rss = await query.getRawMany();
            console.log('chk_alarmprocesslogemail query.getRawMany()=>');
            console.info(rss);
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarmprocesslogemail_count(dto) {
        console.log(`chk_alarmprocesslogemail dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`chk_alarmprocesslogemail count =>` + count);
            console.log(`chk_alarmprocesslogemail tempCountt.count =>`);
            console.info(tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            var rss = await query.getRawMany();
            console.log('query.getRawMany()=>');
            console.info(rss);
            console.log('count=>');
            console.info(count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async delete_alarmp_emaillog(dto) {
        try {
            console.log(`----delete_alarmprocesslogemail---`);
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            if (dto.id) {
                query.andWhere('l.id=:id', { id: dto.id });
            }
            if (device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: device_id });
            }
            if (alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: type_id });
            }
            if (date_now) {
                query.andWhere('l.date=:date', { date: date_now });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            }
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const criteria = {};
                criteria.alarm_action_id = alarm_action_id;
                if (dto.id) {
                    query.andWhere('l.id=:id', { id: dto.id });
                }
                if (device_id) {
                    criteria.device_id = device_id;
                }
                if (type_id) {
                    criteria.type_id = type_id;
                }
                if (alarm_status) {
                    criteria.alarm_status = alarm_status;
                }
                if (dto.event) {
                    criteria.event = dto.event;
                }
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogemailRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                var rt = parseInt('1');
                return rt;
            }
            else {
                var rt = parseInt('0');
                return rt;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async alarm_device_active_map(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var type_id = dto.type_id;
            var alarm_action_id = dto.alarm_action_id;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS time_life',
                'd.period AS period',
                'd.work_status AS work_status',
                'd.*',
                'd.oid AS oid',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.measurement AS measurement',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.bucket AS device_bucket',
                'ar.alarm_action_id AS alarm_action_id',
                'arc.action_name AS action_name',
                'arc.time_life AS time_life',
            ]);
            query.innerJoin('sd_iot_alarm_device', 'ar', 'ar.device_id= d.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'arc', 'arc.alarm_action_id= ar.alarm_action_id');
            query.where('1=1');
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('arc.status=:status', { status: status });
            if (device_id) {
                query.andWhere('ar.device_id=:device_id', { device_id: device_id });
            }
            if (dto.alarm_action_id) {
                query.andWhere('ar.alarm_action_id =:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id =:type_id', { type_id: dto.type_id });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy('d.device_id', 'ASC');
            query.addOrderBy('arc.alarm_action_id', 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async sd_iot_alarm_device_list_map(dto) {
        console.log(`device_list_paginate_active dto=`);
        console.info(dto);
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var mqtt_id = dto.mqtt_id;
            var keyword = dto.keyword || '';
            var createddate = dto.createddate;
            var updateddate = dto.updateddate;
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'd.device_id AS device_id',
                'd.mqtt_id AS mqtt_id',
                'd.setting_id AS setting_id',
                'sad.alarm_action_id AS alarm_action_id',
                'd.type_id AS type_id',
                'd.device_name AS device_name',
                'd.hardware_id AS hardware_id',
                'd.status_warning AS status_warning',
                'd.recovery_warning AS recovery_warning',
                'd.status_alert AS status_alert',
                'd.recovery_alert AS recovery_alert',
                'd.time_life AS timelife',
                'd.period AS period',
                'd.mqtt_data_value AS mqtt_data_value',
                'd.mqtt_data_control AS mqtt_data_control',
                'd.model AS model',
                'd.comparevalue AS comparevalue',
                'd.createddate AS createddate',
                'd.updateddate AS updateddate',
                'd.status AS status',
                'd.unit AS unit',
                'd.action_id AS action_id',
                'd.status_alert_id AS status_alert_id',
                'd.mqtt_control_on AS mqtt_control_on',
                'd.mqtt_control_off AS mqtt_control_off',
                'd.org AS device_org',
                'd.bucket AS device_bucket',
                't.type_name AS type_name',
                'l.location_name AS location_name',
                'l.location_id AS location_id',
                'l.configdata AS configdata',
                'mq.mqtt_name AS mqtt_name',
                'mq.org AS mqtt_org',
                'mq.bucket AS mqtt_bucket',
                'mq.envavorment AS mqtt_envavorment',
                'mq.host AS mqtt_host',
                'mq.port AS mqtt_port',
                'd.mqtt_device_name AS mqtt_device_name',
                'd.mqtt_status_over_name AS mqtt_status_over_name',
                'd.mqtt_status_data_name AS mqtt_status_data_name',
                'd.mqtt_act_relay_name AS mqtt_act_relay_name',
                'd.mqtt_control_relay_name AS mqtt_control_relay_name',
                'alarm.alarm_action_id AS alarm_action_id',
                'alarm.action_name AS action_name',
                'alarm.status_warning AS status_warning',
                'alarm.recovery_warning AS recovery_warning',
                'alarm.status_alert AS status_alert',
                'alarm.recovery_alert AS recovery_alert',
                'alarm.email_alarm AS email_alarm',
                'alarm.line_alarm AS line_alarm',
                'alarm.telegram_alarm AS telegram_alarm',
                'alarm.sms_alarm AS sms_alarm',
                'alarm.nonc_alarm AS nonc_alarm',
                'alarm.time_life AS time_life',
                'alarm.event AS event',
                'alarm.status AS status',
            ]);
            query.innerJoin('sd_iot_alarm_device', 'sad', 'sad.device_id= d.device_id');
            query.innerJoin('sd_iot_device_alarm_action', 'alarm', 'alarm.alarm_action_id= sad.alarm_action_id');
            query.innerJoin('sd_iot_setting', 'st', 'st.setting_id= d.setting_id');
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_mqtt', 'mq', 'mq.mqtt_id = d.mqtt_id');
            query.innerJoin('sd_iot_location', 'l', 'l.location_id= mq.location_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('d.keyword LIKE :keyword', { keyword: `%${keyword}%` });
            }
            var status = 1;
            query.andWhere('d.status=:status', { status: status });
            query.andWhere('mq.status=:status', { status: status });
            query.andWhere('alarm.status=:status', { status: status });
            if (alarm_action_id) {
                query.andWhere('sad.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: alarm_action_id,
                });
            }
            if (device_id) {
                query.andWhere('d.device_id=:device_id', { device_id: device_id });
            }
            if (dto.bucket) {
                query.andWhere('d.bucket =:bucket', { bucket: dto.bucket });
            }
            if (mqtt_id) {
                query.andWhere('d.mqtt_id=:mqtt_id', { mqtt_id: mqtt_id });
            }
            if (dto.org) {
                query.andWhere('d.org=:org', { org: dto.org });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            if (dto.type_id) {
                query.andWhere('d.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.location_id) {
                query.andWhere('st.location_id=:location_id', {
                    location_id: dto.location_id,
                });
            }
            if (dto.sn) {
                query.andWhere('d.sn=:sn', { sn: dto.sn });
            }
            if (dto.status_warning) {
                query.andWhere('d.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('d.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('d.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('d.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.time_life) {
                query.andWhere('d.time_life=:time_life', { time_life: dto.time_life });
            }
            if (dto.period) {
                query.andWhere('d.period=:period', { period: dto.period });
            }
            if (dto.max) {
                query.andWhere('d.max=:max', { max: dto.max });
            }
            if (dto.min) {
                query.andWhere('d.min=:min', { min: dto.min });
            }
            if (dto.hardware_id) {
                query.andWhere('d.hardware_id=:hardware_id', {
                    hardware_id: dto.hardware_id,
                });
            }
            if (dto.model) {
                query.andWhere('d.model=::model', { model: dto.model });
            }
            if (dto.vendor) {
                query.andWhere('d.vendor=:vendor', { vendor: dto.vendor });
            }
            if (dto.comparevalue) {
                query.andWhere('d.comparevalue=:comparevalue', {
                    comparevalue: dto.comparevalue,
                });
            }
            if (dto.oid) {
                query.andWhere('d.oid=:oid', { oid: dto.oid });
            }
            if (dto.action_id) {
                query.andWhere('d.action_id=:action_id', { action_id: dto.action_id });
            }
            if (dto.mqtt_data_value) {
                query.andWhere('d.mqtt_data_value=:mqtt_data_value', {
                    mqtt_data_value: dto.mqtt_data_value,
                });
            }
            if (dto.mqtt_data_control) {
                query.andWhere('d.mqtt_data_control=:mqtt_data_control', {
                    mqtt_data_control: dto.mqtt_data_control,
                });
            }
            if (createddate) {
                query.andWhere('d.createddate=:createddate', {
                    createddate: createddate,
                });
            }
            if (updateddate) {
                query.andWhere('d.updateddate=:updateddate', {
                    updateddate: updateddate,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            query.orderBy('mq.sort', 'ASC');
            query.addOrderBy('d.device_id', 'ASC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async count_alarmprocesslogline(dto) {
        console.log(`count_dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            var status = dto.status;
            const query = await this.alarmprocessloglineRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarmprocesslogline(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocessloglineRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async create_alarmprocesslogline(dto) {
        console.log('dto=>');
        console.info(dto);
        const result = await this.alarmprocessloglineRepository.save(this.alarmprocessloglineRepository.create(dto));
        return result;
    }
    async update_larmprocesslogline(dto) {
        var id = dto.id;
        var DataUpdate = {};
        if (dto.event != '') {
            DataUpdate.event = dto.event;
        }
        if (dto.alarm_type != '') {
            DataUpdate.alarm_type = dto.alarm_type;
        }
        if (dto.status_warning != '') {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.recovery_warning != '') {
            DataUpdate.recovery_warning = dto.recovery_warning;
        }
        if (dto.status_alert != '') {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.recovery_alert != '') {
            DataUpdate.recovery_alert = dto.recovery_alert;
        }
        if (dto.email_alarm != '') {
            DataUpdate.email_alarm = dto.email_alarm;
        }
        if (dto.line_alarm != '') {
            DataUpdate.line_alarm = dto.line_alarm;
        }
        if (dto.telegram_alarm != '') {
            DataUpdate.telegram_alarm = dto.telegram_alarm;
        }
        if (dto.sms_alarm != '') {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.nonc_alarm != '') {
            DataUpdate.nonc_alarm = dto.nonc_alarm;
        }
        if (dto.status != '') {
            DataUpdate.status = dto.status;
        }
        if (dto.time != '') {
            DataUpdate.time = dto.time;
        }
        if (dto.data != '') {
            DataUpdate.data = dto.data;
        }
        if (dto.alarm_status != '') {
            DataUpdate.alarm_status = dto.alarm_status;
        }
        if (dto.subject != '') {
            DataUpdate.subject = dto.subject;
        }
        if (dto.content != '') {
            DataUpdate.content = dto.content;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        await this.alarmprocesslogRepository
            .createQueryBuilder()
            .update('sd_alarm_process_log_line')
            .set(DataUpdate)
            .where('alarm_action_id=:alarm_action_id', {
            alarm_action_id: dto.alarm_action_id,
        })
            .andWhere('device_id =:device_id', { device_id: dto.device_id })
            .andWhere('type_id =:type_id', { type_id: dto.type_id })
            .andWhere('data_alarm =:data_alarm', { data_alarm: dto.data_alarm })
            .andWhere('date =:date', { date: dto.date })
            .execute();
        return 200;
    }
    async delete_alarmprocesslog_line(dto) {
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocessloglineRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.andWhere('l.device_id=:device_id', { device_id: device_id });
            query.andWhere('l.alarm_action_id=:alarm_action_id', {
                alarm_action_id: alarm_action_id,
            });
            query.andWhere('l.type_id=:type_id', { type_id: type_id });
            query.andWhere('l.date=:date', { date: date_now });
            query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                if (alarm_status) {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                        alarm_status: alarm_status,
                    };
                }
                else {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                    };
                }
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocessloglineRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async count_alarmprocesslogsms(dto) {
        console.log(`count_dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            var status = dto.status;
            const query = await this.alarmprocesslogsmsRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarmprocesslogsms(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogsmsRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async create_alarmprocesslogsms(dto) {
        console.log('dto=>');
        console.info(dto);
        const result = await this.alarmprocesslogsmsRepository.save(this.alarmprocesslogsmsRepository.create(dto));
        return result;
    }
    async update_larmprocesslogsms(dto) {
        var id = dto.id;
        var DataUpdate = {};
        if (dto.event != '') {
            DataUpdate.event = dto.event;
        }
        if (dto.alarm_type != '') {
            DataUpdate.alarm_type = dto.alarm_type;
        }
        if (dto.status_warning != '') {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.recovery_warning != '') {
            DataUpdate.recovery_warning = dto.recovery_warning;
        }
        if (dto.status_alert != '') {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.recovery_alert != '') {
            DataUpdate.recovery_alert = dto.recovery_alert;
        }
        if (dto.email_alarm != '') {
            DataUpdate.email_alarm = dto.email_alarm;
        }
        if (dto.sms_alarm != '') {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.telegram_alarm != '') {
            DataUpdate.telegram_alarm = dto.telegram_alarm;
        }
        if (dto.sms_alarm != '') {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.nonc_alarm != '') {
            DataUpdate.nonc_alarm = dto.nonc_alarm;
        }
        if (dto.status != '') {
            DataUpdate.status = dto.status;
        }
        if (dto.time != '') {
            DataUpdate.time = dto.time;
        }
        if (dto.data != '') {
            DataUpdate.data = dto.data;
        }
        if (dto.alarm_status != '') {
            DataUpdate.alarm_status = dto.alarm_status;
        }
        if (dto.subject != '') {
            DataUpdate.subject = dto.subject;
        }
        if (dto.content != '') {
            DataUpdate.content = dto.content;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        await this.alarmprocesslogRepository
            .createQueryBuilder()
            .update('sd_alarm_process_log_sms')
            .set(DataUpdate)
            .where('alarm_action_id=:alarm_action_id', {
            alarm_action_id: dto.alarm_action_id,
        })
            .andWhere('device_id =:device_id', { device_id: dto.device_id })
            .andWhere('type_id =:type_id', { type_id: dto.type_id })
            .andWhere('data_alarm =:data_alarm', { data_alarm: dto.data_alarm })
            .andWhere('date =:date', { date: dto.date })
            .execute();
        return 200;
    }
    async delete_alarmprocesslog_sms(dto) {
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogsmsRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.andWhere('l.device_id=:device_id', { device_id: device_id });
            query.andWhere('l.alarm_action_id=:alarm_action_id', {
                alarm_action_id: alarm_action_id,
            });
            query.andWhere('l.type_id=:type_id', { type_id: type_id });
            query.andWhere('l.date=:date', { date: date_now });
            query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                if (alarm_status) {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                        alarm_status: alarm_status,
                    };
                }
                else {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                    };
                }
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogsmsRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async count_alarmprocesslogtelegram(dto) {
        console.log(`count_dto=`);
        console.info(dto);
        try {
            var schedule_id = dto.schedule_id;
            var device_id = dto.device_id;
            var schedule_event_start = dto.schedule_event_start;
            var day = dto.day;
            var doday = dto.doday;
            var dotime = dto.dotime;
            var schedule_event = dto.schedule_event;
            var device_status = dto.device_status;
            var status = dto.status;
            const query = await this.alarmprocesslogtelegramRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.id)', 'cnt');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            return count;
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async chk_alarmprocesslogtelegram(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogtelegramRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async create_alarmprocesslogtelegram(dto) {
        console.log('dto=>');
        console.info(dto);
        const result = await this.alarmprocesslogtelegramRepository.save(this.alarmprocesslogtelegramRepository.create(dto));
        return result;
    }
    async update_larmprocesslogtelegram(dto) {
        var id = dto.id;
        var DataUpdate = {};
        if (dto.event != '') {
            DataUpdate.event = dto.event;
        }
        if (dto.alarm_type != '') {
            DataUpdate.alarm_type = dto.alarm_type;
        }
        if (dto.status_warning != '') {
            DataUpdate.status_warning = dto.status_warning;
        }
        if (dto.recovery_warning != '') {
            DataUpdate.recovery_warning = dto.recovery_warning;
        }
        if (dto.status_alert != '') {
            DataUpdate.status_alert = dto.status_alert;
        }
        if (dto.recovery_alert != '') {
            DataUpdate.recovery_alert = dto.recovery_alert;
        }
        if (dto.email_alarm != '') {
            DataUpdate.email_alarm = dto.email_alarm;
        }
        if (dto.sms_alarm != '') {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.telegram_alarm != '') {
            DataUpdate.telegram_alarm = dto.telegram_alarm;
        }
        if (dto.sms_alarm != '') {
            DataUpdate.sms_alarm = dto.sms_alarm;
        }
        if (dto.nonc_alarm != '') {
            DataUpdate.nonc_alarm = dto.nonc_alarm;
        }
        if (dto.status != '') {
            DataUpdate.status = dto.status;
        }
        if (dto.time != '') {
            DataUpdate.time = dto.time;
        }
        if (dto.data != '') {
            DataUpdate.data = dto.data;
        }
        if (dto.alarm_status != '') {
            DataUpdate.alarm_status = dto.alarm_status;
        }
        if (dto.subject != '') {
            DataUpdate.subject = dto.subject;
        }
        if (dto.content != '') {
            DataUpdate.content = dto.content;
        }
        const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm';
        const updateddate = moment(new Date(), DATE_TIME_FORMAT);
        DataUpdate.updateddate = Date();
        await this.alarmprocesslogRepository
            .createQueryBuilder()
            .update('sd_alarm_process_log_telegram')
            .set(DataUpdate)
            .where('alarm_action_id=:alarm_action_id', {
            alarm_action_id: dto.alarm_action_id,
        })
            .andWhere('device_id =:device_id', { device_id: dto.device_id })
            .andWhere('type_id =:type_id', { type_id: dto.type_id })
            .andWhere('data_alarm =:data_alarm', { data_alarm: dto.data_alarm })
            .andWhere('date =:date', { date: dto.date })
            .execute();
        return 200;
    }
    async delete_alarmprocesslog_telegram(dto) {
        try {
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogtelegramRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.andWhere('l.device_id=:device_id', { device_id: device_id });
            query.andWhere('l.alarm_action_id=:alarm_action_id', {
                alarm_action_id: alarm_action_id,
            });
            query.andWhere('l.type_id=:type_id', { type_id: type_id });
            query.andWhere('l.date=:date', { date: date_now });
            query.andWhere('l.data_alarm=:data_alarm', { data_alarm: data_alarm });
            if (alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                if (alarm_status) {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                        alarm_status: alarm_status,
                    };
                }
                else {
                    var criteria = {
                        device_id: device_id,
                        alarm_action_id: alarm_action_id,
                        type_id: type_id,
                        date: date_now,
                        data_alarm: data_alarm,
                    };
                }
                console.log(`Attempting to delete record with criteria:`, criteria);
                const deleteResult = await this.alarmprocesslogtelegramRepository.delete(criteria);
                if (deleteResult.affected && deleteResult.affected > 0) {
                    console.log(`Successfully deleted ${deleteResult.affected} record(s).`);
                }
                else {
                    console.log('No records found matching the criteria. Nothing was deleted.');
                }
                return deleteResult;
            }
            else {
                return null;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async useractiveemail(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const isCount = 0;
            const active_status = 1;
            var status = '1';
            const query = await this.userRepository.createQueryBuilder('u');
            if (isCount == 1) {
                var countRs = await query.getCount(['u.id AS uid']);
            }
            else {
                query.select([
                    'u.role_id as role_id',
                    'u.email as email',
                    'u.username as username',
                    'u.public_notification as public_notification',
                    'u.sms_notification as sms_notification',
                    'u.email_notification as email_notification',
                    'u.line_notification as line_notification',
                    'u.mobile_number as mobile_number',
                    'u.phone_number as phone_number',
                    'u.lineid as lineid',
                ]);
            }
            query.where('1=1');
            query.andWhere('u.email_notification=:email_notification', {
                email_notification: active_status,
            });
            if (active_status) {
                query.andWhere('u.active_status=:active_status', {
                    active_status: active_status,
                });
                query.andWhere('u.status IN(:...status)', { status: [1] });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                query.orderBy(`u.createddate`, 'ASC');
                var rs = await query.getRawMany();
                console.log(`rs =>` + rs);
                return rs;
            }
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: JSON.stringify(error) },
                },
            });
        }
    }
    async useractivesms(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const isCount = 0;
            const active_status = 1;
            var status = '1';
            const query = await this.userRepository.createQueryBuilder('u');
            if (isCount == 1) {
                var countRs = await query.getCount(['u.id AS uid']);
            }
            else {
                query.select([
                    'u.role_id',
                    'u.email',
                    'u.username',
                    'u.firstname',
                    'u.lastname',
                    'u.fullname',
                    'u.nickname',
                    'u.status',
                    'u.active_status',
                    'u.network_id',
                    'u.infomation_agree_status',
                    'u.online_status',
                    'u.network_type_id',
                    'u.public_status',
                    'u.type_id',
                    'u.public_notification',
                    'u.sms_notification',
                    'u.email_notification',
                    'u.line_notification',
                    'u.mobile_number',
                    'u.phone_number',
                    'u.lineid',
                ]);
            }
            query.where('1=1');
            query.andWhere('u.sms_notification=:sms_notification', {
                sms_notification: active_status,
            });
            if (active_status) {
                query.andWhere('u.active_status=:active_status', {
                    active_status: active_status,
                });
                query.andWhere('u.status IN(:...status)', { status: [1] });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                query.orderBy(`u.createddate`, 'ASC');
                var rs = await query.getRawMany();
                console.log(`rs =>` + rs);
                return rs;
            }
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: JSON.stringify(error) },
                },
            });
        }
    }
    async useractiveline(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const isCount = 0;
            const active_status = 1;
            var status = '1';
            const query = await this.userRepository.createQueryBuilder('u');
            if (isCount == 1) {
                var countRs = await query.getCount(['u.id AS uid']);
            }
            else {
                query.select([
                    'u.role_id',
                    'u.email',
                    'u.username',
                    'u.firstname',
                    'u.lastname',
                    'u.fullname',
                    'u.nickname',
                    'u.status',
                    'u.active_status',
                    'u.network_id',
                    'u.infomation_agree_status',
                    'u.online_status',
                    'u.network_type_id',
                    'u.public_status',
                    'u.type_id',
                    'u.public_notification',
                    'u.sms_notification',
                    'u.email_notification',
                    'u.line_notification',
                    'u.mobile_number',
                    'u.phone_number',
                    'u.lineid',
                ]);
            }
            query.where('1=1');
            query.andWhere('u.line_notification=:line_notification', {
                line_notification: active_status,
            });
            if (active_status) {
                query.andWhere('u.active_status=:active_status', {
                    active_status: active_status,
                });
                query.andWhere('u.status IN(:...status)', { status: [1] });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                query.orderBy(`u.createddate`, 'ASC');
                var rs = await query.getRawMany();
                console.log(`rs =>` + rs);
                return rs;
            }
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: JSON.stringify(error) },
                },
            });
        }
    }
    async listpaginateAdmin(dto) {
        console.log(`getProfile dto=`);
        console.info(dto);
        try {
            var idx = dto.idx || '';
            var keyword = dto.keyword || '';
            var status = dto.status || '1';
            var active_status = dto.active_status || '0,1';
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.userRepository.createQueryBuilder('u');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT u.id)', 'cnt');
            }
            else {
                query.select([
                    'DISTINCT u.id AS uid',
                    'u.role_id AS role_id',
                    'u.email AS email',
                    'u.username AS username',
                    'u.firstname AS firstname',
                    'u.lastname AS lastname',
                    'u.fullname AS fullname',
                    'u.nickname AS nickname',
                    'u.idcard AS idcard',
                    'u.lastsignindate AS lastsignindate',
                    'u.status AS status',
                    'u.active_status AS active_status',
                    'u.network_id AS network_id',
                    'u.remark AS remark',
                    'u.infomation_agree_status AS infomation_agree_status',
                    'u.gender AS gender',
                    'u.birthday AS birthday',
                    'u.online_status AS online_status',
                    'u.message AS message',
                    'u.network_type_id AS network_type_id',
                    'u.public_status AS public_status',
                    'u.type_id AS type_id',
                    'u.avatarpath AS avatarpath',
                    'u.avatar AS avatar',
                    'u.loginfailed AS loginFailed',
                    'u.createddate AS createddate',
                    'u.updateddate AS updateddate',
                    'u.deletedate AS deletedate',
                    'u.mobile_number AS mobile_number',
                    'u.lineid AS lineid',
                    'u.loginfailed AS loginfailed',
                    'u.public_notification AS public_notification',
                    'u.sms_notification AS sms_notification',
                    'u.email_notification AS email_notification',
                    'u.line_notification AS line_notification',
                    'u.mobile_number AS mobile_number',
                    'u.phone_number AS phone_number',
                    'role.title AS rolename',
                    'access.role_type_id AS role_type_id',
                    'permision.name  AS permision_name',
                    'permision.detail  AS permision_detail',
                    'permision.created  AS permision_created',
                    'permision.updated  AS permision_updated',
                    'permision.insert  AS permision_insert',
                    'permision.update  AS permision_update',
                    'permision.delete  AS permision_delete',
                    'permision.select  AS permision_select',
                    'permision.log  AS permision_log',
                    'permision.config  AS permision_config',
                    'permision.truncate  AS permision_truncate',
                ]);
            }
            query.innerJoin('sd_user_role', 'role', 'u.role_id = role.role_id');
            query.innerJoin('sd_user_roles_access', 'access', 'role.role_id = access.role_type_id');
            query.innerJoin('sd_user_roles_permision', 'permision', 'access.role_type_id = permision.role_type_id');
            query.where('1=1');
            if (keyword) {
                query.andWhere('u.username like :username', {
                    username: keyword ? `%${keyword}%` : '%',
                });
            }
            if (idx) {
                query.andWhere('u.id=:id', { id: idx });
            }
            if (status) {
                query.andWhere('u.status IN(:...status)', { status: [1] });
                const statusArray = status.split(',').map(Number);
                query.andWhere('u.status IN(:...status)', { status: statusArray });
            }
            if (active_status) {
                const statusArray = active_status.split(',').map(Number);
                query.andWhere('u.active_status IN(:...active_status)', {
                    active_status: statusArray,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`u.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`u.createddate`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async listpaginate(dto) {
        console.log(`getProfile dto=`);
        console.info(dto);
        try {
            var idx = dto.idx || '';
            var keyword = dto.keyword || '';
            var status = dto.status || '1';
            var active_status = dto.active_status || '0,1';
            var sort = dto.sort;
            var page = dto.page || 1;
            var pageSize = dto.pageSize || 10;
            var isCount = dto.isCount || 0;
            const query = await this.userRepository.createQueryBuilder('u');
            if (isCount == 1) {
                var countRs = await query.select('COUNT(DISTINCT u.id)', 'cnt');
            }
            else {
                query.select([
                    'u.id AS uid',
                    'u.role_id AS role_id',
                    'u.email AS email',
                    'u.username AS username',
                    'u.firstname AS firstname',
                    'u.lastname AS lastname',
                    'u.fullname AS fullname',
                    'u.nickname AS nickname',
                    'u.idcard AS idcard',
                    'u.lastsignindate AS lastsignindate',
                    'u.status AS status',
                    'u.active_status AS active_status',
                    'u.network_id AS network_id',
                    'u.remark AS remark',
                    'u.infomation_agree_status AS infomation_agree_status',
                    'u.gender AS gender',
                    'u.birthday AS birthday',
                    'u.online_status AS online_status',
                    'u.message AS message',
                    'u.network_type_id AS network_type_id',
                    'u.public_status AS public_status',
                    'u.type_id AS type_id',
                    'u.avatarpath AS avatarpath',
                    'u.avatar AS avatar',
                    'u.loginfailed AS loginFailed',
                    'u.createddate AS createddate',
                    'u.updateddate AS updateddate',
                    'u.deletedate AS deletedate',
                ]);
            }
            query.where('1=1');
            if (keyword) {
                query.andWhere('u.username like :username', {
                    username: keyword ? `%${keyword}%` : '%',
                });
            }
            if (idx) {
                query.andWhere('u.id=:id', { id: idx });
            }
            if (status) {
                const statusArray = status.split(',').map(Number);
                query.andWhere('u.status IN(:...status)', { status: statusArray });
            }
            if (active_status) {
                const statusArray = active_status.split(',').map(Number);
                query.andWhere('u.active_status IN(:...active_status)', {
                    active_status: statusArray,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                if (sort) {
                    const sortResult = (0, format_helper_1.convertSortInput)(sort);
                    if (sortResult == false) {
                        throw new common_1.BadRequestException(`Invalid sort option.`);
                    }
                    const { sortField, sortOrder } = sortResult;
                    console.log(`sort=`);
                    console.info(sort);
                    console.log(`sortField=` + sortField);
                    console.log(`sortOrder=` + sortOrder);
                    console.log(`sortResult=`);
                    console.info(sortResult);
                    if (sortOrder == 'ASC' || sortOrder == 'asc') {
                        var sortOrders = 'ASC';
                    }
                    else if (sortOrder == 'DESC' || sortOrder == 'desc') {
                        var sortOrders = 'DESC';
                    }
                    else {
                        var sortOrders = 'ASC';
                    }
                    query.orderBy(`u.${sortField}`, sortOrders.toUpperCase());
                }
                else {
                    query.orderBy(`u.createddate`, 'ASC');
                }
                query.limit(pageSize);
                query.offset(pageSize * (page - 1));
                return await query.getRawMany();
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async useractivetelegram(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const isCount = 0;
            const active_status = 1;
            var status = '1';
            const query = await this.userRepository.createQueryBuilder('u');
            if (isCount == 1) {
                var countRs = await query.getCount(['u.id AS uid']);
            }
            else {
                query.select([
                    'u.role_id',
                    'u.email',
                    'u.username',
                    'u.firstname',
                    'u.lastname',
                    'u.fullname',
                    'u.nickname',
                    'u.status',
                    'u.active_status',
                    'u.network_id',
                    'u.infomation_agree_status',
                    'u.online_status',
                    'u.network_type_id',
                    'u.public_status',
                    'u.type_id',
                    'u.public_notification',
                    'u.sms_notification',
                    'u.email_notification',
                    'u.line_notification',
                    'u.mobile_number',
                    'u.phone_number',
                    'u.lineid',
                ]);
            }
            query.where('1=1');
            query.andWhere('u.sms_notification=:sms_notification', {
                sms_notification: active_status,
            });
            if (active_status) {
                query.andWhere('u.active_status=:active_status', {
                    active_status: active_status,
                });
                query.andWhere('u.status IN(:...status)', { status: [1] });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                query.orderBy(`u.createddate`, 'ASC');
                var rs = await query.getRawMany();
                console.log(`rs =>` + rs);
                return rs;
            }
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: JSON.stringify(error) },
                },
            });
        }
    }
    async useractive(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const isCount = 0;
            const active_status = 1;
            var status = '1';
            const query = await this.userRepository.createQueryBuilder('u');
            if (isCount == 1) {
                var countRs = await query.getCount(['u.id AS uid']);
            }
            else {
                query.select(['u.*']);
            }
            query.where('1=1');
            if (active_status) {
                query.andWhere('u.active_status=:active_status', {
                    active_status: active_status,
                });
                query.andWhere('u.status IN(:...status)', { status: [1] });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            if (isCount == 1) {
                var count = await query.getCount();
                let tempCounts = {};
                tempCounts.count = countRs;
                console.log(`count =>` + count);
                console.log(`tempCounts.count =>` + tempCounts.count);
                return count;
            }
            else {
                query.orderBy(`u.createddate`, 'ASC');
                var rs = await query.getRawMany();
                console.log(`rs =>` + rs);
                return rs;
            }
        }
        catch (error) {
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: JSON.stringify(error) },
                },
            });
        }
    }
    async getdevicedata(topics) {
        var topic = encodeURI(topics);
        console.log(`---------getdevicedata------------`);
        console.log(`topics=>`);
        console.info(topics);
        if (!topic) {
            var ResultData = {
                statusCode: 200,
                code: 200,
                topic: topic,
                payload: [],
                status: 0,
                message: `Please specify topic..`,
                message_th: `กรุณาระบุ topic..`,
            };
            return ResultData;
        }
        try {
            if (topic) {
                const now = new Date();
                const pad = (num) => String(num).padStart(2, '0');
                const datePart = [
                    now.getFullYear(),
                    pad(now.getMonth() + 1),
                    pad(now.getDate()),
                ].join('-');
                const timePart = [
                    pad(now.getHours()),
                    pad(now.getMinutes()),
                    pad(now.getSeconds()),
                ].join(':');
                var timestamp = datePart + ' ' + timePart;
                console.log(`Requesting data from topic: ${topic}`);
                var data = await Cache.GetCacheData(topic);
                if (data) {
                    var dataObject = data;
                    var getdataFrom = 'Cache';
                }
                else if (!data) {
                    var data = await this.getDataFromTopic(topic);
                    if (!data) {
                        var dataObjects = {
                            timestamp: timestamp,
                            temperature: [],
                            contRelay1: [],
                            actRelay1: [],
                            fan1: [],
                            overFan1: [],
                            contRelay2: [],
                            actRelay2: [],
                            fan2: [],
                            overFan2: [],
                        };
                        var ResultData = {
                            statusCode: 200,
                            code: 200,
                            topic: topic,
                            payload: dataObjects,
                            mqttdata: {},
                            status: 0,
                            message: `Please specify topic..`,
                            message_th: `กรุณาระบุ topic..`,
                        };
                        return ResultData;
                    }
                    var getdataFrom = 'MQTT';
                    var mqttdata = await this.getDataFromTopic(topic);
                    const parts = mqttdata.split(',');
                    const dataObject = {
                        mqtt_dada: topic,
                        timestamp: timestamp,
                        temperature: parseFloat(parts[0]),
                        contRelay1: parseInt(parts[1]),
                        actRelay1: parseInt(parts[2]),
                        fan1: parseInt(parts[3]),
                        overFan1: parseInt(parts[4]),
                        contRelay2: parseInt(parts[5]),
                        actRelay2: parseInt(parts[6]),
                        fan2: parseInt(parts[7]),
                        overFan2: parseInt(parts[8]),
                    };
                    var InpuDatacache = {
                        keycache: `${topic}`,
                        time: 20,
                        data: dataObject,
                    };
                    await Cache.SetCacheData(InpuDatacache);
                }
                var temperature = dataObject['temperature'];
                var fan1 = dataObject['fan1'];
                var fan2 = dataObject['fan2'];
                var overFan1 = dataObject['overFan1'];
                var overFan2 = dataObject['overFan2'];
                if (overFan1 == 0) {
                    var fan1 = dataObject['fan1'];
                }
                if (overFan2 == 0) {
                }
                var dataObjectRs = {
                    mqtt_dada: topic,
                    timestamp: timestamp,
                    temperature: temperature,
                    contRelay1: dataObject['contRelay1'],
                    actRelay1: dataObject['actRelay1'],
                    fan1: fan1,
                    overFan1: overFan1,
                    contRelay2: dataObject['contRelay2'],
                    actRelay2: dataObject['actRelay2'],
                    fan2: fan2,
                    overFan2: overFan2,
                };
                var ResultData = {
                    statusCode: 200,
                    code: 200,
                    topic: topic,
                    payload: dataObjectRs,
                    mqttdata: mqttdata,
                    getdataFrom: getdataFrom,
                    version: '1.0.1',
                    status: 1,
                    message: `Message successfully Get to topic: ${topic}`,
                    message_th: `Message successfully Get to topic: ${topic}`,
                };
                return ResultData;
            }
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                    ms: 'Unprocessable Entity Exception',
                },
            });
        }
    }
    async publish(topics, payload) {
        var topic = encodeURI(topics);
        console.log(`---------publish------------`);
        console.log(`topics=>`);
        console.info(topics);
        console.log(`payload=>`);
        console.info(payload);
        try {
            await (0, rxjs_1.firstValueFrom)(this.client.emit(topic, payload));
            var InpuDatacache = {
                keycache: `${topic}`,
                time: 86400,
                data: payload,
            };
            await Cache.SetCacheData(InpuDatacache);
            const originalTopic = topic;
            const newTopic = originalTopic.replace('CONTROL', 'DATA');
            Cache.DeleteCacheData(newTopic);
            this.logger.log(`Published to topic "${topic}"`);
        }
        catch (error) {
            this.logger.error(`Failed to publish to topic "${topic}"`, error);
        }
    }
    async _getDataFromTopic(topics) {
        var topic = encodeURI(topics);
        console.log(`---------getDataFromTopic------------`);
        console.log(`topic=>`);
        console.info(topic);
        return new Promise((resolve, reject) => {
            this.mqttClient.subscribe(topic, (err) => {
                if (err) {
                    return reject(err);
                }
            });
            this.messageStream
                .pipe((0, operators_1.filter)((message) => message.topic == topic), (0, operators_1.first)(), (0, operators_1.timeout)(60000))
                .subscribe({
                next: (message) => {
                    this.mqttClient.unsubscribe(topic);
                    try {
                        resolve(JSON.parse(message.payload.toString()));
                    }
                    catch (e) {
                        resolve(message.payload.toString());
                    }
                },
                error: (err) => {
                    this.mqttClient.unsubscribe(topic);
                    reject(new Error(`Timeout: No message received from topic "${topic}" within 60 seconds.`));
                },
            });
        });
    }
    async getDataFromTopic(topics) {
        const topic = encodeURI(topics);
        console.log(`---------getDataFromTopic------------`);
        console.log(`topic=>`, topic);
        await new Promise((resolve, reject) => {
            this.mqttClient.subscribe(topic, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
        return new Promise((resolve, reject) => {
            const subscription = this.messageStream
                .pipe((0, operators_1.filter)((message) => message.topic == topic), (0, operators_1.first)(), (0, operators_1.timeout)(60000))
                .subscribe({
                next: (message) => {
                    this.mqttClient.unsubscribe(topic, () => {
                    });
                    try {
                        const payloadStr = message.payload.toString();
                        resolve(JSON.parse(payloadStr));
                    }
                    catch (_a) {
                        resolve(message.payload.toString());
                    }
                    subscription.unsubscribe();
                },
                error: (err) => {
                    this.mqttClient.unsubscribe(topic);
                    if (err.name == 'TimeoutError') {
                        reject(new Error(`Timeout: No message received from topic "${topic}" within 60 seconds.`));
                    }
                    else {
                        reject(err);
                    }
                    subscription.unsubscribe();
                },
            });
        });
    }
    async getdevicedataAll(topics) {
        var topic = encodeURI(topics);
        const now = new Date();
        const pad = (num) => String(num).padStart(2, '0');
        const datePart = [
            now.getFullYear(),
            pad(now.getMonth() + 1),
            pad(now.getDate()),
        ].join('-');
        const timePart = [
            pad(now.getHours()),
            pad(now.getMinutes()),
            pad(now.getSeconds()),
        ].join(':');
        var timestamp = datePart + ' ' + timePart;
        console.log(`---------getdevicedataAll------------`);
        console.log(`datePart=>`);
        console.info(datePart);
        console.log(`timePart=>`);
        console.info(timePart);
        console.log(`topics=>`);
        console.info(topics);
        console.log(`topic=>`);
        console.info(topic);
        console.log(`Requesting data from topic: ${topic}`);
        if (!topic) {
            var ResultData = {
                topic: topic,
                data: [],
                timestamp: timestamp,
                status: 0,
                message: `Please specify topic..`,
                message_th: `กรุณาระบุ topic..`,
            };
            return ResultData;
        }
        var keycache = md5('mqtt_get_data_' + topic);
        try {
            console.log(`Requesting data from keycache: ${keycache}`);
            var data = await Cache.GetCacheData(keycache);
            if (data) {
                return data;
            }
            else {
                var mqttdata = await this.getDataFromTopic(topic);
                var parts = mqttdata.split(',');
                var dataObjects = {
                    topic: topic,
                    cache: 'cache',
                    status: 1,
                    timestamp: timestamp,
                    mqtt: mqttdata,
                    data: parts,
                };
                var InpuDatacache = {
                    keycache: keycache,
                    time: 5,
                    data: dataObjects,
                };
                await Cache.SetCacheData(InpuDatacache);
                return dataObjects;
            }
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                    ms: 'Unprocessable Entity Exception',
                },
            });
        }
    }
    async devicecontrol(topics, message_mqtt) {
        console.log(`---------devicecontrol------------`);
        console.log(`topics=>`);
        console.info(topics);
        console.log(`message_mqtt=>`);
        console.info(message_mqtt);
        var topic_mqtt = encodeURI(topics);
        try {
            var Rt = await this.publish(topic_mqtt, message_mqtt);
            var InpuDatacache = {
                keycache: `${topic_mqtt}`,
                data: message_mqtt,
            };
            await Cache.SetCacheKey(InpuDatacache);
            var today = format.getDayname();
            var getDaynameall = format.getDaynameall();
            const now = new Date();
            const pad = (num) => String(num).padStart(2, '0');
            const datePart = [
                now.getFullYear(),
                pad(now.getMonth() + 1),
                pad(now.getDate()),
            ].join('-');
            const timePart = [
                pad(now.getHours()),
                pad(now.getMinutes()),
                pad(now.getSeconds()),
            ].join(':');
            var timestamp = datePart + ' ' + timePart;
            const originalTopic = topic_mqtt;
            const newTopic = originalTopic.replace('CONTROL', 'DATA');
            Cache.DeleteCacheData(newTopic);
            var GetCacheData = await Cache.GetCacheData(newTopic);
            if (GetCacheData) {
                Cache.DeleteCacheData(newTopic);
            }
            var mqttdata = await Cache.GetCacheData(newTopic);
            console.log(newTopic);
            if (message_mqtt == 0) {
                var dataObject = {
                    timestamp: timestamp,
                    device_1: 0,
                    device_status: 'off',
                };
            }
            else if (message_mqtt == 1) {
                var dataObject = {
                    timestamp: timestamp,
                    device_1: 1,
                    device_status: 'on',
                };
            }
            else if (message_mqtt == 2) {
                var dataObject = {
                    timestamp: timestamp,
                    device_2: 0,
                    device_status: 'off',
                };
            }
            else if (message_mqtt == 3) {
                var dataObject = {
                    timestamp: timestamp,
                    device_2: 1,
                    device_status: 'on',
                };
            }
            var dataRs = await this.getDataFromTopic(newTopic);
            const parts = dataRs.split(',');
            const getDataObject = {
                mqtt_dada: newTopic,
                timestamp: timestamp,
                temperature: parseFloat(parts[0]),
                contRelay1: parseInt(parts[1]),
                actRelay1: parseInt(parts[2]),
                fan1: parseInt(parts[3]),
                overFan1: parseInt(parts[4]),
                contRelay2: parseInt(parts[5]),
                actRelay2: parseInt(parts[6]),
                fan2: parseInt(parts[7]),
                overFan2: parseInt(parts[8]),
            };
            var InpuDatacache = {
                keycache: `${newTopic}`,
                time: 30,
                data: getDataObject,
            };
            await Cache.SetCacheData(InpuDatacache);
            var ResultData = {
                statusCode: 200,
                code: 200,
                topic_mqtt: topic_mqtt,
                Rt: Rt,
                dataRs: dataRs,
                dataObject: dataObject,
                mqttdata: mqttdata,
                today: today,
                payload: getDataObject,
                daynameall: getDaynameall,
                mqtt_data_control: topic_mqtt,
                mqtt_dada_get: newTopic,
                status: message_mqtt,
                status_msg: dataObject['device_status'],
                message: `Topic: ${topic_mqtt} value: ${message_mqtt}`,
                message_th: `Topic: ${topic_mqtt} value: ${message_mqtt}`,
            };
            return ResultData;
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            var ResultDataerr = {
                statusCode: 500,
                code: 500,
                message: err.message,
                errorMessage: err.message,
            };
            return ResultDataerr;
        }
    }
    async delete_alarmprocesslogEmail_Cleardata(dto) {
        try {
            console.log(`----delete_alarmprocesslog---`);
            var device_id = dto.device_id;
            var alarm_action_id = dto.alarm_action_id;
            var type_id = dto.type_id;
            var date_now = dto.date_now;
            var data_alarm = dto.data_alarm;
            var alarm_status = dto.alarm_status;
            const query = await this.alarmprocesslogemailRepository.createQueryBuilder('l');
            var countRs = await query.select('COUNT(DISTINCT l.alarm_action_id)', 'cnt');
            query.where('1=1');
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            if (count >= 1) {
                const deleteResult = await this.alarmprocesslogemailRepository
                    .createQueryBuilder()
                    .delete()
                    .where('1 = 1')
                    .execute();
                var rt = parseInt('1');
                return rt;
            }
            else {
                var rt = parseInt('0');
                return rt;
            }
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async getAlarmDetails(dto) {
        try {
            console.log(`getAlarmDetails dto-->`);
            console.info(dto);
            var type_id = dto.alarmTypeId;
            if (!type_id) {
                var type_id = parseInt(dto.type_id);
            }
            var sensorValues = dto.sensorValueData;
            var sensorValue = format.safeParseFloat(sensorValues);
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = dto.mqtt_name + '-';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm || 0;
            var event = dto.event;
            var dataAlarm = 999;
            var eventControl = event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            if (type_id == 1) {
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var status = 1;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var status = 1;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device sensor ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 2;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status sensor';
                    var content = 'Normal status sensor';
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                    var status = 3;
                }
            }
            else {
                var sensor_data = parseFloat(dto.value_data);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var status = 1;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var status = 1;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 2;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status IO';
                    var content = 'Normal status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                    var status = 3;
                }
            }
            let rt = {};
            rt.status = status;
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.dataAlarm = dataAlarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensorValue;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.dto = dto;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetails:', error);
            throw error;
        }
    }
    async getAlarmDetail1(dto) {
        try {
            console.log(`getAlarmDetails dto-->`);
            console.info(dto);
            var unit = dto.unit;
            var type_id = dto.alarmTypeId;
            if (!type_id) {
                var type_id = parseInt(dto.type_id);
            }
            var sensorValues = dto.sensorValueData;
            var sensorValue = format.safeParseFloat(sensorValues);
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = '';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm || 0;
            var event = dto.event;
            var dataAlarm = 999;
            var eventControl = event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            if (type_id == 1) {
                var sensor_data = parseFloat(dto.value_data);
                var sensorValue = parseFloat(sensorValue);
                var statusWarning = parseFloat(statusWarning);
                var statusAlert = parseFloat(statusAlert);
                var recoveryWarning = parseFloat(recoveryWarning);
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning : ${deviceName} : ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName}: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var status = 1;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm : ${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning : ${deviceName}: ${sensorValue} ` +
                        unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm :${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 4;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status';
                    var content = 'Normal Status Sensor';
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            else {
                var sensor_data = parseFloat(dto.value_data);
                var sensorValue = parseInt(sensorValue);
                var statusWarning = parseInt(statusWarning);
                var statusAlert = parseInt(statusAlert);
                var recoveryWarning = parseInt(recoveryWarning);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var status = 1;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 24;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status IO';
                    var content = 'Normal Status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            let rt = {};
            rt.status = status;
            rt.statusControl = status;
            rt.alarmTypeId = type_id;
            rt.type_id = type_id;
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.dataAlarm = dataAlarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensorValue;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.type_id = dto.type_id;
            rt.mqtt_name = dto.mqtt_name;
            rt.device_name = dto.device_name;
            rt.mqtt_control_on = dto.mqtt_control_on;
            rt.unit = dto.unit;
            rt.sensorValue = dto.sensorValueData;
            rt.statusAlert = statusAlert;
            rt.statusWarning = statusWarning;
            rt.recoveryWarning = recoveryWarning;
            rt.recoveryAlert = dto.recovery_alert;
            rt.mqttName = dto.mqtt_name;
            rt.deviceName = dto.device_name;
            rt.alarmActionName = dto.action_name;
            rt.mqttControlOn = dto.mqtt_control_on;
            rt.mqttControlOff = dto.mqtt_control_off;
            rt.count_alarm = dto.count_alarm;
            rt.event = dto.event;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetails:', error);
            throw error;
        }
    }
    async getAlarmDetailss(dto) {
        try {
            console.log(`getAlarmDetails dto-->`);
            console.info(dto);
            var unit = dto.unit;
            var type_id = dto.alarmTypeId;
            if (!type_id) {
                var type_id = parseInt(dto.type_id);
            }
            var sensorValues = dto.sensorValueData;
            var sensorValue = format.safeParseFloat(sensorValues);
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = '';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm || 0;
            var event = dto.event;
            var dataAlarm = 999;
            var eventControl = event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            var value_data = dto.value_data;
            var value_alarm = dto.value_alarm;
            var value_relay = dto.value_relay;
            var value_control_relay = dto.value_control_relay;
            if (type_id == 1) {
                var sensor_data = parseFloat(dto.value_data);
                var sensorValue = parseFloat(sensorValue);
                var statusWarning = parseFloat(statusWarning);
                var statusAlert = parseFloat(statusAlert);
                var recoveryWarning = parseFloat(recoveryWarning);
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    return dto.type_id;
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning : ${deviceName} : ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName}: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var status = 1;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm : ${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning : ${deviceName}: ${sensorValue} ` +
                        unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm :${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 4;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status';
                    var content = 'Normal Status Sensor';
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            else {
                var value_data = dto.value_data;
                var value_alarm = dto.value_alarm;
                var value_relay = dto.value_relay;
                var value_control_relay = dto.value_control_relay;
                var sensorValue = parseInt(value_alarm);
                var statusWarning = parseInt(statusWarning);
                var statusAlert = parseInt(statusAlert);
                var recoveryWarning = parseInt(recoveryWarning);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var status = 1;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 24;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status IO';
                    var content = 'Normal Status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            let rt = {};
            rt.status = status;
            rt.statusControl = status;
            rt.alarmTypeId = type_id;
            rt.type_id = type_id;
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.dataAlarm = dataAlarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensorValue;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.type_id = dto.type_id;
            rt.mqtt_name = dto.mqtt_name;
            rt.device_name = dto.device_name;
            rt.mqtt_control_on = dto.mqtt_control_on;
            rt.unit = dto.unit;
            rt.sensorValue = dto.sensorValueData;
            rt.statusAlert = statusAlert;
            rt.statusWarning = statusWarning;
            rt.recoveryWarning = recoveryWarning;
            rt.recoveryAlert = dto.recovery_alert;
            rt.mqttName = dto.mqtt_name;
            rt.deviceName = dto.device_name;
            rt.alarmActionName = dto.action_name;
            rt.mqttControlOn = dto.mqtt_control_on;
            rt.mqttControlOff = dto.mqtt_control_off;
            rt.count_alarm = dto.count_alarm;
            rt.event = dto.event;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetails:', error);
            throw error;
        }
    }
    async getAlarmDetail(dto) {
        try {
            console.log(`getAlarmDetails dto-->`);
            console.info(dto);
            var unit = dto.unit;
            var type_id = dto.alarmTypeId;
            if (!type_id) {
                var type_id = parseInt(dto.type_id);
            }
            var sensorValues = dto.value_data;
            if (!sensorValues) {
                var sensorValues = dto.sensorValueData;
                var sensorValue = format.safeParseFloat(sensorValues);
            }
            else {
                var sensorValues = parseInt(dto.value_data);
            }
            var alarmStatusSet = parseInt('999');
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = '';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm || 0;
            var event = dto.event;
            var dataAlarm = 999;
            var eventControl = event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            var type_id = parseInt(dto.type_id);
            var value_alarm = dto.value_alarm;
            var value_relay = dto.value_relay;
            var value_control_relay = dto.value_control_relay;
            if (type_id == 1) {
                var sensor_data = parseFloat(dto.value_data);
                var sensorValue = parseFloat(sensorValue);
                var statusWarning = parseFloat(statusWarning);
                var statusAlert = parseFloat(statusAlert);
                var recoveryWarning = parseFloat(recoveryWarning);
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning : ${deviceName} : ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName}: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var data_alarm = parseInt(statusWarning);
                    var status = 1;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm : ${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var data_alarm = parseInt(recoveryWarning);
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning : ${deviceName}: ${sensorValue} ` +
                        unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var data_alarm = parseInt(recoveryWarning);
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm :${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var data_alarm = parseInt(recoveryAlert);
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 4;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status';
                    var content = 'Normal Status Sensor';
                    var dataAlarm = 999;
                    var data_alarm = parseInt('999');
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            else {
                var value_data = dto.value_data;
                var value_alarm = dto.value_alarm;
                var value_relay = dto.value_relay;
                var value_control_relay = dto.value_control_relay;
                var sensorValue = parseInt(value_alarm);
                var sensor_data = parseInt(value_alarm);
                var statusWarning = parseInt(statusWarning);
                var statusAlert = parseInt(statusAlert);
                var recoveryWarning = parseInt(recoveryWarning);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var data_alarm = parseInt('0');
                    var status = 1;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var data_alarm = parseInt('0');
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var data_alarm = parseInt('1');
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var data_alarm = parseInt('1');
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 24;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status IO';
                    var content = 'Normal Status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var data_alarm = parseInt('999');
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            let rt = {};
            rt.status = status;
            rt.statusControl = status;
            rt.alarmTypeId = type_id;
            rt.type_id = type_id;
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.dataAlarm = dataAlarm;
            rt.data_alarm = data_alarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensor_data;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.type_id = dto.type_id;
            rt.mqtt_name = dto.mqtt_name;
            rt.device_name = dto.device_name;
            rt.mqtt_control_on = dto.mqtt_control_on;
            rt.unit = dto.unit;
            rt.sensorValue = dto.sensorValueData;
            rt.statusAlert = statusAlert;
            rt.statusWarning = statusWarning;
            rt.recoveryWarning = recoveryWarning;
            rt.recoveryAlert = dto.recovery_alert;
            rt.mqttName = dto.mqtt_name;
            rt.deviceName = dto.device_name;
            rt.alarmActionName = dto.action_name;
            rt.mqttControlOn = dto.mqtt_control_on;
            rt.mqttControlOff = dto.mqtt_control_off;
            rt.count_alarm = dto.count_alarm;
            rt.event = dto.event;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetails:', error);
            throw error;
        }
    }
    async getAlarmDetailValidate(dto) {
        try {
            console.log('getAlarmDetails dto-->', dto);
            const unit = dto.unit || '';
            let type_id = dto.type_id ? parseInt(dto.type_id) : 0;
            if (dto.alarmTypeId) {
                type_id = parseInt(dto.alarmTypeId);
            }
            let sensorValues = dto.value_data;
            if (sensorValues !== null &&
                sensorValues !== undefined &&
                sensorValues !== '') {
                const sensorValueNum = parseInt(sensorValues);
                if (!isNaN(sensorValueNum)) {
                    sensorValues = sensorValueNum;
                }
            }
            const statusAlert = parseFloat(dto.status_alert) || 0;
            const statusWarning = parseFloat(dto.status_warning) || 0;
            const recoveryWarning = parseFloat(dto.recovery_warning) || 0;
            const recoveryAlert = parseFloat(dto.recovery_alert) || 0;
            const mqttName = '';
            const deviceName = dto.device_name || '';
            const alarmActionName = dto.action_name || '';
            const mqttControlOn = dto.mqtt_control_on || '';
            const mqttControlOff = dto.mqtt_control_off || '';
            const count_alarm = parseInt(dto.count_alarm) || 0;
            const event = parseInt(dto.event) || 0;
            let dataAlarm = 999;
            let eventControl = event;
            let messageMqttControl = event === 1 ? mqttControlOn : mqttControlOff;
            let alarmStatusSet = 999;
            let subject = '';
            let content = '';
            let status = 5;
            let data_alarm = 0;
            let value_data = dto.value_data;
            let value_alarm = dto.value_alarm || '';
            let value_relay = dto.value_relay || '';
            let value_control_relay = dto.value_control_relay || '';
            let sensor_data = null;
            if (type_id === 1) {
                sensor_data = parseFloat(dto.value_data) || 0;
                const sensorValue = sensor_data;
                if ((sensorValue > statusWarning || sensorValue === statusWarning) &&
                    statusWarning < statusAlert) {
                    alarmStatusSet = 1;
                    subject = `${mqttName} Warning : ${deviceName} : ${sensorValue} ${unit}`;
                    content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName}: ${sensorValue}`;
                    dataAlarm = statusWarning;
                    data_alarm = statusWarning;
                    status = 1;
                }
                else if ((sensorValue > statusAlert || sensorValue === statusAlert) &&
                    statusAlert > statusWarning) {
                    alarmStatusSet = 2;
                    subject = `${mqttName} Alarm : ${deviceName}: ${sensorValue} ${unit}`;
                    content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    dataAlarm = statusAlert;
                    data_alarm = statusAlert;
                    status = 2;
                }
                else if (count_alarm >= 1 &&
                    (sensorValue < recoveryWarning || sensorValue === recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    alarmStatusSet = 3;
                    subject = `${mqttName} Recovery Warning : ${deviceName}: ${sensorValue} ${unit}`;
                    content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} : ${sensorValue}`;
                    dataAlarm = recoveryWarning;
                    data_alarm = recoveryWarning;
                    eventControl = event === 1 ? 0 : 1;
                    messageMqttControl = event === 1 ? mqttControlOff : mqttControlOn;
                    status = 3;
                }
                else if (count_alarm >= 1 &&
                    (sensorValue < recoveryAlert || sensorValue === recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    alarmStatusSet = 4;
                    subject = `${mqttName} Recovery Alarm :${deviceName}: ${sensorValue} ${unit}`;
                    content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    dataAlarm = recoveryAlert;
                    data_alarm = recoveryAlert;
                    eventControl = event === 1 ? 0 : 1;
                    messageMqttControl = event === 1 ? mqttControlOff : mqttControlOn;
                    status = 4;
                }
                else {
                    alarmStatusSet = 999;
                    subject = 'Normal Status';
                    content = 'Normal Status Sensor';
                    dataAlarm = 0;
                    data_alarm = 0;
                    status = 5;
                }
            }
            else {
                const sensorValue = parseInt(dto.value_alarm) || 0;
                sensor_data = sensorValue;
                if (sensorValue === statusWarning) {
                    alarmStatusSet = 1;
                    subject = `${mqttName} Warning Device IO`;
                    content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} : ${sensorValue}`;
                    dataAlarm = statusWarning;
                    data_alarm = 0;
                    status = 1;
                }
                else if (sensorValue === statusAlert) {
                    alarmStatusSet = 2;
                    subject = `${mqttName} Alarm IO`;
                    content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    dataAlarm = statusAlert;
                    data_alarm = 0;
                    status = 2;
                }
                else if (count_alarm >= 1 && sensorValue === recoveryWarning) {
                    alarmStatusSet = 3;
                    subject = `${mqttName} Recovery Warning IO`;
                    content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} : ${sensorValue}`;
                    dataAlarm = recoveryWarning;
                    data_alarm = 1;
                    eventControl = event === 1 ? 0 : 1;
                    messageMqttControl = event === 1 ? mqttControlOff : mqttControlOn;
                    status = 3;
                }
                else if (count_alarm >= 1 && sensorValue === recoveryAlert) {
                    alarmStatusSet = 4;
                    subject = `${mqttName} Recovery Alarm IO`;
                    content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    dataAlarm = recoveryAlert;
                    data_alarm = 1;
                    eventControl = event === 1 ? 0 : 1;
                    messageMqttControl = event === 1 ? mqttControlOff : mqttControlOn;
                    status = 4;
                }
                else {
                    alarmStatusSet = 999;
                    subject = 'Normal Status IO';
                    content = `Normal Status IO sensorValue => ${sensorValue} statusWarning => ${statusWarning}`;
                    dataAlarm = 0;
                    data_alarm = 0;
                    status = 5;
                }
            }
            const result = {
                status: status,
                statusControl: status,
                alarmTypeId: type_id,
                type_id: type_id,
                alarmStatusSet: alarmStatusSet,
                subject: subject,
                content: content,
                value_data: value_data,
                value_alarm: dto.value_alarm || '',
                value_relay: value_relay,
                value_control_relay: value_control_relay,
                dataAlarm: dataAlarm,
                data_alarm: data_alarm,
                eventControl: eventControl,
                messageMqttControl: messageMqttControl,
                sensor_data: sensor_data,
                count_alarm: count_alarm,
                mqttName: mqttName,
                mqtt_name: dto.mqtt_name || '',
                device_name: dto.device_name || '',
                mqtt_control_on: dto.mqtt_control_on || '',
                unit: dto.unit || '',
                sensorValue: dto.sensorValueData || '',
                statusAlert: statusAlert,
                statusWarning: statusWarning,
                recoveryWarning: recoveryWarning,
                recoveryAlert: dto.recovery_alert || '',
                deviceName: dto.device_name || '',
                alarmActionName: dto.action_name || '',
                mqttControlOn: dto.mqtt_control_on || '',
                mqttControlOff: dto.mqtt_control_off || '',
                event: dto.event || 0,
            };
            return result;
        }
        catch (error) {
            console.error('Error in getAlarmDetails:', error);
            throw error;
        }
    }
    async getAlarmDetailsAlert(dto) {
        try {
            console.log('getAlarmDetails dto-->', dto);
            const unit = dto.unit || '';
            const type_id = parseInt(dto.alarmTypeId) || 0;
            const sensorValueStr = dto.sensorValueData;
            let sensorValue = 0;
            if (sensorValueStr !== null &&
                sensorValueStr !== undefined &&
                sensorValueStr !== '') {
                if (type_id === 1) {
                    sensorValue = parseFloat(sensorValueStr) || 0;
                }
                else {
                    sensorValue = parseInt(sensorValueStr) || 0;
                }
            }
            const statusAlert = parseFloat(dto.status_alert) || 0;
            const statusWarning = parseFloat(dto.status_warning) || 0;
            const recoveryWarning = parseFloat(dto.recovery_warning) || 0;
            const recoveryAlert = parseFloat(dto.recovery_alert) || 0;
            const mqttName = '';
            const deviceName = dto.device_name || '';
            const alarmActionName = dto.action_name || '';
            const mqttControlOn = dto.mqtt_control_on || '';
            const mqttControlOff = dto.mqtt_control_off || '';
            const count_alarm = parseInt(dto.count_alarm) || 0;
            const event = parseInt(dto.event) || 0;
            let alarmStatusSet = 999;
            let subject = '';
            let content = '';
            let status = 5;
            let dataAlarm = 999;
            let eventControl = event;
            let messageMqttControl = event === 1 ? mqttControlOn : mqttControlOff;
            let sensor_data = sensorValue;
            if (type_id === 1) {
                const sensorValueNum = sensorValue;
                const statusWarningNum = statusWarning;
                const statusAlertNum = statusAlert;
                const recoveryWarningNum = recoveryWarning;
                const recoveryAlertNum = recoveryAlert;
                if ((sensorValueNum > statusWarningNum ||
                    sensorValueNum === statusWarningNum) &&
                    statusWarningNum < statusAlertNum) {
                    alarmStatusSet = 1;
                    subject = `${mqttName} Warning : ${deviceName} : ${sensorValueNum} ${unit}`;
                    content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName}: ${sensorValueNum}`;
                    dataAlarm = statusWarningNum;
                    status = 1;
                }
                else if ((sensorValueNum > statusAlertNum ||
                    sensorValueNum === statusAlertNum) &&
                    statusAlertNum > statusWarningNum) {
                    alarmStatusSet = 2;
                    subject = `${mqttName} Alarm : ${deviceName}: ${sensorValueNum} ${unit}`;
                    content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} : ${sensorValueNum}`;
                    dataAlarm = statusAlertNum;
                    status = 2;
                }
                else if (count_alarm >= 1 &&
                    (sensorValueNum < recoveryWarningNum ||
                        sensorValueNum === recoveryWarningNum) &&
                    recoveryWarningNum <= recoveryAlertNum) {
                    alarmStatusSet = 3;
                    subject = `${mqttName} Recovery Warning : ${deviceName}: ${sensorValueNum} ${unit}`;
                    content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} : ${sensorValueNum}`;
                    dataAlarm = recoveryWarningNum;
                    eventControl = event === 1 ? 0 : 1;
                    messageMqttControl = event === 1 ? mqttControlOff : mqttControlOn;
                    status = 3;
                }
                else if (count_alarm >= 1 &&
                    (sensorValueNum < recoveryAlertNum ||
                        sensorValueNum === recoveryAlertNum) &&
                    recoveryAlertNum >= recoveryWarningNum) {
                    alarmStatusSet = 4;
                    subject = `${mqttName} Recovery Alarm : ${deviceName}: ${sensorValueNum} ${unit}`;
                    content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} : ${sensorValueNum}`;
                    dataAlarm = recoveryAlertNum;
                    eventControl = event === 1 ? 0 : 1;
                    messageMqttControl = event === 1 ? mqttControlOff : mqttControlOn;
                    status = 4;
                }
                else {
                    alarmStatusSet = 999;
                    subject = 'Normal Status';
                    content = 'Normal Status Sensor';
                    dataAlarm = 0;
                    status = 5;
                }
            }
            else {
                const sensorValueNum = sensorValue;
                const statusWarningNum = Math.round(statusWarning);
                const statusAlertNum = Math.round(statusAlert);
                const recoveryWarningNum = Math.round(recoveryWarning);
                const recoveryAlertNum = Math.round(recoveryAlert);
                sensor_data = parseInt(dto.value_data) || 0;
                if (sensorValueNum === statusWarningNum) {
                    alarmStatusSet = 1;
                    subject = `${mqttName} Warning Device IO`;
                    content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} : ${sensorValueNum}`;
                    dataAlarm = statusWarningNum;
                    status = 1;
                }
                else if (sensorValueNum === statusAlertNum) {
                    alarmStatusSet = 2;
                    subject = `${mqttName} Alarm IO`;
                    content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} : ${sensorValueNum}`;
                    dataAlarm = statusAlertNum;
                    status = 2;
                }
                else if (count_alarm >= 1 && sensorValueNum === recoveryWarningNum) {
                    alarmStatusSet = 3;
                    subject = `${mqttName} Recovery Warning IO`;
                    content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} : ${sensorValueNum}`;
                    dataAlarm = recoveryWarningNum;
                    eventControl = event === 1 ? 0 : 1;
                    messageMqttControl = event === 1 ? mqttControlOff : mqttControlOn;
                    status = 3;
                }
                else if (count_alarm >= 1 && sensorValueNum === recoveryAlertNum) {
                    alarmStatusSet = 4;
                    subject = `${mqttName} Recovery Alarm IO`;
                    content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} : ${sensorValueNum}`;
                    dataAlarm = recoveryAlertNum;
                    eventControl = event === 1 ? 0 : 1;
                    messageMqttControl = event === 1 ? mqttControlOff : mqttControlOn;
                    status = 4;
                }
                else {
                    alarmStatusSet = 999;
                    subject = 'Normal Status IO';
                    content = `Normal Status IO sensorValue => ${sensorValueNum} statusWarning => ${statusWarningNum}`;
                    dataAlarm = 0;
                    status = 5;
                }
            }
            const result = {
                status: status,
                alarmStatusSet: alarmStatusSet,
                subject: subject,
                content: content,
                dataAlarm: dataAlarm,
                eventControl: eventControl,
                messageMqttControl: messageMqttControl,
                sensor_data: sensor_data,
                count_alarm: count_alarm,
                mqttName: mqttName,
            };
            return result;
        }
        catch (error) {
            console.error('Error in getAlarmDetailsAlert:', error);
            throw error;
        }
    }
    async _getAlarmDetailValidate(dto) {
        try {
            console.log(`getAlarmDetails dto-->`);
            console.info(dto);
            var unit = dto.unit;
            var type_id = dto.alarmTypeId;
            if (!type_id) {
                var type_id = parseInt(dto.type_id);
            }
            var sensorValues = dto.value_data;
            if (sensorValues !== null &&
                sensorValues !== undefined &&
                sensorValues !== '') {
                var sensorValueNum = parseInt(sensorValues);
                if (!isNaN(sensorValueNum)) {
                    sensorValues = sensorValueNum;
                    var sensorValues = format.safeParseFloat(sensorValues);
                }
            }
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = '';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm || 0;
            var event = dto.event;
            var dataAlarm = 999;
            var eventControl = event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            var type_id = parseInt(dto.type_id);
            if (type_id == 1) {
                var value_data = dto.value_data;
                var value_alarm = dto.value_alarm;
                var value_relay = dto.value_relay;
                var value_control_relay = dto.value_control_relay;
                var value_alarm = dto.value_alarm;
                var value_relay = dto.value_relay;
                var value_control_relay = dto.value_control_relay;
                var value_data = parseFloat(value_data);
                var sensor_data = parseFloat(dto.value_data);
                var sensorValue = parseFloat(sensorValue);
                var statusWarning = parseFloat(dto.status_warning);
                var statusAlert = parseFloat(dto.status_alert);
                var recoveryWarning = parseFloat(dto.recovery_warning);
                var recoveryAlert = parseFloat(dto.recovery_alert);
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning : ${deviceName} : ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName}: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var data_alarm = parseInt(statusWarning);
                    var status = 1;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm : ${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var data_alarm = parseInt(recoveryWarning);
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning : ${deviceName}: ${sensorValue} ` +
                        unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var data_alarm = parseInt(recoveryWarning);
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm :${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var data_alarm = parseInt(recoveryAlert);
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 4;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status';
                    var content = 'Normal Status Sensor';
                    var dataAlarm = 999;
                    var data_alarm = parseInt('999');
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            else {
                var value_data = dto.value_data;
                var value_alarm = dto.value_alarm;
                var value_relay = dto.value_relay;
                var value_control_relay = dto.value_control_relay;
                var sensorValue = parseInt(value_alarm);
                var sensor_data = parseInt(value_alarm);
                var statusWarning = parseInt(statusWarning);
                var statusAlert = parseInt(statusAlert);
                var recoveryWarning = parseInt(recoveryWarning);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var data_alarm = parseInt('0');
                    var status = 1;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var data_alarm = parseInt('0');
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var data_alarm = parseInt('1');
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var data_alarm = parseInt('1');
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 24;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status IO';
                    var content = 'Normal Status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var data_alarm = parseInt('999');
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            let rt = {};
            rt.status = status;
            rt.statusControl = status;
            rt.alarmTypeId = type_id;
            rt.type_id = type_id;
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.value_data = value_data;
            rt.value_alarm = dto.value_alarm;
            rt.value_relay = value_relay;
            rt.value_control_relay = value_control_relay;
            rt.dataAlarm = value_alarm;
            rt.data_alarm = value_alarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensor_data;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.type_id = dto.type_id;
            rt.mqtt_name = dto.mqtt_name;
            rt.device_name = dto.device_name;
            rt.mqtt_control_on = dto.mqtt_control_on;
            rt.unit = dto.unit;
            rt.sensorValue = dto.sensorValueData;
            rt.statusAlert = statusAlert;
            rt.statusWarning = statusWarning;
            rt.recoveryWarning = recoveryWarning;
            rt.recoveryAlert = dto.recovery_alert;
            rt.mqttName = dto.mqtt_name;
            rt.deviceName = dto.device_name;
            rt.alarmActionName = dto.action_name;
            rt.mqttControlOn = dto.mqtt_control_on;
            rt.mqttControlOff = dto.mqtt_control_off;
            rt.count_alarm = dto.count_alarm;
            rt.event = dto.event;
            rt.dto = dto;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetails:', error);
            throw error;
        }
    }
    async _getAlarmDetailsAlert(dto) {
        try {
            console.log(`getAlarmDetails dto-->`);
            console.info(dto);
            var unit = dto.unit;
            var type_id = dto.alarmTypeId;
            var sensorValues = dto.sensorValueData;
            var sensorValue = sensorValues;
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = '';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm || 0;
            var event = dto.event;
            var dataAlarm = 999;
            var eventControl = event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            if (type_id == 1) {
                var sensor_data = parseFloat(dto.value_data);
                var sensorValue = parseFloat(sensorValue);
                var statusWarning = parseFloat(statusWarning);
                var statusAlert = parseFloat(statusAlert);
                var recoveryWarning = parseFloat(recoveryWarning);
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning : ${deviceName} : ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName}: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var status = 1;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm : ${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning : ${deviceName}: ${sensorValue} ` +
                        unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm :${deviceName}: ${sensorValue} ` + unit;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 4;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status';
                    var content = 'Normal Status Sensor';
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            else {
                var sensorValue = parseInt(sensorValue);
                var statusWarning = parseInt(statusWarning);
                var statusAlert = parseInt(statusAlert);
                var recoveryWarning = parseInt(recoveryWarning);
                var sensor_data = parseInt(dto.value_data);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusWarning;
                    var status = 1;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = statusAlert;
                    var status = 2;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 3;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm IO`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} : ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                    var status = 24;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal Status IO';
                    var content = 'Normal Status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                    var status = 5;
                }
            }
            let rt = {};
            rt.status = status;
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.dataAlarm = dataAlarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensorValue;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.dto = dto;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetails:', error);
            throw error;
        }
    }
    async getAlarmDetailsChkEmail(dto) {
        return await this.getAlarmDetails(dto);
    }
    async getAlarmDetailsSendEmail(dto) {
        try {
            var device_status = 0;
            var ResultDatasendEmail = [];
            var useractive_arr = [];
            var filter_useractive = { status: 1 };
            var useractive = await this.useractiveemail(filter_useractive);
            var user_arr = [];
            console.log(`getAlarmDetailsSendEmail dto-->`);
            console.info(dto);
            var alarmStatusSet = 0;
            var type_id = dto.alarmTypeId;
            var sensorValues = dto.sensorValueData;
            var sensorValue = sensorValues;
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = dto.mqtt_name + '-';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm;
            var event = dto.event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            if (type_id == 1) {
                var sensor_data = parseFloat(dto.value_data);
                var sensorValue = parseFloat(sensorValue);
                var statusWarning = parseFloat(statusWarning);
                var statusAlert = parseFloat(statusAlert);
                var recoveryWarning = parseFloat(recoveryWarning);
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device sensor ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status sensor';
                    var content = 'Normal status sensor';
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                }
            }
            else {
                var sensor_data = parseInt(dto.value_data);
                var sensorValue = parseInt(sensorValue);
                var statusWarning = parseInt(statusWarning);
                var statusAlert = parseInt(statusAlert);
                var recoveryWarning = parseInt(recoveryWarning);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status IO';
                    var content = 'Normal status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                }
            }
            var log_alarm_log = '';
            var emails = [];
            for (const [k, v] of Object.entries(useractive)) {
                var email = useractive[k].email;
                emails.push(email);
                var mobile_number = useractive[k].mobile_number;
                var lineid = useractive[k].lineid;
                var user_arr = {
                    email: email,
                    mobile: mobile_number,
                    lineid: lineid,
                };
                useractive_arr.push(user_arr);
            }
            if (alarmStatusSet != 0 && emails.length > 0) {
                await this.sendEmail(emails, subject, content);
                var ResultDatasendEmail = 'sendEmail to ' + emails.join(', ');
            }
            let rt = {};
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.dataAlarm = dataAlarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensorValue;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.dto = dto;
            rt.ResultDatasendEmail;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetailsSendEmail:', error);
            throw error;
        }
    }
    async getAlarmDetailsSendLine(dto) {
        try {
            console.log(`getAlarmDetails dto-->`);
            console.info(dto);
            var type_id = dto.type_id;
            var sensorValues = dto.sensorValueData;
            var sensorValue = format.safeParseFloat(sensorValues);
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = dto.mqtt_name + '-';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm || 0;
            var event = dto.event;
            var dataAlarm = 999;
            var eventControl = event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            if (type_id == 1) {
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device sensor ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status sensor';
                    var content = 'Normal status sensor';
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                }
            }
            else {
                var sensor_data = parseFloat(dto.value_data);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status IO';
                    var content = 'Normal status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                }
            }
            let rt = {};
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.dataAlarm = dataAlarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensorValue;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.dto = dto;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetailsChkEmail:', error);
            throw error;
        }
    }
    async getAlarmDetailsSendtelegram(dto) {
        try {
            console.log(`getAlarmDetails dto-->`);
            console.info(dto);
            var type_id = dto.alarmTypeId;
            var sensorValues = dto.sensorValueData;
            var sensorValue = format.safeParseFloat(sensorValues);
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = dto.mqtt_name + '-';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm || 0;
            var event = dto.event;
            var dataAlarm = 999;
            var eventControl = event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            if (type_id == 1) {
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device sensor ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status sensor';
                    var content = 'Normal status sensor';
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                }
            }
            else {
                var sensor_data = parseFloat(dto.value_data);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status IO';
                    var content = 'Normal status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                }
            }
            let rt = {};
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.dataAlarm = dataAlarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensorValue;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.dto = dto;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetailsChkEmail:', error);
            throw error;
        }
    }
    async getAlarmDetailsSendsms(dto) {
        try {
            console.log(`getAlarmDetails dto-->`);
            console.info(dto);
            var type_id = dto.alarmTypeId;
            var sensorValues = dto.sensorValueData;
            var sensorValue = format.safeParseFloat(sensorValues);
            var statusAlert = dto.status_alert;
            var statusWarning = dto.status_warning;
            var recoveryWarning = dto.recovery_warning;
            var recoveryAlert = dto.recovery_alert;
            var mqttName = dto.mqtt_name + '-';
            var deviceName = dto.device_name;
            var alarmActionName = dto.action_name;
            var mqttControlOn = dto.mqtt_control_on;
            var mqttControlOff = dto.mqtt_control_off;
            var count_alarm = dto.count_alarm || 0;
            var event = dto.event;
            var dataAlarm = 999;
            var eventControl = event;
            var messageMqttControl = event == 1 ? mqttControlOn : mqttControlOff;
            if (type_id == 1) {
                if ((sensorValue > statusWarning || sensorValue == statusWarning) &&
                    statusWarning < statusAlert) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                }
                else if ((sensorValue > statusAlert || sensorValue == statusAlert) &&
                    statusAlert > statusWarning) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryWarning || sensorValue == recoveryWarning) &&
                    recoveryWarning <= recoveryAlert) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device Sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    (sensorValue < recoveryAlert || sensorValue == recoveryAlert) &&
                    recoveryAlert >= recoveryWarning) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device sensor ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device sensor: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status sensor';
                    var content = 'Normal status sensor';
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                }
            }
            else {
                var sensor_data = parseFloat(dto.value_data);
                if (sensorValue == statusWarning) {
                    var alarmStatusSet = parseInt('1');
                    var subject = `${mqttName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusWarning;
                }
                else if (sensorValue == statusAlert) {
                    var alarmStatusSet = parseInt('2');
                    var subject = `${mqttName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = statusAlert;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryWarning) {
                    var alarmStatusSet = parseInt('3');
                    var subject = `${mqttName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Warning Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryWarning;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else if ((count_alarm > 1 || count_alarm == 1) &&
                    sensorValue == recoveryAlert) {
                    var alarmStatusSet = parseInt('4');
                    var subject = `${mqttName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var content = `${mqttName} ${alarmActionName} Recovery Alarm Alarm Device IO: ${deviceName} value: ${sensorValue}`;
                    var dataAlarm = recoveryAlert;
                    var eventControl = event == 1 ? 0 : 1;
                    var messageMqttControl = event == 1 ? mqttControlOff : mqttControlOn;
                }
                else {
                    var alarmStatusSet = parseInt('999');
                    var subject = 'Normal status IO';
                    var content = 'Normal status IO sensorValue => ' +
                        sensorValue +
                        ' statusWarning =>' +
                        statusWarning;
                    var dataAlarm = 999;
                    var eventControl;
                    var messageMqttControl;
                }
            }
            let rt = {};
            rt.alarmStatusSet = alarmStatusSet;
            rt.subject = subject;
            rt.content = content;
            rt.dataAlarm = dataAlarm;
            rt.eventControl = eventControl;
            rt.messageMqttControl = messageMqttControl;
            rt.sensor_data = sensorValue;
            rt.count_alarm = count_alarm;
            rt.mqttName = mqttName;
            rt.dto = dto;
            return await rt;
        }
        catch (error) {
            console.error('Error in getAlarmDetailsChkEmail:', error);
            throw error;
        }
    }
    async countDataEmail(dto) {
        try {
            var fillterData = {};
            if (dto.alarm_action_id) {
                fillterData.alarm_action_id = dto.alarm_action_id;
            }
            if (dto.data_alarm_event) {
                fillterData.event = dto.data_alarm_event;
            }
            if (dto.type_id) {
                fillterData.type_id = dto.type_id;
            }
            if (dto.date_now) {
                fillterData.date = dto.date_now;
            }
            if (dto.time_now) {
                fillterData.time = dto.time_now;
            }
            if (dto.sensorValueData) {
                fillterData.data = dto.sensorValueData;
            }
            if (dto.alarmStatusSet == 1) {
                fillterData.status_warning = dto.data_alarm_status_warning;
            }
            else if (dto.alarmStatusSet == 2) {
                fillterData.status_alert = dto.data_alarm_status_alert;
            }
            else if (dto.alarmStatusSet == 3) {
                fillterData.recovery_warning = dto.data_alarm_recovery_warning;
            }
            else if (dto.alarmStatusSet == 4) {
                fillterData.recovery_alert = dto.data_alarm_recovery_alert;
            }
            if (dto.alarm_status) {
                fillterData.alarm_status = dto.alarm_status;
            }
            if (dto.data_alarm) {
                fillterData.data_alarm = dto.data_alarm;
            }
            let count_alarm = 0;
            try {
                var countResult = await this.count_alarmprocesslogemail(fillterData);
                count_alarm = parseInt(countResult) || 0;
            }
            catch (error) {
                console.error('Error counting alarm process log:', error);
                count_alarm = 0;
            }
            if (count_alarm == 0) {
                const count_alarm = parseInt('0');
                return count_alarm;
            }
            else {
                return count_alarm;
            }
        }
        catch (error) {
            console.error('Error in countDataEmail:', error);
            throw error;
        }
    }
    async countDataControl(dto) {
        try {
            var fillterData = {};
            if (dto.alarm_action_id) {
                fillterData.alarm_action_id = dto.alarm_action_id;
            }
            if (dto.data_alarm_event) {
                fillterData.event = dto.data_alarm_event;
            }
            if (dto.type_id) {
                fillterData.type_id = dto.type_id;
            }
            if (dto.date_now) {
                fillterData.date = dto.date_now;
            }
            if (dto.time_now) {
                fillterData.time = dto.time_now;
            }
            if (dto.sensorValueData) {
                fillterData.data = dto.sensorValueData;
            }
            if (dto.alarmStatusSet == 1) {
                fillterData.status_warning = dto.data_alarm_status_warning;
            }
            else if (dto.alarmStatusSet == 2) {
                fillterData.status_alert = dto.data_alarm_status_alert;
            }
            else if (dto.alarmStatusSet == 3) {
                fillterData.recovery_warning = dto.data_alarm_recovery_warning;
            }
            else if (dto.alarmStatusSet == 4) {
                fillterData.recovery_alert = dto.data_alarm_recovery_alert;
            }
            if (dto.alarm_status) {
                fillterData.alarm_status = dto.alarm_status;
            }
            if (dto.data_alarm) {
                fillterData.data_alarm = dto.data_alarm;
            }
            let new_count_alarm = 0;
            try {
                const countResult = await this.count_alarmprocesslog(fillterData);
                new_count_alarm = parseInt(countResult) || 0;
            }
            catch (error) {
                console.error('Error counting alarm process log:', error);
                new_count_alarm = 0;
            }
            if (new_count_alarm == 0) {
                const new_count_alarm = parseInt('0');
                return new_count_alarm;
            }
            else {
                return new_count_alarm;
            }
        }
        catch (error) {
            console.error('Error in countDataEmail:', error);
            throw error;
        }
    }
    async manageAlarmLog(inputCreate, setdataChk, validateCount) {
        try {
            let countAlarm = 0;
            try {
                const countResult = await this.count_alarmprocesslog(setdataChk);
                countAlarm = parseInt(countResult) || 0;
            }
            catch (error) {
                console.error('Error counting alarm process log:', error);
                countAlarm = 0;
            }
            console.log('------------manageAlarmLog----------------');
            console.log('setdataChk=>');
            console.info(setdataChk);
            console.log('countAlarm=>' + countAlarm);
            console.log('validateCount=>' + validateCount);
            console.log('inputCreate=>');
            console.info(inputCreate);
            if (countAlarm < validateCount) {
                console.log('manageAlarmLog case 1');
                if (countAlarm == 0) {
                    console.log('countAlarm=' + countAlarm);
                    await this.create_alarmprocesslog(inputCreate);
                    await this.create_alarmprocesslogtemp(inputCreate);
                }
            }
            else if (countAlarm > validateCount) {
                console.log('manageAlarmLog case 2');
                console.log('countAlarm=' + countAlarm);
                await this.delete_alarmprocesslog({
                    alarm_action_id: setdataChk.alarm_action_id,
                    device_id: setdataChk.device_id,
                    type_id: setdataChk.type_id,
                    date_now: setdataChk.date,
                    data_alarm: setdataChk.data_alarm,
                });
            }
        }
        catch (error) {
            console.error('Error in manageAlarmLog:', error);
            throw error;
        }
    }
    async checkExistingLogsToday(setdataChk) {
        const today = format.getCurrentDatenow();
        const time = format.getCurrentTimenow();
        return await this.alarmprocesslogRepository.find({
            where: {
                alarm_action_id: setdataChk.alarm_action_id,
                device_id: setdataChk.device_id,
                type_id: setdataChk.type_id,
                date: today,
                time: time,
            },
        });
    }
    async __manageAlarmLogRecovery(inputCreate, setdataChk, validateCount) {
        try {
            await this.entityManager.transaction(async (transactionalEntityManager) => {
                var countAlarm = 0;
                try {
                    const countResult = await this.count_alarmprocesslog(setdataChk);
                    countAlarm = parseInt(countResult) || 0;
                }
                catch (error) {
                    console.error('Error counting alarm process log:', error);
                    countAlarm = 0;
                }
                console.log('------------manageAlarmLogRecovery----------------');
                console.log('countAlarm=>' + countAlarm);
                console.log('validateCount=>' + validateCount);
                const existingLogs = await this.checkExistingLogsToday(setdataChk);
                if (existingLogs.length == 0) {
                    console.log('No logs today, creating new log');
                    await this.create_alarmprocesslog(inputCreate);
                    await this.create_alarmprocesslogtemp(inputCreate);
                }
                else if (countAlarm >= validateCount) {
                    console.log('Exceeds limit, deleting old and creating new');
                    await this.delete_alarmprocesslog_Recovery({
                        alarm_action_id: setdataChk.alarm_action_id,
                        device_id: setdataChk.device_id,
                        type_id: setdataChk.type_id,
                    });
                    await this.create_alarmprocesslog(inputCreate);
                    await this.create_alarmprocesslogtemp(inputCreate);
                }
            });
        }
        catch (error) {
            console.error('Error in manageAlarmLogRecovery:', error);
            throw error;
        }
    }
    async manageAlarmLogRecovery(inputCreate, setdataChk, validateCount) {
        try {
            const today = format.getCurrentDatenow();
            const currentTime = format.getCurrentTimenow();
            const isDuplicate = await this.checkExactDuplicate({
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: inputCreate.date,
                time: inputCreate.time,
                alarm_status: inputCreate.alarm_status,
                data: inputCreate.data,
            });
            console.log('Alarm Log Creation Check:', {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                time: inputCreate.time,
                status: inputCreate.alarm_status,
                value: inputCreate.data,
            });
            if (isDuplicate) {
                console.log('Duplicate log found, skipping creation');
                return;
            }
            await this.entityManager.transaction(async (transactionalEntityManager) => {
                const today = format.getCurrentDatenow();
                const time = format.getCurrentTimenow();
                const existingLogs = await transactionalEntityManager
                    .createQueryBuilder(alarmprocesslog_entity_1.alarmprocesslog, 'log')
                    .setLock('pessimistic_write')
                    .where('log.alarm_action_id = :alarmActionId', {
                    alarmActionId: inputCreate.alarm_action_id,
                })
                    .andWhere('log.device_id = :deviceId', {
                    deviceId: inputCreate.device_id,
                })
                    .andWhere('log.type_id = :typeId', { typeId: inputCreate.type_id })
                    .andWhere('log.date = :date', { date: today })
                    .andWhere('log.time = :time', { time: time })
                    .getMany();
                const recentLogs = existingLogs.filter((log) => {
                    const today = format.getCurrentDatenow();
                    const time = format.getCurrentTimenow();
                    const logTime = format.timeToMinutes(log.time);
                    const currentTimeMin = format.timeToMinutes(currentTime);
                    return currentTimeMin - logTime <= 5;
                });
                if (recentLogs.length > 0) {
                    console.log('Recent logs exist within 1 minutes, skipping creation');
                    return;
                }
                if (existingLogs.length >= validateCount) {
                    console.log('Maximum logs per day reached, deleting oldest');
                    const oldestLog = existingLogs.sort((a, b) => new Date(a.createddate).getTime() -
                        new Date(b.createddate).getTime())[0];
                    await transactionalEntityManager.remove(alarmprocesslog_entity_1.alarmprocesslog, oldestLog);
                }
                console.log('Creating new log');
                const newLog = this.alarmprocesslogRepository.create(inputCreate);
                await transactionalEntityManager.save(newLog);
                const newTempLog = this.alarmprocesslogtempRepository.create(inputCreate);
                await transactionalEntityManager.save(newTempLog);
            });
        }
        catch (error) {
            if (error.code == '23505') {
                console.log('Duplicate prevented by database constraint');
                return;
            }
            console.error('Error in manageAlarmLogRecovery:', error);
            throw error;
        }
    }
    async checkDuplicateLogOne(inputCreate) {
        const today = format.getCurrentDatenow();
        const time = format.getCurrentTimenow();
        const existing = await this.alarmprocesslogtempRepository.findOne({
            where: {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: today,
                time: time,
                alarm_status: inputCreate.alarm_status,
            },
        });
        console.log('checkDuplicateLogOne->inputCreate->');
        console.info(inputCreate);
        console.log('today->' + today);
        console.log('time->' + time);
        console.log('existing->' + existing);
        return !!existing;
    }
    async checkDuplicateLogOne1(inputCreate) {
        const today = format.getCurrentDatenow();
        const time = format.getCurrentTimenow();
        const existing = await this.alarmprocesslogtempRepository.findOne({
            where: {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: today,
                time: time,
                alarm_status: inputCreate.alarm_status,
            },
        });
        return !!existing;
    }
    async checkDuplicateLogTwo(inputCreate) {
        const today = format.getCurrentDatenow();
        const time = format.getCurrentTimenow();
        const existing = await this.alarmprocesslogtempRepository.findOne({
            where: {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                date: today,
                time: time,
                alarm_status: inputCreate.alarm_status,
            },
        });
        return !!existing;
    }
    async checkDuplicateLogSensor(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogtempRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async checkDuplicateLogIO(dto) {
        console.log(`dto=`);
        console.info(dto);
        try {
            const query = await this.alarmprocesslogRepository.createQueryBuilder('l');
            var countRs = await query.select('l.*');
            query.where('1=1');
            if (dto.alarm_action_id) {
                query.andWhere('l.alarm_action_id=:alarm_action_id', {
                    alarm_action_id: dto.alarm_action_id,
                });
            }
            if (dto.device_id) {
                query.andWhere('l.device_id=:device_id', { device_id: dto.device_id });
            }
            if (dto.type_id) {
                query.andWhere('l.type_id=:type_id', { type_id: dto.type_id });
            }
            if (dto.alarm_type) {
                query.andWhere('l.alarm_type=:alarm_type', {
                    alarm_type: dto.alarm_type,
                });
            }
            if (dto.event) {
                query.andWhere('l.event=:event', { event: dto.event });
            }
            if (dto.date) {
                query.andWhere('l.date=:date', { date: dto.date });
            }
            if (dto.time) {
                query.andWhere('l.time=:time', { time: dto.time });
            }
            if (dto.status) {
                query.andWhere('l.status=:status', { status: dto.status });
            }
            if (dto.data) {
                query.andWhere('l.data=:data', { data: dto.data });
            }
            if (dto.data_alarm) {
                query.andWhere('l.data_alarm=:data_alarm', {
                    data_alarm: dto.data_alarm,
                });
            }
            if (dto.status_warning) {
                query.andWhere('l.status_warning=:status_warning', {
                    status_warning: dto.status_warning,
                });
            }
            if (dto.recovery_warning) {
                query.andWhere('l.recovery_warning=:recovery_warning', {
                    recovery_warning: dto.recovery_warning,
                });
            }
            if (dto.status_alert) {
                query.andWhere('l.status_alert=:status_alert', {
                    status_alert: dto.status_alert,
                });
            }
            if (dto.recovery_alert) {
                query.andWhere('l.recovery_alert=:recovery_alert', {
                    recovery_alert: dto.recovery_alert,
                });
            }
            if (dto.alarm_status) {
                query.andWhere('l.alarm_status=:alarm_status', {
                    alarm_status: dto.alarm_status,
                });
            }
            query.printSql();
            query.maxExecutionTime(10000);
            query.getSql();
            var count = await query.getCount();
            let tempCounts = {};
            tempCounts.count = countRs;
            console.log(`count =>` + count);
            console.log(`tempCountt.count =>` + tempCounts.count);
            query.orderBy('l.createddate', 'DESC');
            query.addOrderBy('l.updateddate', 'DESC');
            return await query.getRawMany();
        }
        catch (error) {
            var error1 = JSON.stringify(error);
            var error2 = JSON.parse(error1);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    args: { errorMessage: error2 },
                },
            });
        }
    }
    async manageAlarmLogRecoveryOne(inputCreate, setdataChk, validateCount) {
        try {
            const today = format.getCurrentDatenow();
            const currentTime = format.getCurrentTimenow();
            const isDuplicate = await this.checkExactDuplicate({
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: inputCreate.date,
                time: inputCreate.time,
                alarm_status: inputCreate.alarm_status,
                data: inputCreate.data,
            });
            console.log('Alarm Log Creation Check:', {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                time: inputCreate.time,
                status: inputCreate.alarm_status,
                value: inputCreate.data,
            });
            if (isDuplicate) {
                console.log('Duplicate log found, skipping creation');
                return;
            }
            await this.entityManager.transaction(async (transactionalEntityManager) => {
                const today = format.getCurrentDatenow();
                const time = format.getCurrentTimenow();
                const existingLogs = await transactionalEntityManager
                    .createQueryBuilder(alarmprocesslog_entity_1.alarmprocesslog, 'log')
                    .setLock('pessimistic_write')
                    .where('log.alarm_action_id = :alarmActionId', {
                    alarmActionId: inputCreate.alarm_action_id,
                })
                    .andWhere('log.device_id = :deviceId', {
                    deviceId: inputCreate.device_id,
                })
                    .andWhere('log.type_id = :typeId', { typeId: inputCreate.type_id })
                    .andWhere('log.date = :date', { date: today })
                    .andWhere('log.time = :time', { time: time })
                    .getMany();
                const recentLogs = existingLogs.filter((log) => {
                    const today = format.getCurrentDatenow();
                    const time = format.getCurrentTimenow();
                    const logTime = format.timeToMinutes(log.time);
                    const currentTimeMin = format.timeToMinutes(currentTime);
                    return currentTimeMin - logTime <= 5;
                });
                if (recentLogs.length > 0) {
                    console.log('Recent logs exist within 5 minutes, skipping creation');
                    return;
                }
                if (existingLogs.length >= validateCount) {
                    console.log('Maximum logs per day reached, deleting oldest');
                    const oldestLog = existingLogs.sort((a, b) => new Date(a.createddate).getTime() -
                        new Date(b.createddate).getTime())[0];
                    await transactionalEntityManager.remove(alarmprocesslog_entity_1.alarmprocesslog, oldestLog);
                }
                const newTempLog = this.alarmprocesslogtempRepository.create(inputCreate);
                await transactionalEntityManager.save(newTempLog);
            });
        }
        catch (error) {
            if (error.code == '23505') {
                console.log('Duplicate prevented by database constraint');
                return;
            }
            console.error('Error in manageAlarmLogRecovery:', error);
            throw error;
        }
    }
    async manageAlarmLogRecoveryOnec(inputCreate, setdataChk, validateCount) {
        try {
            const today = format.getCurrentDatenow();
            const currentTime = format.getCurrentTimenow();
            const isDuplicate = await this.checkExactDuplicate({
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: inputCreate.date,
                time: inputCreate.time,
                alarm_status: inputCreate.alarm_status,
                data: inputCreate.data,
            });
            console.log('Alarm Log Creation Check:', {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                time: inputCreate.time,
                status: inputCreate.alarm_status,
                value: inputCreate.data,
            });
            if (isDuplicate) {
                console.log('Duplicate log found, skipping creation');
                return;
            }
            await this.entityManager.transaction(async (transactionalEntityManager) => {
                const today = format.getCurrentDatenow();
                const time = format.getCurrentTimenow();
                const existingLogs = await transactionalEntityManager
                    .createQueryBuilder(alarmprocesslog_entity_1.alarmprocesslog, 'log')
                    .setLock('pessimistic_write')
                    .where('log.alarm_action_id = :alarmActionId', {
                    alarmActionId: inputCreate.alarm_action_id,
                })
                    .andWhere('log.device_id = :deviceId', {
                    deviceId: inputCreate.device_id,
                })
                    .andWhere('log.type_id = :typeId', { typeId: inputCreate.type_id })
                    .andWhere('log.date = :date', { date: today })
                    .andWhere('log.time = :time', { time: time })
                    .getMany();
                const recentLogs = existingLogs.filter((log) => {
                    const today = format.getCurrentDatenow();
                    const time = format.getCurrentTimenow();
                    const logTime = format.timeToMinutes(log.time);
                    const currentTimeMin = format.timeToMinutes(currentTime);
                    return currentTimeMin - logTime <= 5;
                });
                if (recentLogs.length > 0) {
                    console.log('Recent logs exist within 5 minutes, skipping creation');
                    return;
                }
                if (existingLogs.length >= validateCount) {
                    console.log('Maximum logs per day reached, deleting oldest');
                    const oldestLog = existingLogs.sort((a, b) => new Date(a.createddate).getTime() -
                        new Date(b.createddate).getTime())[0];
                    await transactionalEntityManager.remove(alarmprocesslog_entity_1.alarmprocesslog, oldestLog);
                }
                const newTempLog = this.alarmprocesslogtempRepository.create(inputCreate);
                await transactionalEntityManager.save(newTempLog);
            });
        }
        catch (error) {
            if (error.code == '23505') {
                console.log('Duplicate prevented by database constraint');
                return;
            }
            console.error('Error in manageAlarmLogRecovery:', error);
            throw error;
        }
    }
    async manageAlarmLogRecoveryTwo(inputCreate, setdataChk, validateCount) {
        try {
            const today = format.getCurrentDatenow();
            const currentTime = format.getCurrentTimenow();
            const isDuplicate = await this.checkExactDuplicate({
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: inputCreate.date,
                time: inputCreate.time,
                alarm_status: inputCreate.alarm_status,
                data: inputCreate.data,
            });
            console.log('Alarm Log Creation Check:', {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                time: inputCreate.time,
                status: inputCreate.alarm_status,
                value: inputCreate.data,
            });
            if (isDuplicate) {
                console.log('Duplicate log found, skipping creation');
                return;
            }
            await this.entityManager.transaction(async (transactionalEntityManager) => {
                const today = format.getCurrentDatenow();
                const time = format.getCurrentTimenow();
                const existingLogs = await transactionalEntityManager
                    .createQueryBuilder(alarmprocesslog_entity_1.alarmprocesslog, 'log')
                    .setLock('pessimistic_write')
                    .where('log.alarm_action_id = :alarmActionId', {
                    alarmActionId: inputCreate.alarm_action_id,
                })
                    .andWhere('log.device_id = :deviceId', {
                    deviceId: inputCreate.device_id,
                })
                    .andWhere('log.alarm_status = :alarm_status', {
                    alarm_status: inputCreate.alarm_status,
                })
                    .andWhere('log.date = :date', { date: today })
                    .andWhere('log.time = :time', { time: time })
                    .getMany();
                const recentLogs = existingLogs.filter((log) => {
                    const today = format.getCurrentDatenow();
                    const time = format.getCurrentTimenow();
                    const logTime = format.timeToMinutes(log.time);
                    const currentTimeMin = format.timeToMinutes(currentTime);
                    return currentTimeMin - logTime <= 5;
                });
                if (recentLogs.length > 0) {
                    console.log('Recent logs exist within 5 minutes, skipping creation');
                    return;
                }
                if (existingLogs.length >= validateCount) {
                    console.log('Maximum logs per day reached, deleting oldest');
                    const oldestLog = existingLogs.sort((a, b) => new Date(a.createddate).getTime() -
                        new Date(b.createddate).getTime())[0];
                    await transactionalEntityManager.remove(alarmprocesslog_entity_1.alarmprocesslog, oldestLog);
                }
                const newTempLog = this.alarmprocesslogtempRepository.create(inputCreate);
                await transactionalEntityManager.save(newTempLog);
            });
        }
        catch (error) {
            if (error.code == '23505') {
                console.log('Duplicate prevented by database constraint');
                return;
            }
            console.error('Error in manageAlarmLogRecovery:', error);
            throw error;
        }
    }
    async checkExactDuplicate(criteria) {
        const existing = await this.alarmprocesslogRepository.findOne({
            where: {
                alarm_action_id: criteria.alarm_action_id,
                device_id: criteria.device_id,
                type_id: criteria.type_id,
                date: criteria.date,
                time: criteria.time,
                alarm_status: criteria.alarm_status,
                data: criteria.data,
            },
        });
        return !!existing;
    }
    static timeToMinutes(timeString) {
        const [hours, minutes] = timeString.split(':').map(Number);
        return hours * 60 + minutes;
    }
    async checkDuplicateLog(inputCreate) {
        const today = format.getCurrentDatenow();
        const time = format.getCurrentTimenow();
        const existing = await this.alarmprocesslogRepository.findOne({
            where: {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: today,
                time: time,
                alarm_status: inputCreate.alarm_status,
            },
        });
        return !!existing;
    }
    async checkDuplicateTempLog(inputCreate) {
        const today = format.getCurrentDatenow();
        const time = format.getCurrentTimenow();
        const existing = await this.alarmprocesslogtempRepository.findOne({
            where: {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: today,
                time: time,
                alarm_status: inputCreate.alarm_status,
            },
        });
        return !!existing;
    }
    async _manageAlarmLogEmail(inputCreate, setdataChk, validateCount) {
        const queryRunner = this.dataSource.createQueryRunner();
        try {
            await queryRunner.connect();
            await queryRunner.startTransaction();
            const countAlarm = await this.count_alarmprocesslogemail(setdataChk);
            if (countAlarm < validateCount) {
                if (countAlarm == 0) {
                    await this.create_alarmprocesslogemail(inputCreate);
                    await this.create_alarmprocesslogtemp(inputCreate);
                }
            }
            else if (countAlarm > validateCount) {
                await this.delete_alarmprocesslog_email(setdataChk);
            }
            await queryRunner.commitTransaction();
        }
        catch (error) {
            await queryRunner.rollbackTransaction();
            console.error('Error in manageAlarmLogEmail:', error);
            if (error.code == '23505') {
                console.warn('Duplicate entry prevented by unique constraint');
            }
            else {
                throw error;
            }
        }
        finally {
            await queryRunner.release();
        }
    }
    async checkExactDuplicateEmail(criteria) {
        const existing = await this.alarmprocesslogemailRepository.findOne({
            where: {
                alarm_action_id: criteria.alarm_action_id,
                device_id: criteria.device_id,
                type_id: criteria.type_id,
                date: criteria.date,
                time: criteria.time,
                alarm_status: criteria.alarm_status,
                data: criteria.data,
            },
        });
        return !!existing;
    }
    async checkDuplicateLogEmailOne(inputCreate) {
        const today = format.getCurrentDatenow();
        const time = format.getCurrentTimenow();
        const existing = await this.alarmprocesslogemailRepository.findOne({
            where: {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: today,
                time: time,
                alarm_status: inputCreate.alarm_status,
            },
        });
        return !!existing;
    }
    async manageAlarmLogEmail(inputCreate, setdataChk, validateCount) {
        try {
            const today = format.getCurrentDatenow();
            const currentTime = format.getCurrentTimenow();
            const isDuplicate = await this.checkExactDuplicateEmail({
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                date: inputCreate.date,
                time: inputCreate.time,
                alarm_status: inputCreate.alarm_status,
                data: inputCreate.data,
            });
            console.log('Alarm Email Log Creation Check:', {
                alarm_action_id: inputCreate.alarm_action_id,
                device_id: inputCreate.device_id,
                type_id: inputCreate.type_id,
                time: inputCreate.time,
                status: inputCreate.alarm_status,
                value: inputCreate.data,
            });
            if (isDuplicate) {
                console.log('Duplicate Email log found, skipping creation');
                return;
            }
            await this.entityManager.transaction(async (transactionalEntityManager) => {
                const today = format.getCurrentDatenow();
                const time = format.getCurrentTimenow();
                const existingLogs = await transactionalEntityManager
                    .createQueryBuilder(alarmprocesslogemail_entity_1.alarmprocesslogemail, 'log')
                    .setLock('pessimistic_write')
                    .where('log.alarm_action_id = :alarmActionId', {
                    alarmActionId: inputCreate.alarm_action_id,
                })
                    .andWhere('log.device_id = :deviceId', {
                    deviceId: inputCreate.device_id,
                })
                    .andWhere('log.type_id = :typeId', { typeId: inputCreate.type_id })
                    .andWhere('log.date = :date', { date: today })
                    .andWhere('log.time = :time', { time: time })
                    .getMany();
                const recentLogs = existingLogs.filter((log) => {
                    const today = format.getCurrentDatenow();
                    const time = format.getCurrentTimenow();
                    const logTime = format.timeToMinutes(log.time);
                    const currentTimeMin = format.timeToMinutes(currentTime);
                    return currentTimeMin - logTime <= 5;
                });
                if (recentLogs.length > 0) {
                    console.log('Recent Email logs exist within 1 minutes, skipping creation');
                    return;
                }
                if (existingLogs.length >= validateCount) {
                    console.log('Maximum Email logs per day reached, deleting oldest');
                    const oldestLog = existingLogs.sort((a, b) => new Date(a.createddate).getTime() -
                        new Date(b.createddate).getTime())[0];
                    await transactionalEntityManager.remove(alarmprocesslogemail_entity_1.alarmprocesslogemail, oldestLog);
                }
                console.log('Creating new Email log');
                const newLog = this.alarmprocesslogemailRepository.create(inputCreate);
                await transactionalEntityManager.save(newLog);
                const newTempLog = this.alarmprocesslogtempRepository.create(inputCreate);
                await transactionalEntityManager.save(newTempLog);
            });
        }
        catch (error) {
            if (error.code == '23505') {
                console.log('Duplicate Email prevented by database constraint');
                return;
            }
            console.error('Error in alarmprocesslogemailRepository:', error);
            throw error;
        }
    }
    async manageAlarmLogRecoveryEmail(inputCreate, setdataChk, validateCount) {
        try {
            await this.entityManager.transaction(async (transactionalEntityManager) => {
                var countAlarm = 0;
                try {
                    const countResult = await this.count_alarmprocesslogemail(setdataChk);
                    countAlarm = parseInt(countResult) || 0;
                }
                catch (error) {
                    console.error('Error counting alarm process log:', error);
                    countAlarm = 0;
                }
                console.log('------------manageAlarmLogRecovery----------------');
                console.log('countAlarm=>' + countAlarm);
                console.log('validateCount=>' + validateCount);
                if (countAlarm < validateCount) {
                    console.log('manageAlarmLog case 1');
                    if (countAlarm == 0) {
                        await this.delete_alarmprocesslog_Recovery({
                            alarm_action_id: setdataChk.alarm_action_id,
                            device_id: setdataChk.device_id,
                            type_id: setdataChk.type_id,
                            date_now: setdataChk.date,
                        });
                        await this.create_alarmprocesslogemail(inputCreate);
                        await this.create_alarmprocesslogtemp(inputCreate);
                    }
                    else if (countAlarm > 0 && countAlarm < validateCount) {
                        console.log('Existing logs within limit, no action needed');
                    }
                }
                else if (countAlarm > validateCount) {
                    console.log('manageAlarmLog case 2');
                    await this.delete_alarmprocesslog_email({
                        alarm_action_id: setdataChk.alarm_action_id,
                        device_id: setdataChk.device_id,
                        type_id: setdataChk.type_id,
                    });
                }
            });
        }
        catch (error) {
            console.error('Error in manageAlarmLogRecovery:', error);
            throw error;
        }
    }
    async manageAlarmLogLine(inputCreate, setdataChk, validateCount) {
        try {
            const countAlarm = await this.count_alarmprocesslogline(setdataChk);
            if (countAlarm < validateCount) {
                const countCheck = await this.count_alarmprocesslogline(Object.assign(Object.assign({}, setdataChk), { time: format.getCurrentTimenow() }));
                var count_alarm = 0;
                try {
                    const countResult = await this.count_alarmprocesslogline(setdataChk);
                    count_alarm = parseInt(countResult) || 0;
                }
                catch (error) {
                    console.error('Error counting alarm process log:', error);
                    count_alarm = 0;
                }
                if (count_alarm == 0) {
                    await this.create_alarmprocesslogline(inputCreate);
                    await this.create_alarmprocesslogtemp(inputCreate);
                }
            }
            else if (countAlarm > validateCount) {
                await this.delete_alarmprocesslog_line({
                    alarm_action_id: setdataChk.alarm_action_id,
                    device_id: setdataChk.device_id,
                    type_id: setdataChk.type_id,
                    date_now: setdataChk.date,
                    data_alarm: setdataChk.data_alarm,
                });
            }
        }
        catch (error) {
            console.error('Error in manageAlarmLogLine:', error);
            throw error;
        }
    }
    async manageAlarmLogsms(inputCreate, setdataChk, validateCount) {
        var countAlarm = 0;
        try {
            const countResult = await this.count_alarmprocesslogsms(setdataChk);
            countAlarm = parseInt(countResult) || 0;
        }
        catch (error) {
            console.error('Error counting alarm countResult log:', error);
            countAlarm = 0;
        }
        if (countAlarm < validateCount) {
            const countCheck = await this.count_alarmprocesslogsms(Object.assign(Object.assign({}, setdataChk), { time: format.getCurrentTimenow() }));
            var count_alarm = 0;
            try {
                const countResult = await this.count_alarmprocesslogsms(setdataChk);
                count_alarm = parseInt(countResult) || 0;
            }
            catch (error) {
                console.error('Error counting alarm process log:', error);
                count_alarm = 0;
            }
            if (count_alarm == 0) {
                await this.create_alarmprocesslogsms(inputCreate);
                await this.create_alarmprocesslogtemp(inputCreate);
            }
        }
        else if (countAlarm > validateCount) {
            await this.delete_alarmprocesslog_sms({
                alarm_action_id: setdataChk.alarm_action_id,
                device_id: setdataChk.device_id,
                type_id: setdataChk.type_id,
                date_now: setdataChk.date,
                data_alarm: setdataChk.data_alarm,
            });
        }
    }
    async manageAlarmLogtelegram(inputCreate, setdataChk, validateCount) {
        const countAlarm = await this.count_alarmprocesslogtelegram(setdataChk);
        if (countAlarm <= validateCount) {
            const countCheck = await this.count_alarmprocesslogtelegram(Object.assign(Object.assign({}, setdataChk), { time: format.getCurrentTimenow() }));
            var count_alarm = 0;
            try {
                const countResult = await this.count_alarmprocesslogtelegram(setdataChk);
                count_alarm = parseInt(countResult) || 0;
            }
            catch (error) {
                console.error('Error counting alarm process log:', error);
                count_alarm = 0;
            }
            if (count_alarm == 0) {
                await this.create_alarmprocesslogtelegram(inputCreate);
                await this.create_alarmprocesslogtemp(inputCreate);
            }
        }
        else if (countAlarm > validateCount) {
            await this.delete_alarmprocesslog_telegram({
                alarm_action_id: setdataChk.alarm_action_id,
                device_id: setdataChk.device_id,
                type_id: setdataChk.type_id,
                date_now: setdataChk.date,
                data_alarm: setdataChk.data_alarm,
            });
        }
    }
    async testGmailConnection() {
        try {
            const nodemailer = require('nodemailer');
            const portsToTest = [465, 587];
            for (const port of portsToTest) {
                this.logger.log(`Testing Gmail connection on port ${port}...`);
                const transporter = nodemailer.createTransport({
                    host: 'smtp.gmail.com',
                    port: port,
                    secure: port == 465,
                    auth: {
                        user: 'icmon0955@gmail.com',
                        pass: 'kvemegelpacfsfdd',
                    },
                    connectionTimeout: 30000,
                    greetingTimeout: 30000,
                    tls: {
                        rejectUnauthorized: false,
                    },
                });
                try {
                    await transporter.verify();
                    this.logger.log(`✓ Gmail connection successful on port ${port}`);
                    var satatusData = true;
                    var content = 'Alarm Test';
                    var to = 'icmon0955@gmail.com';
                    var subject = 'Alarm Test';
                    var content = 'Alarm Test';
                    console.log(`---sendemail--`);
                    console.log(`to--` + to);
                    console.log(`subject--` + subject);
                    console.log(`content--` + content);
                    let ResultData = await this.sendEmail(to, subject, content);
                    var resalt = {
                        satatus: satatusData,
                        msg: `✓ Gmail connection successful on port ${port}`,
                        to,
                        subject,
                        content,
                        ResultData,
                    };
                    return resalt;
                }
                catch (portError) {
                    this.logger.warn(`✗ Gmail connection failed on port ${port}: ${portError.message}`);
                }
            }
            this.logger.error('All Gmail connection attempts failed');
            return false;
        }
        catch (error) {
            this.logger.error('Gmail connection test failed completely:', error);
            return false;
        }
    }
    async deviceeventmap(dto) {
        console.log(`deviceeventmap Dto=`);
        console.info(dto);
        try {
            const device_id = dto.device_id || '';
            const alarm_action_id = dto.alarm_action_id || '';
            const sort = dto.sort;
            const query = this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'e.alarm_action_id as alarm_action_id',
                'd.*',
                't.type_name AS type_name',
            ]);
            query.innerJoin('sd_iot_alarm_device_event', 'e', 'e.device_id = d.device_id AND d.status = :status', { status: 1 });
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.where('1=1');
            if (dto.bucket) {
                const bucket = dto.bucket;
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (device_id) {
                query.andWhere('e.device_id = :device_id', { device_id });
            }
            if (alarm_action_id) {
                query.andWhere('e.alarm_action_id = :alarm_action_id', {
                    alarm_action_id,
                });
            }
            query.orderBy('e.device_id', 'ASC');
            query.maxExecutionTime(10000);
            console.log('SQL:', query.getSql());
            console.log('Parameters:', query.getParameters());
            return await query.getRawMany();
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async devicealarmmap(dto) {
        console.log(`devicealarmmap Dto=`);
        console.info(dto);
        try {
            const device_id = dto.device_id || '';
            const alarm_action_id = dto.alarm_action_id || '';
            const sort = dto.sort;
            const query = this.DeviceRepository.createQueryBuilder('d');
            query.select([
                'e.alarm_action_id as alarm_action_id',
                'd.*',
                't.type_name AS type_name',
            ]);
            query.innerJoin('sd_iot_device_type', 't', 't.type_id = d.type_id');
            query.innerJoin('sd_iot_alarm_device', 'e', 'e.device_id = d.device_id AND d.status = :status', { status: 1 });
            query.where('1=1');
            if (dto.bucket) {
                const bucket = dto.bucket;
                query.andWhere('d.bucket = :bucket', { bucket });
            }
            if (device_id) {
                query.andWhere('e.device_id = :device_id', { device_id });
            }
            if (alarm_action_id) {
                query.andWhere('e.alarm_action_id = :alarm_action_id', {
                    alarm_action_id,
                });
            }
            query.orderBy('e.device_id', 'ASC');
            query.maxExecutionTime(10000);
            console.log('SQL:', query.getSql());
            console.log('Parameters:', query.getParameters());
            return await query.getRawMany();
        }
        catch (err) {
            this.logger.error(`Error ${JSON.stringify(err)}`);
            throw new common_1.UnprocessableEntityException({
                status: common_1.HttpStatus.UNPROCESSABLE_ENTITY,
                error: {
                    errorMessage: err.message,
                },
            });
        }
    }
    async createDashboardConfig(dto) {
        const existingConfig = await this.dashboardConfigRepository.findOne({
            where: {
                name: dto.name,
                location_id: dto.location_id,
            },
        });
        if (existingConfig) {
            console.log(`Update: พบข้อมูลชื่อ "${dto.name}" ที่ Location ${dto.location_id}`);
            existingConfig.config_data = dto.config;
            existingConfig.updated_date = new Date();
            return await this.dashboardConfigRepository.save(existingConfig);
        }
        else {
            console.log(`Create: ไม่พบข้อมูลเดิม กำลังสร้าง Row ใหม่...`);
            const newConfig = this.dashboardConfigRepository.create({
                name: dto.name,
                location_id: dto.location_id,
                config_data: dto.config,
                created_date: new Date(),
                updated_date: new Date(),
            });
            return await this.dashboardConfigRepository.save(newConfig);
        }
    }
    async findOrCreateConfig(name, locationId) {
        let config = await this.dashboardConfigRepository.findOne({
            where: {
                name: name,
                location_id: locationId,
            },
        });
        if (!config) {
            console.log(`Get: ไม่พบ "${name}" ที่ Location ${locationId} กำลังสร้างข้อมูลเริ่มต้น...`);
            const newConfig = this.dashboardConfigRepository.create({
                name: name,
                location_id: locationId,
                config_data: { groups: [], updated_at: new Date().toISOString() },
                created_date: new Date(),
                updated_date: new Date(),
            });
            config = await this.dashboardConfigRepository.save(newConfig);
        }
        return config;
    }
    async findOneDashboardConfig(id) {
        const config = await this.dashboardConfigRepository.findOne({
            where: { id: id },
        });
        if (!config)
            throw new common_1.NotFoundException(`Config ID ${id} not found`);
        return config;
    }
    async upsertDashboardConfig(dto) {
        const existingConfig = await this.dashboardConfigRepository.findOne({
            where: {
                location_id: dto.location_id,
            },
        });
        if (existingConfig) {
            console.log(`Matching record found for "${dto.name}" at location ${dto.location_id}. Updating...`);
            Object.assign(existingConfig, dto);
            return await this.dashboardConfigRepository.save(existingConfig);
        }
        else {
            console.log(`No match found. Creating new record for "${dto.name}" at location ${dto.location_id}.`);
            const newConfig = this.dashboardConfigRepository.create(dto);
            return await this.dashboardConfigRepository.save(newConfig);
        }
    }
    async findAllDashboardConfig() {
        return await this.dashboardConfigRepository.find();
    }
    async findByName(name) {
        return await this.dashboardConfigRepository.findOne({ where: { name } });
    }
    async updateDashboard(id, dto) {
        const config = await this.dashboardConfigRepository.findOneBy({ id });
        Object.assign(config, dto);
        return await this.dashboardConfigRepository.save(config);
    }
    async updateDashboardConfig(id, dto) {
        const config = await this.findOneDashboardConfig(id);
        Object.assign(config, dto);
        return await this.dashboardConfigRepository.save(config);
    }
    async removeDashboardConfig(id) {
        const result = await this.dashboardConfigRepository.delete(id);
        if (result.affected === 0) {
            throw new common_1.NotFoundException(`ID ${id} not found`);
        }
    }
};
SettingsService = SettingsService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(3, (0, common_1.Inject)('MQTT_CLIENT')),
    __param(4, (0, typeorm_1.InjectRepository)(dashboard_config_entity_1.dashboardConfig)),
    __param(5, (0, typeorm_1.InjectRepository)(setting_entity_1.Setting)),
    __param(6, (0, typeorm_1.InjectRepository)(location_entity_1.Location)),
    __param(7, (0, typeorm_1.InjectRepository)(type_entity_1.Type)),
    __param(8, (0, typeorm_1.InjectRepository)(sensor_entity_1.Sensor)),
    __param(9, (0, typeorm_1.InjectRepository)(group_entity_1.Group)),
    __param(10, (0, typeorm_1.InjectRepository)(mqtt_entity_1.Mqtt)),
    __param(11, (0, typeorm_1.InjectRepository)(api_entity_1.Api)),
    __param(12, (0, typeorm_1.InjectRepository)(devicetype_entity_1.DeviceType)),
    __param(13, (0, typeorm_1.InjectRepository)(device_entity_1.Device)),
    __param(14, (0, typeorm_1.InjectRepository)(email_entity_1.Email)),
    __param(15, (0, typeorm_1.InjectRepository)(host_entity_1.Host)),
    __param(16, (0, typeorm_1.InjectRepository)(influxdb_entity_1.Influxdb)),
    __param(17, (0, typeorm_1.InjectRepository)(line_entity_1.Line)),
    __param(18, (0, typeorm_1.InjectRepository)(nodered_entity_1.Nodered)),
    __param(19, (0, typeorm_1.InjectRepository)(schedule_entity_1.Schedule)),
    __param(20, (0, typeorm_1.InjectRepository)(sms_entity_1.Sms)),
    __param(21, (0, typeorm_1.InjectRepository)(token_entity_1.Token)),
    __param(22, (0, typeorm_1.InjectRepository)(scheduledevice_entity_1.scheduleDevice)),
    __param(23, (0, typeorm_1.InjectRepository)(deviceaction_entity_1.Deviceaction)),
    __param(24, (0, typeorm_1.InjectRepository)(deviceactionlog_entity_1.Deviceactionlog)),
    __param(25, (0, typeorm_1.InjectRepository)(deviceactionuser_entity_1.Deviceactionuser)),
    __param(26, (0, typeorm_1.InjectRepository)(devivicealarmaction_entity_1.Devicealarmaction)),
    __param(27, (0, typeorm_1.InjectRepository)(telegram_entity_1.Telegram)),
    __param(28, (0, typeorm_1.InjectRepository)(alarmdevice_entity_1.alarmDevice)),
    __param(29, (0, typeorm_1.InjectRepository)(alarmdeviceevent_entity_1.alarmDeviceEvent)),
    __param(30, (0, typeorm_1.InjectRepository)(scheduleprocesslog_entity_1.scheduleprocesslog)),
    __param(31, (0, typeorm_1.InjectRepository)(alarmprocesslog_entity_1.alarmprocesslog)),
    __param(32, (0, typeorm_1.InjectRepository)(alarmprocesslogtemp_entity_1.alarmprocesslogtemp)),
    __param(33, (0, typeorm_1.InjectRepository)(alarmprocesslogmqtt_entity_1.alarmprocesslogmqtt)),
    __param(34, (0, typeorm_1.InjectRepository)(alarmprocesslogemail_entity_1.alarmprocesslogemail)),
    __param(35, (0, typeorm_1.InjectRepository)(alarmprocesslogline_entity_1.alarmprocesslogline)),
    __param(36, (0, typeorm_1.InjectRepository)(alarmprocesslogsms_entity_1.alarmprocesslogsms)),
    __param(37, (0, typeorm_1.InjectRepository)(alarmprocesslogtelegram_entity_1.alarmprocesslogtelegram)),
    __param(38, (0, typeorm_1.InjectRepository)(user_entity_1.User)),
    __param(39, (0, typeorm_1.InjectRepository)(sduserrole_entity_1.SdUserRole)),
    __param(40, (0, typeorm_1.InjectRepository)(rolesaccess_entity_1.SdUserRolesAccess)),
    __param(41, (0, typeorm_1.InjectRepository)(userrolepermission_entity_1.UserRolePermission)),
    __param(42, (0, typeorm_1.InjectRepository)(mqtthost_entity_1.mqtthost)),
    __metadata("design:paramtypes", [mailer_1.MailerService,
        typeorm_2.EntityManager,
        typeorm_2.DataSource,
        microservices_1.ClientProxy,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository,
        typeorm_2.Repository])
], SettingsService);
exports.SettingsService = SettingsService;
//# sourceMappingURL=settings.service.js.map