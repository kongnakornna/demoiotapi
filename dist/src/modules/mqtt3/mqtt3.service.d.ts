import { Repository } from 'typeorm';
import { CreateMqtt2Dto } from '@src/modules/mqtt2/dto/create-mqtt2.dto';
import { UpdateMqtt2Dto } from '@src/modules/mqtt2/dto/update-mqtt2.dto';
import { ClientProxy } from '@nestjs/microservices';
import { User } from '@src/modules/users/entities/user.entity';
import { SdUserRole } from '@src/modules/users/entities/sduserrole.entity';
import { SdUserRolesAccess } from '@src/modules/users/entities/rolesaccess.entity';
import { UserRolePermission } from '@src/modules/users/entities/userrolepermission.entity';
import { DeviceType } from '@src/modules/settings/entities/devicetype.entity';
import { Setting } from '@src/modules/settings/entities/setting.entity';
import { Location } from '@src/modules/settings/entities/location.entity';
import { Type } from '@src/modules/settings/entities/type.entity';
import { Sensor } from '@src/modules/settings/entities/sensor.entity';
import { Group } from '@src/modules/settings/entities/group.entity';
import { Mqtt } from '@src/modules/settings/entities/mqtt.entity';
import { Api } from '@src/modules/settings/entities/api.entity';
import { Device } from '@src/modules/settings/entities/device.entity';
import { Email } from '@src/modules/settings/entities/email.entity';
import { Host } from '@src/modules/settings/entities/host.entity';
import { Influxdb } from '@src/modules/settings/entities/influxdb.entity';
import { Line } from '@src/modules/settings/entities/line.entity';
import { Nodered } from '@src/modules/settings/entities/nodered.entity';
import { Schedule } from '@src/modules/settings/entities/schedule.entity';
import { Sms } from '@src/modules/settings/entities/sms.entity';
import { Token } from '@src/modules/settings/entities/token.entity';
import { scheduleDevice } from '@src/modules/settings/entities/scheduledevice.entity';
import { Deviceaction } from '@src/modules/settings/entities/deviceaction.entity';
import { Deviceactionlog } from '@src/modules/settings/entities/deviceactionlog.entity';
import { Deviceactionuser } from '@src/modules/settings/entities/deviceactionuser.entity';
import { Devicealarmaction } from '@src/modules/settings/entities/devivicealarmaction.entity';
import { Telegram } from '@src/modules/settings/entities/telegram.entity';
import { alarmDevice } from '@src/modules/settings/entities/alarmdevice.entity';
import { alarmDeviceEvent } from '@src/modules/settings/entities/alarmdeviceevent.entity';
import { dashboardConfig } from '@src/modules/settings/entities/dashboard-config.entity';
import { scheduleprocesslog } from '@src/modules/settings/entities/scheduleprocesslog.entity';
import { alarmprocesslog } from '@src/modules/settings/entities/alarmprocesslog.entity';
import { alarmprocesslogtemp } from '@src/modules/settings/entities/alarmprocesslogtemp.entity';
import { alarmprocesslogmqtt } from '@src/modules/settings/entities/alarmprocesslogmqtt.entity';
import { alarmprocesslogemail } from '@src/modules/settings/entities/alarmprocesslogemail.entity';
import { alarmprocesslogline } from '@src/modules/settings/entities/alarmprocesslogline.entity';
import { alarmprocesslogsms } from '@src/modules/settings/entities/alarmprocesslogsms.entity';
import { alarmprocesslogtelegram } from '@src/modules/settings/entities/alarmprocesslogtelegram.entity';
import { mqtthost } from '@src/modules/settings/entities/mqtthost.entity';
import { MqttClient } from 'mqtt';
import { Observable } from 'rxjs';
import 'dotenv/config';
interface MqttConnectionStatus {
    connected: boolean;
    lastConnectionTime: Date | null;
    error: any;
}
export declare class Mqtt3Service {
    private readonly client;
    private DevicealarmactionRepository;
    private readonly dashboardConfigRepository;
    private SettingRepository;
    private LocationRepository;
    private TypeRepository;
    private SensorRepository;
    private GroupRepository;
    private MqttRepository;
    private ApiRepository;
    private DeviceTypeRepository;
    private DeviceRepository;
    private EmailRepository;
    private HostRepository;
    private InfluxdbRepository;
    private LineRepository;
    private NoderedRepository;
    private ScheduleRepository;
    private SmsRepository;
    private TokenRepository;
    private scheduleDeviceRepository;
    private DeviceactionRepository;
    private DeviceactionlogRepository;
    private DeviceactionuserRepository;
    private TelegramRepository;
    private alarmDeviceRepository;
    private alarmDeviceEventRepository;
    private scheduleprocesslogRepository;
    private alarmprocesslogRepository;
    private alarmprocesslogtempRepository;
    private alarmprocesslogmqttRepository;
    private alarmprocesslogemailRepository;
    private alarmprocessloglineRepository;
    private alarmprocesslogsmsRepository;
    private alarmprocesslogtelegramRepository;
    private userRepository;
    private SdUserRoleRepository;
    private SdUserRolesAccessRepository;
    private UserRolePermissionRepository;
    private mqtthostRepository;
    private latestData;
    private mqttClient;
    private connectionStatus;
    private messageStream;
    private readonly logger;
    private messageStreams;
    private messageCache1;
    private subscribedTopics1;
    private isConnected;
    private connectionPromise;
    private subscribedTopics;
    private messageCache;
    constructor(client: ClientProxy, DevicealarmactionRepository: Repository<Devicealarmaction>, dashboardConfigRepository: Repository<dashboardConfig>, SettingRepository: Repository<Setting>, LocationRepository: Repository<Location>, TypeRepository: Repository<Type>, SensorRepository: Repository<Sensor>, GroupRepository: Repository<Group>, MqttRepository: Repository<Mqtt>, ApiRepository: Repository<Api>, DeviceTypeRepository: Repository<DeviceType>, DeviceRepository: Repository<Device>, EmailRepository: Repository<Email>, HostRepository: Repository<Host>, InfluxdbRepository: Repository<Influxdb>, LineRepository: Repository<Line>, NoderedRepository: Repository<Nodered>, ScheduleRepository: Repository<Schedule>, SmsRepository: Repository<Sms>, TokenRepository: Repository<Token>, scheduleDeviceRepository: Repository<scheduleDevice>, DeviceactionRepository: Repository<Deviceaction>, DeviceactionlogRepository: Repository<Deviceactionlog>, DeviceactionuserRepository: Repository<Deviceactionuser>, TelegramRepository: Repository<Telegram>, alarmDeviceRepository: Repository<alarmDevice>, alarmDeviceEventRepository: Repository<alarmDeviceEvent>, scheduleprocesslogRepository: Repository<scheduleprocesslog>, alarmprocesslogRepository: Repository<alarmprocesslog>, alarmprocesslogtempRepository: Repository<alarmprocesslogtemp>, alarmprocesslogmqttRepository: Repository<alarmprocesslogmqtt>, alarmprocesslogemailRepository: Repository<alarmprocesslogemail>, alarmprocessloglineRepository: Repository<alarmprocesslogline>, alarmprocesslogsmsRepository: Repository<alarmprocesslogsms>, alarmprocesslogtelegramRepository: Repository<alarmprocesslogtelegram>, userRepository: Repository<User>, SdUserRoleRepository: Repository<SdUserRole>, SdUserRolesAccessRepository: Repository<SdUserRolesAccess>, UserRolePermissionRepository: Repository<UserRolePermission>, mqtthostRepository: Repository<mqtthost>);
    onModuleInit(): void;
    IsonModuleInit(connectUrl_mqtt: any): Promise<void>;
    isMqttConnected(): boolean;
    private subscribedTopic;
    private messageCached;
    getdevicedataDirecs(topics: string): Promise<any>;
    clearTopicCache(topic?: string): void;
    unsubscribeTopic(topic: string): void;
    onModuleDestroy(): void;
    initializeMqttClient(brokerUrl?: any): Promise<boolean>;
    private updateCache;
    getMqttData(topic: string): Promise<any>;
    publishMessage(topic: string, message: string | object): Promise<{
        success: boolean;
        error?: string;
    }>;
    subscribeToMultipleTopics(topics: string[]): Promise<{
        success: boolean;
        errors?: string[];
    }>;
    unsubscribeFromTopic(topic: string): Promise<{
        success: boolean;
        error?: string;
    }>;
    getConnectionStatus(): boolean;
    getDetailedConnectionStatus(): Promise<{
        isConnected: boolean;
        mqttClientConnected: boolean;
        subscribedTopics: string[];
        cacheSize: number;
    }>;
    clearCache(): void;
    clearTopicCached(topic: string): void;
    getCachedData(topic: any): Promise<any>;
    hasCachedData(topic: string): boolean;
    disconnect(): Promise<void>;
    reconnect(brokerUrl?: string): Promise<boolean>;
    waitForConnection(timeoutMs?: number): Promise<boolean>;
    getMqttClient(): MqttClient | null;
    getSubscribedTopics(): string[];
    getCacheStats(): {
        size: number;
        keys: string[];
    };
    subscribeToTopicWithResponse(topic: string, timeoutMs?: number): Promise<any>;
    subscribeToTopic(topic: string, returnAsPromise?: boolean, timeoutMs?: number): Observable<any> | Promise<any>;
    private cacheTimeout;
    getDataTopics(topics: string): Promise<any>;
    private subscribeToTopicS;
    private waitForMessage;
    private generateTimestamp;
    private processPayload;
    private cacheResult;
    private buildResponse;
    private delay;
    getMqttConnectionStatus(): MqttConnectionStatus;
    checkConnectionStatus(): void;
    checkConnectionStatusMqtt(): Promise<{
        isConnected: any;
        connected: any;
        status: any;
        connectUrl_mqtt: any;
        msg: string;
    }>;
    checkConnectionStatusMqtts(UrlMqtt: any): Promise<{
        url: any;
        isConnect: any;
        isConnected: any;
        connected: any;
        status: any;
        msg: string;
    }>;
    getDataTopicCacheDataMqtt(topics: string): Promise<any>;
    getdMqttdataTopics(topics: any): Promise<void>;
    getMqttTopicData(topics: string, deletecache: any): Promise<any>;
    getMqttTopicDataRS(topics: any, deletecache: any): Promise<void>;
    _getMqttTopicData(topics: string, deletecache: any): Promise<any>;
    getMqttTopicDataV1(topics: string, deletecache: any): Promise<any>;
    getMqttTopicS(topics: string, deletecache: any): Promise<any>;
    getDataTopicCacheData(topics: string): Promise<any>;
    getDataTopic2(topics: string): Promise<any>;
    getDataTopicdevicemqtt(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getDataTopic(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getDataTopicPage(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicPA(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    waitForMessageWithTimeout(topic: string, timeout: number): Promise<any>;
    getMqttTopicPA1(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopic(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicTest(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicSS(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    _2_getMqttTopic(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicSlow(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicFast(topics: string): Promise<any>;
    getDataTopicMqtt(topics: string): Promise<any>;
    getDataTopicCache(topics: string, deletecache: any): Promise<any>;
    getDataFromTopics(topics: string): Promise<string>;
    getDataFromTopicsOL(topics: string): Promise<string>;
    getDataFromTopic(topics: string): Promise<any>;
    _getDataFromTopic(topics: string): Promise<any>;
    publishs(topics: string, payload: any): void;
    publish(topics: string, payload: any): Promise<void>;
    updateData(topics: string, payload: any): Promise<void>;
    getData(topics: string): Promise<any | null>;
    cacheMqttData(topics: string, payload: any): Promise<void>;
    getDataFromCache(topics: string): Promise<any | null>;
    updateLatestData(topics: string, payload: any): void;
    getLatestData(topics: string): any | null;
    devicecontrols(topics: string, message_mqtt: any, message_control: any): Promise<void>;
    devicecontrol(topics: string, message_mqtt: any): Promise<void>;
    devicecontrolV2(topics: string, message_mqtt: any): Promise<void>;
    getdevicedatatopics(topics: any): Promise<void>;
    getdevicedata(topics: any): Promise<void>;
    getdevicedataALL(topics: any): Promise<void>;
    getdevicedataMqttV11(topics: any): Promise<void>;
    getdevicedataMqtt(topics: any): Promise<any>;
    private generateTimestamps;
    private cacheDataAsyncs;
    getdevicedataAll(topics: any): Promise<void>;
    getdevicedataDirec(topics: string): Promise<any>;
    AlarmDetailValidate(dto: any): Promise<{
        status: number;
        statusControl: number;
        alarmTypeId: number;
        type_id: number;
        alarmStatusSet: number;
        title: any;
        subject: string;
        content: string;
        value_data: any;
        value_alarm: any;
        value_relay: any;
        value_control_relay: any;
        dataAlarm: number;
        data_alarm: number;
        max: any;
        min: any;
        eventControl: number;
        messageMqttControl: string;
        sensor_data: any;
        count_alarm: number;
        mqttName: string;
        mqtt_name: any;
        device_name: any;
        mqtt_control_on: any;
        unit: any;
        sensorValue: any;
        statusAlert: number;
        statusWarning: number;
        recoveryWarning: number;
        recoveryAlert: any;
        deviceName: any;
        alarmActionName: any;
        mqttControlOn: any;
        mqttControlOff: any;
        event: any;
        timestamp: string;
    }>;
    alarm_device(dto: any): Promise<Devicealarmaction>;
    alarm_device_paginate_status(dto: any): Promise<Devicealarmaction>;
    device_lists_id(dto: any): Promise<Device>;
    devicetype(dto: any): Promise<DeviceType>;
    scheduleprocess(dto: any): Promise<Device>;
    scheduleprocesslog_count_status(dto: any): Promise<scheduleprocesslog>;
    scheduleprocesslog_count(dto: any): Promise<scheduleprocesslog>;
    update_scheduleprocesslog_v2(dto: any): Promise<number>;
    create(createMqtt2Dto: CreateMqtt2Dto): string;
    findAll(): string;
    findOne(id: number): string;
    update(id: number, updateMqtt2Dto: UpdateMqtt2Dto): string;
    remove(id: number): string;
}
export {};
