import { Repository } from 'typeorm';
import { DeviceType } from '@src/modules/settings/entities/devicetype.entity';
import { Setting } from '@src/modules/settings/entities/setting.entity';
import { Location } from '@src/modules/settings/entities/location.entity';
import { Type } from '@src/modules/settings/entities/type.entity';
import { Sensor } from '@src/modules/settings/entities/sensor.entity';
import { Group } from '@src/modules/settings/entities/group.entity';
import { Mqtt } from '@src/modules/settings/entities/mqtt.entity';
import { Deviceaction } from '@src/modules/settings/entities/deviceaction.entity';
import { Deviceactionlog } from '@src/modules/settings/entities/deviceactionlog.entity';
import { Deviceactionuser } from '@src/modules/settings/entities/deviceactionuser.entity';
import { Devicealarmaction } from '@src/modules/settings/entities/devivicealarmaction.entity';
import { Telegram } from '@src/modules/settings/entities//telegram.entity';
import { Api } from '@src/modules/settings/entities/api.entity';
import { Device } from '@src/modules/settings/entities/device.entity';
import { Email } from '@src/modules/settings/entities/email.entity';
import { Host } from '@src/modules/settings/entities/host.entity';
import { Influxdb } from '@src/modules/settings/entities/influxdb.entity';
import { Line } from '@src/modules/settings/entities/line.entity';
import { Nodered } from '@src/modules/settings/entities/nodered.entity';
import { Schedule } from '@src/modules/settings/entities/schedule.entity';
import { Sms } from '@src/modules/settings/entities/sms.entity';
import { Token } from '@src/modules/settings/entities/token.entity';
import { scheduleDevice } from '@src/modules/settings/entities/scheduledevice.entity';
import { scheduleprocesslog } from '@src/modules/settings/entities/scheduleprocesslog.entity';
import { alarmprocesslog } from '@src/modules/settings/entities/alarmprocesslog.entity';
import { mqttlog } from '@src/modules/iot/entities/mqttlog.entity';
import { ClientProxy } from '@nestjs/microservices';
import { MqttClient } from 'mqtt';
import { Observable } from 'rxjs';
interface MqttConnectionStatus {
    connected: boolean;
    lastConnectionTime: Date | null;
    error: any;
}
export declare class MqttService {
    private readonly client;
    private SettingRepository;
    private LocationRepository;
    private TypeRepository;
    private SensorRepository;
    private GroupRepository;
    private MqttRepository;
    private ApiRepository;
    private DeviceTypeRepository;
    private DeviceRepository;
    private EmailRepository;
    private HostRepository;
    private InfluxdbRepository;
    private LineRepository;
    private NoderedRepository;
    private ScheduleRepository;
    private SmsRepository;
    private TokenRepository;
    private scheduleDeviceRepository;
    private DeviceactionRepository;
    private DeviceactionlogRepository;
    private DeviceactionuserRepository;
    private DevicealarmactionRepository;
    private TelegramRepository;
    private scheduleprocesslogRepository;
    private alarmprocesslogRepository;
    private mqttlogRepository;
    private latestData;
    private mqttClient;
    private connectionStatus;
    private messageStream;
    private readonly logger;
    private messageStreams;
    private messageCache1;
    private subscribedTopics1;
    private isConnected;
    private connectionPromise;
    private subscribedTopics;
    private messageCache;
    constructor(client: ClientProxy, SettingRepository: Repository<Setting>, LocationRepository: Repository<Location>, TypeRepository: Repository<Type>, SensorRepository: Repository<Sensor>, GroupRepository: Repository<Group>, MqttRepository: Repository<Mqtt>, ApiRepository: Repository<Api>, DeviceTypeRepository: Repository<DeviceType>, DeviceRepository: Repository<Device>, EmailRepository: Repository<Email>, HostRepository: Repository<Host>, InfluxdbRepository: Repository<Influxdb>, LineRepository: Repository<Line>, NoderedRepository: Repository<Nodered>, ScheduleRepository: Repository<Schedule>, SmsRepository: Repository<Sms>, TokenRepository: Repository<Token>, scheduleDeviceRepository: Repository<scheduleDevice>, DeviceactionRepository: Repository<Deviceaction>, DeviceactionlogRepository: Repository<Deviceactionlog>, DeviceactionuserRepository: Repository<Deviceactionuser>, DevicealarmactionRepository: Repository<Devicealarmaction>, TelegramRepository: Repository<Telegram>, scheduleprocesslogRepository: Repository<scheduleprocesslog>, alarmprocesslogRepository: Repository<alarmprocesslog>, mqttlogRepository: Repository<mqttlog>);
    onModuleInit(): void;
    IsonModuleInit(connectUrl_mqtt: any): Promise<void>;
    isMqttConnected(): boolean;
    private subscribedTopic;
    private messageCached;
    getdevicedataDirecs(topics: string): Promise<any>;
    clearTopicCache(topic?: string): void;
    unsubscribeTopic(topic: string): void;
    onModuleDestroy(): void;
    initializeMqttClient(brokerUrl?: any): Promise<boolean>;
    private updateCache;
    getMqttData(topic: string): Promise<any>;
    publishMessage(topic: string, message: string | object): Promise<{
        success: boolean;
        error?: string;
    }>;
    subscribeToMultipleTopics(topics: string[]): Promise<{
        success: boolean;
        errors?: string[];
    }>;
    unsubscribeFromTopic(topic: string): Promise<{
        success: boolean;
        error?: string;
    }>;
    getConnectionStatus(): boolean;
    getDetailedConnectionStatus(): Promise<{
        isConnected: boolean;
        mqttClientConnected: boolean;
        subscribedTopics: string[];
        cacheSize: number;
    }>;
    clearCache(): void;
    clearTopicCached(topic: string): void;
    getCachedData(topic: any): Promise<any>;
    hasCachedData(topic: string): boolean;
    disconnect(): Promise<void>;
    reconnect(brokerUrl?: string): Promise<boolean>;
    waitForConnection(timeoutMs?: number): Promise<boolean>;
    getMqttClient(): MqttClient | null;
    getSubscribedTopics(): string[];
    getCacheStats(): {
        size: number;
        keys: string[];
    };
    subscribeToTopicWithResponse(topic: string, timeoutMs?: number): Promise<any>;
    subscribeToTopic(topic: string, returnAsPromise?: boolean, timeoutMs?: number): Observable<any> | Promise<any>;
    private cacheTimeout;
    getDataTopics(topics: string): Promise<any>;
    private subscribeToTopicS;
    private waitForMessage;
    private generateTimestamp;
    private processPayload;
    private cacheResult;
    private buildResponse;
    private delay;
    getMqttConnectionStatus(): MqttConnectionStatus;
    checkConnectionStatus(): void;
    checkConnectionStatusMqtt(): Promise<{
        isConnected: any;
        connected: any;
        status: any;
        msg: string;
    }>;
    checkConnectionStatusMqtts(UrlMqtt: any): Promise<{
        url: any;
        isConnect: any;
        isConnected: any;
        connected: any;
        status: any;
        msg: string;
    }>;
    getDataTopicCacheDataMqtt(topics: string): Promise<any>;
    getdMqttdataTopics(topics: any): Promise<void>;
    getMqttTopicData(topics: string, deletecache: any): Promise<any>;
    getMqttTopicDataRS(topics: any, deletecache: any): Promise<void>;
    _getMqttTopicData(topics: string, deletecache: any): Promise<any>;
    getMqttTopicDataV1(topics: string, deletecache: any): Promise<any>;
    getMqttTopicS(topics: string, deletecache: any): Promise<any>;
    getDataTopicCacheData(topics: string): Promise<any>;
    getDataTopic2(topics: string): Promise<any>;
    getDataTopicdevicemqtt(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getDataTopic(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getDataTopicPage(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicPA(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    waitForMessageWithTimeout(topic: string, timeout: number): Promise<any>;
    getMqttTopicPA1(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopic(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicTest(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicSS(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    _2_getMqttTopic(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicSlow(topics: string, deletecache: any, retryCount?: number): Promise<any>;
    getMqttTopicFast(topics: string): Promise<any>;
    getDataTopicMqtt(topics: string): Promise<any>;
    getDataTopicCache(topics: string, deletecache: any): Promise<any>;
    getDataFromTopics(topics: string): Promise<string>;
    getDataFromTopicsOL(topics: string): Promise<string>;
    getDataFromTopic(topics: string): Promise<any>;
    _getDataFromTopic(topics: string): Promise<any>;
    publishs(topics: string, payload: any): void;
    publish(topics: string, payload: any): Promise<void>;
    updateData(topics: string, payload: any): Promise<void>;
    getData(topics: string): Promise<any | null>;
    cacheMqttData(topics: string, payload: any): Promise<void>;
    getDataFromCache(topics: string): Promise<any | null>;
    updateLatestData(topics: string, payload: any): void;
    getLatestData(topics: string): any | null;
    devicecontrols(topics: string, message_mqtt: any, message_control: any): Promise<void>;
    devicecontrol(topics: string, message_mqtt: any): Promise<void>;
    devicecontrolV2(topics: string, message_mqtt: any): Promise<void>;
    getdevicedatatopics(topics: any): Promise<void>;
    getdevicedata(topics: any): Promise<void>;
    getdevicedataALL(topics: any): Promise<void>;
    getdevicedataMqttV11(topics: any): Promise<void>;
    getdevicedataMqtt(topics: any): Promise<any>;
    private generateTimestamps;
    private cacheDataAsyncs;
    getdevicedataAll(topics: any): Promise<void>;
    getdevicedataDirec(topics: string): Promise<any>;
    mqtt_all(): Promise<Mqtt>;
    mqtt_list_paginate(dto: any): Promise<Mqtt>;
    mqtt_list_paginate_active(dto: any): Promise<Mqtt>;
    mqtt_list_paginate_active_air(dto: any): Promise<Mqtt>;
    mqtt_list_paginate_active_fan_app(dto: any): Promise<Mqtt>;
    mqtt_list_paginate_active_fan(dto: any): Promise<Mqtt>;
    mqtt_list_paginate_all_data(dto: any): Promise<Mqtt>;
    create_mqttlogRepository(dto: any): Promise<mqttlog>;
    mqttlog_paginate(dto: any): Promise<mqttlog>;
}
export {};
